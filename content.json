{"meta":{"title":"XiaochenCui_Blog","subtitle":"千里之行 始于足下","description":"崔晓晨的个人博客","author":"Xiaochen Cui","url":"http://www.cuixiaochen.com"},"pages":[{"title":"XiaochenCui_Blog | 404","date":"2016-08-14T07:13:15.196Z","updated":"2016-08-10T12:58:10.732Z","comments":false,"path":"404.html","permalink":"http://www.cuixiaochen.com/404.html","excerpt":"","text":""},{"title":"","date":"2016-08-14T07:13:17.812Z","updated":"2016-08-10T09:36:20.135Z","comments":false,"path":"tags/index.html","permalink":"http://www.cuixiaochen.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"N皇后问题解法汇总及分析(python)","slug":"N皇后问题解法汇总及分析-python","date":"2016-08-18T12:26:29.000Z","updated":"2016-08-18T13:22:39.717Z","comments":true,"path":"2016/08/18/N皇后问题解法汇总及分析-python/","link":"","permalink":"http://www.cuixiaochen.com/2016/08/18/N皇后问题解法汇总及分析-python/","excerpt":"N皇后问题是回溯算法的典型案例，本文通过N皇后问题复习递归/回溯算法并运用一些python函数库简化程序。","text":"N皇后问题是回溯算法的典型案例，本文通过N皇后问题复习递归/回溯算法并运用一些python函数库简化程序。 最容易理解的递归解法123456789101112131415161718192021222324252627282930313233343536373839404142434445class Solution(object): def __init__(self): # board存储一种解法（作为缓存） self.board = [] # boards存储所有解法（作为结果） self.boards = [] def solve_n_queens(self, n): \"\"\" :param n: int: :return: self.boards: list[list[int]] \"\"\" self.board = [0 for i in range(n)] self.solve_line(0, n) return self.boards # 解决前row列 def solve_line(self, row, n): if row == n: self.boards.append([i for i in self.board]) return else: for col in range(n): if self.is_valid(row, col): self.board[row] = col self.solve_line(row + 1, n) self.board[row] = 0 # 监测(row,col)是否与0~row-1行发生冲突 def is_valid(self, row, col): for i in range(row): if self.board[i] == col: return False if i+self.board[i] == row+col: return False if i-self.board[i] == row-col: return False return True if __name__ == '__main__': s = Solution() r = s.solve_n_queens(8) for i in r: print(i) Raymond Hettingers 的解法（使用permutations）12345678from itertools import permutations n = 8cols = range(n)for vec in permutations(cols): if n == len(set(vec[i]+i for i in cols)) \\ == len(set(vec[i]-i for i in cols)): print ( vec ) 这个解法由 Raymond Hettingers 编写，展示了 itertools 模块的魅力。 Raymond Hettingers 对这个解法的解释： 由于解（由vector表示）中每一个元素代表棋盘的一行，所以不用检测棋子是否在同一行。同时，由于使用了生成器（generator）permutation，vector中的每个元素都是不同的，所以不用检测棋子是否在同一列。因此，我们只需要检测是否存在斜线冲突。 检测斜线冲突的办法是将每一个元素加上/减去它的索引（即每一个棋子的列序号加上/减去它的行序号）。这样，在斜线上冲突的棋子将会呈现出相同的值。然后将所有棋子相加/相减后的索引放入一个set中，再比较set的大小与n的值，即可得知是否发生了斜线冲突。 所有不发生斜线冲突的全排列都是一个解，将它们输出。 这个解法的缺陷在于不能跳过已经被证实为不可行的前缀，如（1,2,…）。这些前缀会在多种全排列中被反复测试。 Steve Howell 的解法这个解法来自于 Steve Howell 1234567891011121314151617# From: http://wiki.python.org/moin/SimplePrograms, with permission from the author, Steve HowellBOARD_SIZE = 8 def under_attack(col, queens): return col in queens or \\ any(abs(col - x) == len(queens)-i for i,x in enumerate(queens)) def solve(n): solutions = [[]] for row in range(n): solutions = [solution+[i+1] for solution in solutions for i in range(BOARD_SIZE) if not under_attack(i+1, solution)] return solutions for answer in solve(BOARD_SIZE): print(list(enumerate(answer, start=1))) 由 Steve Howell 的解法改进而来的回溯解法把上面的 Steve Howell 的解法中的list表达式替换为generator表达式，便形成了一种回溯解法： 12345678910111213141516171819BOARD_SIZE = 8 def under_attack(col, queens): return col in queens or \\ any(abs(col - x) == len(queens)-i for i,x in enumerate(queens)) def solve(n): solutions = [[]] for row in range(n): solutions = (solution+[i+1] for solution in solutions # first for clause is evaluated immediately, # so \"solutions\" is correctly captured for i in range(BOARD_SIZE) if not under_attack(i+1, solution)) return solutions answers = solve(BOARD_SIZE)first_answer = next(answers)print(list(enumerate(first_answer, start=1))) 基于permutations的回溯解法参考链接 N-queens problem - Rosetta Code Accepted 4ms c++ solution use backtracking and bitmask, easy understand. | LeetCode Discuss （未完待续）","categories":[],"tags":[{"name":"python","slug":"python","permalink":"http://www.cuixiaochen.com/tags/python/"},{"name":"算法","slug":"算法","permalink":"http://www.cuixiaochen.com/tags/算法/"}]},{"title":"Matplotlib 制作可视化累加器(visual accumulator)","slug":"Matplotlib-制作可视化累加器-visual-accumulator","date":"2016-08-01T03:05:19.000Z","updated":"2016-08-13T07:15:10.342Z","comments":true,"path":"2016/08/01/Matplotlib-制作可视化累加器-visual-accumulator/","link":"","permalink":"http://www.cuixiaochen.com/2016/08/01/Matplotlib-制作可视化累加器-visual-accumulator/","excerpt":"用matplotlib制作的可视化累加器，主要用于查找算法的可视化。","text":"用matplotlib制作的可视化累加器，主要用于查找算法的可视化。 matplotlib 简介matplotlib 是一个2D的python图形库,主要用于在多个平台上生产可交互的高质量图像，并提供多种文件格式供保存。matplotlib可用于多种python平台（如：python shell,ipython,web应用,以及六种gui toolkits）。 例如： 可视化累加器用于查找及搜索算法的可视化，动态显示算法的时间消耗。 api123456789class VisualAccumulator(object): def add_point(self, x, y): # 在图片上添加点(x, y) ... def add_data_value(self, value=0): # 添加数据value，并计算平均值 ... 实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374import warningsimport matplotlib.cbookimport matplotlib.pyplot as pltfrom matplotlib.pyplot import xlim,ylimfrom pylab import plot,gcfwarnings.filterwarnings(\"ignore\",category=matplotlib.cbook.mplDeprecation) class VisualAccumulator(object): plt.figure(num=None, figsize=(8, 6), dpi=100, facecolor='w', edgecolor='k') plt.ion() ax = plt.gca() ax.set_autoscale_on(True) fig = gcf() fig.canvas.set_window_title('VisualAccumulator') line, = plot([], [], linestyle='none', marker='.', color='grey', lw=0.2) line_ave, = plot([], [], linestyle='none', marker='.', color='black', lw=0.2) xdata, ydata = [], [] xdata_ave, ydata_ave = [], [] def __init__(self, x=1000, y=1000): self.n = 0 self.total = 0 xlim(0, x) ylim(0, y) def add_point(self, x, y, ave=False): if not ave: # add data to xdata and ydata self.xdata.append(x) self.ydata.append(y) self.line.set_data(self.xdata, self.ydata) else: # add data to xdata_ave and ydata_ave self.xdata_ave.append(x) self.ydata_ave.append(y) self.line_ave.set_data(self.xdata_ave, self.ydata_ave) # Recompute the data limits based on current artists. # Artist: Abstract base class for someone who renders into a FigureCanvas. self.ax.relim() # autoscale_view(tight=None, scalex=True, scaley=True): # Autoscale the view limits using the data limits. self.ax.autoscale_view(True, True, True) xmin, xmax = xlim() if x&gt;=xmax: xlim(xmin,xmax*1.5) ylim(xlim()) plt.draw() plt.pause(0.00000000000001) def add_data_value(self, value=0): self.n +=1 self.total += value self.add_point(self.n, value) self.add_point(self.n, self.total/self.n, ave=True) # 测试用例if __name__ == '__main__': va_test = VisualAccumulator(20, 20) va_test.add_data_value(3) va_test.add_data_value(7) va_test.add_data_value(15) va_test.add_data_value(2) plt.pause(10) 应用可视化查找算法，如：顺序查找 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354class SequentialSearchST(object): def __init__(self): ... def get(self, key): # 根据指定的key返回data，没找到key则返回None ... def put(self, key, data): # 将指定的key的data值置为data，没找到key则插入为头节点 ... def __contains__(self, key): # 判断指定的key值是否存在 ... @property def keys(self): # 以列表形式返回所有key ... @timeitdef main(file, n=None): va = VisualAccumulator(20,20) st = SequentialSearchST() with open(file, 'r') as f: for line in f: for word in line.split(): if len(word) &lt; n: continue elif word not in st: cmp_times = st.put(word, 1) va.add_data_value(cmp_times) else: cmp_times = st.put(word, st.get(word) + 1) va.add_data_value(cmp_times) st.max.data = 0 for key in st.keys: tmp = st.get(key) if tmp &gt; st.max.data: st.max.key = key st.max.data = tmp print(st.max) if __name__ == '__main__': min_len = 8 # 查找双城记的前2000行，过滤长度小于8的单词 main(file='tale2k.txt', n=min_len) 查找过程： 运行结果：","categories":[],"tags":[{"name":"matplotlib","slug":"matplotlib","permalink":"http://www.cuixiaochen.com/tags/matplotlib/"},{"name":"python","slug":"python","permalink":"http://www.cuixiaochen.com/tags/python/"},{"name":"算法","slug":"算法","permalink":"http://www.cuixiaochen.com/tags/算法/"}]},{"title":"Bash script 笔记（一）","slug":"Bash-script-笔记（一）","date":"2016-07-03T06:55:32.000Z","updated":"2016-08-11T02:36:58.862Z","comments":true,"path":"2016/07/03/Bash-script-笔记（一）/","link":"","permalink":"http://www.cuixiaochen.com/2016/07/03/Bash-script-笔记（一）/","excerpt":"记录 bash script 中一些容易写错的语法","text":"记录 bash script 中一些容易写错的语法 I/O Redirection参考: I/0 Redirection source参考: Source command - Linux Shell Scripting Tutorial - A Beginner’s handbookThe source command can be used to load any functions file into the current shell script or a command prompt. $@$@ is all of the parameters passed to the script. $?$? is the return code (status code) of the last command or script executed.0 == success, any other number means a failure local声明一个局部变量 awk参考: How To Use awk In Bash Scripting (未完待续)","categories":[],"tags":[{"name":"bash script","slug":"bash-script","permalink":"http://www.cuixiaochen.com/tags/bash-script/"}]},{"title":"flask-mail 探究","slug":"flask-mail-探究","date":"2016-06-30T12:32:01.000Z","updated":"2016-08-11T02:36:34.927Z","comments":true,"path":"2016/06/30/flask-mail-探究/","link":"","permalink":"http://www.cuixiaochen.com/2016/06/30/flask-mail-探究/","excerpt":"mail发送中文，附件等问题","text":"mail发送中文，附件等问题 由FLASKY_MAIL_SENDER = ‘Flasky Admin flasky@example.com‘配置项所引发的问题","categories":[],"tags":[{"name":"flask","slug":"flask","permalink":"http://www.cuixiaochen.com/tags/flask/"}]},{"title":"Bash script 快速入门指南（译）","slug":"Bash-script-快速入门指南（译）","date":"2016-06-15T03:04:28.000Z","updated":"2016-08-13T07:08:39.961Z","comments":true,"path":"2016/06/15/Bash-script-快速入门指南（译）/","link":"","permalink":"http://www.cuixiaochen.com/2016/06/15/Bash-script-快速入门指南（译）/","excerpt":"原文地址： bash-tute","text":"原文地址： bash-tute 使用 Bash shell 编写脚本(script)的入门指南一个简单的 shell script一个 shell script 不只是将多个指令简单地排列在一起并运行。一般来说，shell script 应该在第一行作如下声明： 1#!/bin/bash 这行声明会指定 script 运行在 bash shell 中，而不管用户当前使用的是哪一种交互式 shell 。不同的shell语法差异很大，所以这行声明非常重要。 一个简单的例子以下是一个简单的shell script例子： 1234#!/bin/bashecho &quot;hello, $USER. I wish to list some files of yours&quot;echo &quot;listing files in the current directory, $PWD&quot;ls # list files 首先，注意第４行。在一个bash script中，跟在符号#后面的被视作注释（除了第一行的shell声明），shell 将会忽略注释。注释的作用是帮助人们阅读script。 \\$USER 和 \\$PWD 是变量。这两个变量属于被shell预定义的标准变量，他们不需要在script中特别定义。如果变量名在双引号内部，这个变量将会被被展开。展开表示shell将会先用变量的值替换变量，然后再执行指令。 接下来我们会详细讨论变量。 变量所有编程语言都需要变量。定义变量的方法如下： 1X=&quot;hello&quot; 引用变量的方法如下： 1$X $X表示的是变量X的值。在语法上要注意以下几点： 符号 = 两边不能有空格。这样写是错误的： 1X = hello 双引号并不是必需的，但当变量的值中包含空格时，就必须加双引号，如： 12X=hello world # 错误X=&quot;hello world&quot; # 正确 这是因为shell会把命令行解析为一堆命令以及被空格分隔的命令参数。foo=baris 被解析为一个命令。但foo = bar会被错误地解析，foo因为被空格分隔导致它被解析成了一个单独的命令。同理，X=hello world也是错误的。 单引号 VS 双引号一般情况下，将变量名包在双引号里可以使变量展开。单引号则不会展开变量。 例子 1234#!/bin/bashecho -n &apos;$USER=&apos; # -n option stops echo from breaking the lineecho &quot;$USER&quot;echo &quot;\\$USER=$USER&quot; # this does the same thing as the first two lines 输出结果如下（假设你的用户名是elford） 12$USER=elflord$USER=elflord 综上，双引号更灵活，单引号更直观。所以，当两种引号都可以用的时候优先选择单引号。 使用引号保护你的变量用引号保护变量很管用。当变量中包含空格或者变量是一个空的字符串时，更需要用引号保护变量。例如： 12345#!/bin/bashX=&quot;&quot;if [ -n $X ]; then # -n tests to see if the argument is non empty echo &quot;the variable X is not the empty string&quot;fi 输出结果： 1the variable X is not the empty string # 错误 这里出现的结果不符合预期是因为shell把$X展开成了空字符串，所以表达式[-n]返回true(此时-n没有参数，返回true)。正确的script应该这样写： 12345#!/bin/bashX=&quot;&quot;if [ -n &quot;$X&quot; ]; then # -n tests to see if the argument is non empty echo &quot;the variable X is not the empty string&quot;fi 在这个例子中，表达式被展开为[ -n “” ]，并返回false。因为-n被给予参数””(空字符串)。 变量在运行时会被展开下面这个例子可以证明shell确实“展开”了变量（就像前文提到的一样）： 12345#!/bin/bashLS=&quot;ls&quot;LS_FLAGS=&quot;-al&quot;$LS $LS_FLAGS $HOME 这个script的最后一行实际上执行了下面这个指令： 1ls -al /home/elflord # （假设你的home目录在/home/elford） 这个script的机制是：shell将变量替换为变量的值，然后执行指令。 使用大括号保护你的变量假设你想输出变量X的值，然后紧接着输出字母”abc”。那么应该如何做？先试一下这样写： 123#!/bin/bashX=ABCecho &quot;$Xabc&quot; 输出为空，因为shell认为我们在请求变量Xabc，而变量Xabc并未被定义。解决的办法是用大括号将变量X与其它字母隔开： 123#!/bin/bashX=ABCecho &quot;$&#123;X&#125;abc&quot; 条件语句，if/then/elif条件语句if…的语法如下： 123456if conditionthen statement1 statement2 ..........fi if…else…的语法如下： 12345678if conditionthen statement1 statement2 ..........else statement3fi 此外，你还可以在if后面使用多个elif： 1234567891011121314151617if condition1then statement1 statement2 ..........elif condition2then statement3 statement4 ........ elif condition3then statement5 statement6 ........ fi 在实际使用中，任何指令都可以作为分支判断条件。当指令返回值为０时（也就是说指令运行的结果为成功），相应代码块中的指令就会开始执行。在本文中，我们只使用”test”或”[ ]”执行判断。 Test指令与操作判断条件中的指令大多数时候都是test指令。Test根据各操作的成功或失败来返回真或假（更准确地说，以０或非０状态退出），例如： 1test operand1 operator operand2 如果在test中只需要一个操作数，那么test指令可以简写为： 1[ operand1 operator operand2 ] 用法实例： 1234567891011121314151617181920212223#!/bin/bashX=3Y=4empty_string=&quot;&quot;if [ $X -lt $Y ] # is $X less than $Y ? then echo &quot;\\$X=$&#123;X&#125;, which is smaller than \\$Y=$&#123;Y&#125;&quot;fiif [ -n &quot;$empty_string&quot; ]; then echo &quot;empty string is non_empty&quot;fiif [ -e &quot;$&#123;HOME&#125;/.fvwmrc&quot; ]; then # 测试 ~/.fvwmrc 是否存在 echo &quot;you have a .fvwmrc file&quot; if [ -L &quot;$&#123;HOME&#125;/.fvwmrc&quot; ]; then # 测试 ~/.fvwmrc 是否是符号链接(symbolic link) echo &quot;it&apos;s a symbolic link elif [ -f &quot;$&#123;HOME&#125;/.fvwmrc&quot; ]; then # 测试 ~/.fvwmrc 是否是常规文件(regular file) echo &quot;it&apos;s a regular file&quot; fielse echo &quot;you have no .fvwmrc file&quot;fi 一些需要注意的地方test指令的正确格式是“操作数&lt;空格&gt;操作符&lt;空格&gt;操作数”或者“操作符&lt;空格&gt;操作数”，空格是必需的。如果第一个连续字符串以’-‘开头，它会被解析为操作符，否则被解析为操作数。例如: 123if [ 1=2 ]; then echo &quot;hello&quot;fi 将会输出hello，因为shell找到了一个操作数，但没有找到任何操作符。 另一个需要注意的是引号，不用引号保护变量有可能造成bug。如： 123456#!/bin/bashX=&quot;-n&quot;Y=&quot;&quot;if [ $X = $Y ] ; then echo &quot;X=Y&quot;fi 这个script不会输出预期的结果，因为shell将表达式展开为： 1[ -n = ] 然而字符串”=”的长度不为０。 test操作符的简短总结常用的test操作符： 操作符 返回值为真的情况 操作数的个数 -n 操作数不为０（或长度不为０） 1 -z 操作数为０（或长度为０） 1 -d 操作的目录存在 1 -f 操作的文件存在 1 -eq 两个操作数为整数且相等 2 -neq 两个操作数为整数且不相等 2 = 两个操作数相等（可比较字符串） 2 != 两个操作数不相等（可比较字符串） 2 -lt 操作数１小于操作数２（且都为整数） 2 -gt 操作数１大于操作数２（且都为整数） 2 -ge 操作数１大于等于操作数２（且都为整数） 2 -le 操作数１小于等于操作数２（且都为整数） 2 循环在bash中，循环分为两种： for循环 while循环 for 循环for 循环用法实例： 12345#!/bin/bashfor X in red green bluedo echo $Xdone for循环会遍历用空格分隔的各项（如果单项里面包含空格，则需要用引号保护这一项）。例如： 12345678#!/bin/bashcolour1=&quot;red&quot;colour2=&quot;light blue&quot;colour3=&quot;dark green&quot;for X in &quot;$colour1&quot; $colour2&quot; $colour3&quot;do echo $Xdone 当不确定遍历的项中是否包含空格时，用引号保护它。 for循环中的通配符符号 * 可以匹配任意字符串。如： 1echo * 会输出当前目录下的所有文件和文件夹。 1echo *.jpg 会输出所有jpeg文件。 1echo $&#123;HOME&#125;/public_html/*.jpg 会输出public_html目录下的所有jpeg文件。 如上所示，* 通配符在操作文件时十分管用，尤其是用在for循环中，如： 12345#!/bin/bashfor X in *.htmldo grep -L &apos;&lt;UL&gt;&apos; &quot;$X&quot; # 通过正则匹配查找目录下所有html文件中的ul标签done while循环while循环在条件判断为真时执行内部代码块，如： 1234567#!/bin/bashX=0while [ $X -le 20 ]do echo $X X=$((X+1))done bash不允许C语言风格的for循环： 1for (X=1,X&lt;10; X++) 不允许for循环的其中一个原因是：bash是一种解释型语言，所以它的执行效率很低，正因如此，重型循环(heavy iteration)不被允许。 指令替换在bash中，指令替换是一个很有用的功能，它帮助你使用某条指令的输出去执行另一条指令。例如：把一条指令的输出设为变量X的值。 指令替换有两种方式： 括号展开 反引号展开(``) 括号展开的格式为：$(commands) ，它将会被展开为commands的输出。括号展开允许嵌套，所以commands中可以包含括号展开。 反引号展开则将 commands 展开为 commands 的输出。 例如： 1234567#!/bin/bashfiles=&quot;$(ls)&quot;web_files=`ls public_html`echo &quot;$files&quot; # 用双引号保护内部的空格echo &quot;$web_files&quot; # 用双引号保护内部的空格X=`expr 3 \\* 2 + 4` # 利用 expr 进行运算echo &quot;$X&quot; 括号展开的优势在于容易嵌套。而且大多数 bourne shell 的变种都支持括号展开 （如：POSIX）。然而反引号展开的可读性更强，而且最基础的 shell 都能支持它（如：#!/bin/sh 的所有版本） 注：上例中echo表达式中的字符串必须用引号保护。","categories":[],"tags":[{"name":"bash script","slug":"bash-script","permalink":"http://www.cuixiaochen.com/tags/bash-script/"}]},{"title":"Mongodb 常见报错及解决方案","slug":"Mongodb-常见报错及解决方案","date":"2016-05-20T06:55:35.000Z","updated":"2016-08-11T02:35:45.103Z","comments":true,"path":"2016/05/20/Mongodb-常见报错及解决方案/","link":"","permalink":"http://www.cuixiaochen.com/2016/05/20/Mongodb-常见报错及解决方案/","excerpt":"最近在使用mongodb的过程中遇到了一些棘手的错误，所以做了一个笔记以供参考","text":"最近在使用mongodb的过程中遇到了一些棘手的错误，所以做了一个笔记以供参考 WARNING: soft rlimits too low. rlimits set to processes, files. Number of processes should be at least 32767.5 : 0.5 times number of files. 解决方案: 切换至root用户，更改相关设置 查看ulimit: 1$ ulimit -a 更改相关ulimit: 1$ ulimit -n &lt;value&gt; 推荐设置: 123456-f (file size): unlimited-t (cpu time): unlimited-v (virtual memory): unlimited [1]-n (open files): 64000-m (memory size): unlimited [1] [2]-u (processes/threads): 64000 重启mongodb 参考: UNIX ulimit Settings — MongoDB Manual 3.2 BadValue Invalid or no user locale set. Please ensure LANG and/or LC_* environment variables are set correctly 解决方案: 设置locale 设置 /etc/default/locale 为: 123LANG=en_US.UTF-8LANGUAGE=en_USLC_ALL=en_US.UTF-8 或者: 123LANG=&quot;en_US.UTF-8&quot;LANGUAGE=&quot;en_US:en&quot;LC_ALL=&quot;en_US.UTF-8&quot; 重启mongodb 参考: virtualbox - error in installing mongo in virtual machine - Ask Ubuntu","categories":[],"tags":[{"name":"mongodb","slug":"mongodb","permalink":"http://www.cuixiaochen.com/tags/mongodb/"}]}]}