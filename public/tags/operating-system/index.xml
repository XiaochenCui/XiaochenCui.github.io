<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>operating system on XiaochenCui&#39;s Blog</title>
    <link>https://cuixiaochen.com/tags/operating-system/</link>
    <description>Recent content in operating system on XiaochenCui&#39;s Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Tue, 17 Apr 2018 22:00:19 +0000</lastBuildDate>
    
	<atom:link href="https://cuixiaochen.com/tags/operating-system/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>操作系统学习笔记：第一章习题及解答</title>
      <link>https://cuixiaochen.com/posts/operation-system-study-notes-2/</link>
      <pubDate>Tue, 17 Apr 2018 22:00:19 +0000</pubDate>
      
      <guid>https://cuixiaochen.com/posts/operation-system-study-notes-2/</guid>
      <description>&lt;h1 id=&#34;习题&#34;&gt;习题&lt;/h1&gt;

&lt;ol&gt;
&lt;li&gt;什么是 multiprogramming？&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;在第二代操作系统（如 7094 机）上，若当前作业因等待磁带或其他 I/O 操作而暂停时，CPU 就只能简单地原地踏步直至该 I/O 完成。在很多情况下，I/O 操作等待的时间通常占到 80% ~ 90%, 所以要通过 multiprogramming 的方式来减少 CPU 资源的浪费。&lt;/p&gt;

&lt;p&gt;具体方案就是将内存分成多个部分，每个部分存放不同的作业（如下图所示），当一个作业等待 I/O 操作完成时，另一个作业可以使用 CPU。如果内存中可以同时存放足够多的作业，则 CPU 利用率可以接近 100%。（注意：在内存中同时驻留多个作业需要特殊的硬件来对其进行保护，以避免作业对信息被窃取或受到攻击。）
 {% asset_img multi-programmed-system.jpg %}&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>操作系统学习笔记：基本概念</title>
      <link>https://cuixiaochen.com/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%80%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/</link>
      <pubDate>Sun, 07 Jan 2018 15:29:54 +0000</pubDate>
      
      <guid>https://cuixiaochen.com/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%80%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/</guid>
      <description>&lt;p&gt;几个基本概念的简要介绍&lt;/p&gt;

&lt;h1 id=&#34;进程&#34;&gt;进程&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;进程 (process) 本质上是正在执行的一个程序。&lt;/li&gt;
&lt;li&gt;与每个进程相关的是进程的地址空间 (address space), 这是从某个最小值的存储位置（通常是零）到某个最大值存储位置的列表。在这个地址空间中，进程可以进行读写。&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
  </channel>
</rss>