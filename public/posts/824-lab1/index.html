<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="Hugo 0.57.2" />

  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="author" content="" />
  <meta property="og:url" content="https://cuixiaochen.com/posts/824-lab1/" />
  <link rel="canonical" href="https://cuixiaochen.com/posts/824-lab1/" /><script type="application/ld+json">
  {
      "@context" : "http://schema.org",
      "@type" : "BlogPosting",
      "mainEntityOfPage": {
           "@type": "WebPage",
           "@id": "https:\/\/cuixiaochen.com\/"
      },
      "articleSection" : "posts",
      "name" : "MIT6.824 Lab 1 - MapReduce",
      "headline" : "MIT6.824 Lab 1 - MapReduce",
      "description" : "\x3ch1 id=\x22前言\x22\x3e前言\x3c\/h1\x3e\n\n\x3cp\x3eMIT6.824 是一门久负盛名的分布式系统课程，今天开始我将会将课程中的系统作业、学习感悟写在专栏 \x3ca href=\x22\/categories\/MIT6-824-Labs\/\x22\x3eMIT6.824 Labs\x3c\/a\x3e 中，与大家一起学习这门非常有趣的课程\x3c\/p\x3e",
      "inLanguage" : "en-US",
      "author" : "",
      "creator" : "",
      "publisher": "",
      "accountablePerson" : "",
      "copyrightHolder" : "",
      "copyrightYear" : "2018",
      "datePublished": "2018-09-10 21:30:17 \x2b0000 UTC",
      "dateModified" : "2018-09-10 21:30:17 \x2b0000 UTC",
      "url" : "https:\/\/cuixiaochen.com\/posts\/824-lab1\/",
      "keywords" : [ "distributed systems", ]
  }
</script>
<title>MIT6.824 Lab 1 - MapReduce - XiaochenCui&#39;s Blog</title>
  <meta property="og:title" content="MIT6.824 Lab 1 - MapReduce - XiaochenCui&#39;s Blog" />
  <meta property="og:type" content="article" />
  <meta name="description" content="前言

MIT6.824 是一门久负盛名的分布式系统课程，今天开始我将会将课程中的系统作业、学习感悟写在专栏 MIT6.824 Labs 中，与大家一起学习这门非常有趣的课程" />

  <link rel="stylesheet" href="https://unpkg.com/flexboxgrid@6.3.1/dist/flexboxgrid.min.css" />
  <link rel="stylesheet"
    href="https://cdnjs.cloudflare.com/ajax/libs/github-markdown-css/2.10.0/github-markdown.min.css" />
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.13.1/styles/tomorrow.min.css" />
  <link rel="stylesheet" href="/css/index.css">
  <link href="/index.xml" rel="alternate" type="application/rss+xml" title="XiaochenCui&#39;s Blog">
  
  <link href="https://fonts.googleapis.com/css?family=Arvo|Permanent+Marker" rel="stylesheet">
  
  <script>
    

    (function (undefined) { }).call('object' === typeof window && window || 'object' === typeof self && self || 'object' === typeof global && global || {});
  </script>

  
</head>

<body>
  <article class="post " id="article">
    <div class="row">
      <div class="col-xs-12 col-sm-10 col-md-8 col-sm-offset-1 col-md-offset-2 col-lg-6 col-lg-offset-3">
        <div class="site-header">
          
<header>
  <div class="signatures site-title">
    <a href="/">Xiaochen Cui</a>
  </div>
</header>
<div class="row end-xs">
  
  
</div>
<div class="header-line"></div>

        </div>
        <header class="post-header">
          <h1 class="post-title">MIT6.824 Lab 1 - MapReduce</h1>
          
        </header>

        <div class="post-content markdown-body">
          <h1 id="前言">前言</h1>

<p>MIT6.824 是一门久负盛名的分布式系统课程，今天开始我将会将课程中的系统作业、学习感悟写在专栏 <a href="/categories/MIT6-824-Labs/">MIT6.824 Labs</a> 中，与大家一起学习这门非常有趣的课程</p>

<p>完整代码（含答案）见 <a href="https://github.com/XiaochenCui/mit6.824">github</a></p>

<h1 id="mapreduce">MapReduce</h1>

<p>MapReduce 的具体架构及思想 <a href="https://pdos.csail.mit.edu/6.824/papers/mapreduce.pdf">paper</a> 中已经讲的很详细了，在此不再赘述，仅贴出架构图供大家复习：</p>

<p>{% asset_img mr.jpg %}</p>

<h1 id="习题讲解">习题讲解</h1>

<h2 id="part-i-map-reduce-input-and-output">Part I: Map/Reduce input and output</h2>

<p>要求完成 doMap 和 doReduce 函数</p>

<h3 id="domap">doMap</h3>

<p><code>doMap</code> 函数执行一个 map 任务，它的运行流程如下：
1. 读取输入文件 (inFile)
1. 调用用户编写的 map 函数 (mapF) 处理输入文件
1. 然后将 map 函数的输出分片到 r 个缓存文件中（其中 r 为 reduce task 的个数）</p>

<p>Tips：
1. map 函数的输出为键值对列表
1. 使用 <code>ihash</code> 确定输出文件索引值的目的是为了使输出均匀分布，且对于不同的 worker，同一个 key 会落在 reduce index 相同的输出文件
1. 空间复杂度为 O(n)，其中 n 为 key 的个数
1. 读取文件使用 <a href="https://golang.org/pkg/io/ioutil/#ReadFile">ioutil#ReadFile</a>
1. 将 KeyValue 写入文件可以用 <a href="https://golang.org/pkg/encoding/json/#Encoder">encoding/json#Encoder</a></p>

<pre><code class="language-go">func doMap(
    jobName string, // the name of the MapReduce job
    mapTask int, // which map task this is
    inFile string,
    nReduce int, // the number of reduce task that will be run (&quot;R&quot; in the paper)
    mapF func(filename string, contents string) []KeyValue,
) {
    // Read content of inFile
    data, err := ioutil.ReadFile(inFile)
    if err != nil {
        log.Printf(&quot;Error: %v&quot;, err)
    }

    // Execute map function
    keyValuePairs := mapF(inFile, string(data[:len(data)]))

    // Split the keyValuePairs into a multidimensional array whose size is the
    // number of reduce tasks
    divided := make([][]KeyValue, nReduce)
    for _, keyValue := range keyValuePairs {
        index := ihash(keyValue.Key) % nReduce
        divided[index] = append(divided[index], keyValue)
    }
    debug(&quot;%#v&quot;, divided)

    // Write divided keyValuePairs to R files, where R is the number of reduce
    // tasks
    for i, subKeyValuePairs := range divided {
        // Get filename for output
        filePath := reduceName(jobName, mapTask, i)

        // Create output file
        f, err := os.Create(filePath)
        if err != nil {
            log.Printf(&quot;Error: %v&quot;, err)
        }
        enc := json.NewEncoder(f)
        for _, kv := range subKeyValuePairs {
            err := enc.Encode(&amp;kv)
            if err != nil {
                log.Printf(&quot;Error: %v&quot;, err)
            }
        }

        f.Close()
    }
}

func ihash(s string) int {
    h := fnv.New32a()
    h.Write([]byte(s))
    return int(h.Sum32() &amp; 0x7fffffff)
}
</code></pre>

<h3 id="doreduce">doReduce</h3>

<p>doReduce 函数运行一个 reduce task，它的运行流程：
1. 读取 m 个缓存文件（m 为 map task 的个数）
1. 将相同 key 对应的 value 合并为一个列表
1. 处理每个 key：将其对应的 value 列表传入 reduce 函数 (reduceF)，得到最终的 value
1. 将结果写入到磁盘</p>

<p>Tips:
1. 按行读取文件可以用 <a href="https://golang.org/pkg/bufio/#Scanner">bufio#Scanner</a>
1. JSON 解序列化可以用 <a href="https://golang.org/pkg/encoding/json/#Unmarshaler">json#Unmarshaler</a></p>

<pre><code class="language-go">func doReduce(
    jobName string, // the name of the whole MapReduce job
    reduceTask int, // which reduce task this is
    outFile string, // write the output here
    nMap int, // the number of map tasks that were run (&quot;M&quot; in the paper)
    reduceF func(key string, values []string) string,
) {
    keyValuesMap := make(map[string][]string)

    // Read intermediate files
    for i := 0; i &lt; nMap; i++ {
        filename := reduceName(jobName, i, reduceTask)
        file, err := os.Open(filename)
        if err != nil {
            log.Printf(&quot;Error: %v&quot;, err)
        }

        var tempKeyValuePairs []KeyValue
        var keyValue KeyValue
        fileScanner := bufio.NewScanner(file)
        for fileScanner.Scan() {
            json.Unmarshal([]byte(fileScanner.Text()), &amp;keyValue)
            tempKeyValuePairs = append(tempKeyValuePairs, keyValue)
        }
        debug(&quot;KeyValues: %v&quot;, tempKeyValuePairs)

        for _, keyValue := range tempKeyValuePairs {
            key := keyValue.Key
            if values, ok := keyValuesMap[key]; ok {
                keyValuesMap[key] = append(values, keyValue.Value)
            } else {
                keyValuesMap[key] = []string{keyValue.Value}
            }
        }
    }

    file, err := os.Create(outFile)
    if err != nil {
        log.Printf(&quot;Error: %v&quot;, err)
    }
    enc := json.NewEncoder(file)
    for k, v := range keyValuesMap {
        enc.Encode(KeyValue{k, reduceF(k, v)})
    }
    file.Close()
}
</code></pre>

<h2 id="part-ii-single-worker-word-count">Part II: Single-worker word count</h2>

<h3 id="mapf">mapF</h3>

<p>每读入一个输入文件，map 函数就会被执行一次，第一个参数是文件名，第二个参数是文件内容。由于我们这里的目标是做 word count，所以 key 是 word，value 是 word 在该文件中出现的次数</p>

<p>Tips:
1. 单词分隔可以用 <a href="https://golang.org/pkg/strings/#FieldsFunc">strings#FieldsFunc</a></p>

<pre><code class="language-go">func mapF(filename string, contents string) []mapreduce.KeyValue {
    // Your code here (Part II).
    notWord := func(c rune) bool {
        return !unicode.IsLetter(c) &amp;&amp; !unicode.IsNumber(c)
    }
    words := strings.FieldsFunc(contents, notWord)
    wordCountMap := make(map[string]int)
    for _, word := range words {
        if _, ok := wordCountMap[word]; ok {
            wordCountMap[word]++
        } else {
            wordCountMap[word] = 1
        }
    }
    var wordCount []mapreduce.KeyValue
    for k, v := range wordCountMap {
        wordCount = append(wordCount, mapreduce.KeyValue{Key: k, Value: strconv.Itoa(v)})
    }
    return wordCount
}
</code></pre>

<h3 id="reducef">reduceF</h3>

<p>对于每一个 key，reduce 函数会被执行一次，第一个参数是 key，第二个参数是其对应的所有值组成的列表</p>

<pre><code class="language-go">func reduceF(key string, values []string) string {
    // Your code here (Part II).
    sum := 0
    for _, v := range values {
        v, err := strconv.Atoi(v)
        if err != nil {
            fmt.Print(&quot;Error: %v, value: %v&quot;, err, v)
        } else {
            sum += v
        }
    }
    return strconv.Itoa(sum)
}
</code></pre>

<h2 id="part-iii-distributing-mapreduce-tasks">Part III: Distributing MapReduce tasks</h2>

<p>在这里我们将会完成 schedule 函数。schedule 函数负责调度工作，它在程序的整个生命周期中会运行两次：map 阶段一次，reduce 阶段一次。</p>

<p>这里我们在 goroutine 中使用指针访问外部数据是非常错误的写法，一旦 doTaskArgs 的值被外部程序修改，就会导致不可预料的结果。而这里我们的程序正常运行只是由于每次循环都会重新声明 doTaskArgs。</p>

<p>正确的做法是将 goroutine 所需的外部变量作为参数传入 goroutine。</p>

<p>同时，将任务分配完毕后直接跳出分配循环的做法也是不正确的，在 Part IV 中我们将会看到更正确、更优雅的写法。</p>

<pre><code class="language-go">func schedule(jobName string, mapFiles []string, nReduce int, phase jobPhase, registerChan chan string) {
    var ntasks int
    var n_other int // number of inputs (for reduce) or outputs (for map)
    switch phase {
    case mapPhase:
        ntasks = len(mapFiles)
        n_other = nReduce
    case reducePhase:
        ntasks = nReduce
        n_other = len(mapFiles)
    }

    fmt.Printf(&quot;Schedule: %v %v tasks (%d I/Os)\n&quot;, ntasks, phase, n_other)

    finishedTasks := 0
    for i := 0; i &lt; ntasks; i++ {
        workerAddress := &lt;-registerChan
        fmt.Printf(&quot;Assigning #%d task to %s\n&quot;, i, workerAddress)
        inputFile := mapFiles[i]
        doTaskArgs := DoTaskArgs{
            JobName:       jobName,
            File:          inputFile,
            Phase:         phase,
            TaskNumber:    i,
            NumOtherPhase: n_other,
        }
        go func() {
            success := call(workerAddress, &quot;Worker.DoTask&quot;, &amp;doTaskArgs, nil)
            if success {
                fmt.Printf(&quot;Task success\n&quot;)
                registerChan &lt;- workerAddress
                finishedTasks++
            } else {
                fmt.Printf(&quot;Task failed\n&quot;)
            }
        }()
    }

    unfinishedTasks := ntasks - finishedTasks
    for i := 0; i &lt; unfinishedTasks; i++ {
        &lt;-registerChan
    }

    fmt.Printf(&quot;Schedule: %v done\n&quot;, phase)
}
</code></pre>

<h2 id="part-iv-handling-worker-failures">Part IV: Handling worker failures</h2>

<p>之前完成的 schedule 函数将任务分配完之后就开始等待所有任务完成，无法处理 worker failures。</p>

<p>在这里我们对它进行改进，主要：
1. 将 channel receive 改为 unblock
1. 失败的 task 重新入队</p>

<pre><code class="language-go">func schedule(jobName string, mapFiles []string, nReduce int, phase jobPhase, registerChan chan string) {
    var ntasks int
    var n_other int // number of inputs (for reduce) or outputs (for map)
    switch phase {
    case mapPhase:
        ntasks = len(mapFiles)
        n_other = nReduce
    case reducePhase:
        ntasks = nReduce
        n_other = len(mapFiles)
    }

    fmt.Printf(&quot;Schedule: %v %v tasks (%d I/Os)\n&quot;, ntasks, phase, n_other)

    finishedTasks := 0
    tasksChan := make(chan int, ntasks)
    var taskIndex int
    for taskIndex := 0; taskIndex &lt; ntasks; taskIndex++ {
        tasksChan &lt;- taskIndex
    }
    var inputFile string
    for finishedTasks &lt; ntasks {
        select {
        case taskIndex = &lt;-tasksChan:
            workerAddress := &lt;-registerChan
            fmt.Printf(&quot;Assigning #%d task to %s\n&quot;, taskIndex, workerAddress)
            inputFile = mapFiles[taskIndex]
            doTaskArgs := DoTaskArgs{
                JobName:       jobName,
                File:          inputFile,
                Phase:         phase,
                TaskNumber:    taskIndex,
                NumOtherPhase: n_other,
            }
            go func() {
                success := call(workerAddress, &quot;Worker.DoTask&quot;, &amp;doTaskArgs, nil)
                if success {
                    fmt.Printf(&quot;Task #%d success\n&quot;, doTaskArgs.TaskNumber)
                    finishedTasks++
                    registerChan &lt;- workerAddress
                } else {
                    fmt.Printf(&quot;Task #%d failed\n&quot;, doTaskArgs.TaskNumber)
                    tasksChan &lt;- doTaskArgs.TaskNumber
                }
            }()
        default:
        }
    }

    fmt.Printf(&quot;Schedule: %v done\n&quot;, phase)
}
</code></pre>

<h2 id="part-v-inverted-index-generation">Part V: Inverted index generation</h2>

<p>在这里我们将会实现 inverted index, 与之前的 word count 正好相反，现在 word 作为 key，而 document 作为 value</p>

<h3 id="domap-1">doMap</h3>

<pre><code class="language-go">func mapF(document string, value string) (res []mapreduce.KeyValue) {
    // Your code here (Part V).
    notWord := func(c rune) bool {
        return !unicode.IsLetter(c) &amp;&amp; !unicode.IsNumber(c)
    }
    words := strings.FieldsFunc(value, notWord)
    wordDoc := make(map[string]string)
    for _, word := range words {
        if _, ok := wordDoc[word]; !ok {
            wordDoc[word] = document
        }
    }
    for k, v := range wordDoc {
        res = append(res, mapreduce.KeyValue{Key: k, Value: v})
    }
    return res
}
</code></pre>

<h3 id="doreduce-1">doReduce</h3>

<p>由于 values 不存在冲突的情况，所以直接 join 起来就可以了。</p>

<pre><code class="language-go">func reduceF(key string, values []string) string {
    // Your code here (Part V).
    var documents []string
    for _, v := range values {
        documents = append(documents, v)
    }
    res := strings.Join(documents, &quot;,&quot;)
    res = strconv.Itoa(len(documents)) + &quot; &quot; + res
    return res
}
</code></pre>
        </div>

        

        <div class="site-footer">
  
  <div class="site-footer-item">
    <a href="https://github.com/XiaochenCui" target="_blank">Github</a>
  </div>
  
  
</div>

      </div>
    </div>
  </article>

  <script src="/js/highlight.pack.js"></script>
<script src="https://unpkg.com/quicklink@0.1.1/dist/quicklink.umd.js"></script>

<script>
  hljs.initHighlightingOnLoad();
  
  var posts = document.getElementById('posts-list');
  posts && quicklink({
    el: posts,
    priority: true,
  });
</script>

  

</body>

</html>