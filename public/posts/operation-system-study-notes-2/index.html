<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="Hugo 0.57.2" />

  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="author" content="" />
  <meta property="og:url" content="https://cuixiaochen.com/posts/operation-system-study-notes-2/" />
  <link rel="canonical" href="https://cuixiaochen.com/posts/operation-system-study-notes-2/" /><script type="application/ld+json">
  {
      "@context" : "http://schema.org",
      "@type" : "BlogPosting",
      "mainEntityOfPage": {
           "@type": "WebPage",
           "@id": "https:\/\/cuixiaochen.com\/"
      },
      "articleSection" : "posts",
      "name" : "操作系统学习笔记：第一章习题及解答",
      "headline" : "操作系统学习笔记：第一章习题及解答",
      "description" : "\x3ch1 id=\x22习题\x22\x3e习题\x3c\/h1\x3e\n\n\x3col\x3e\n\x3cli\x3e什么是 multiprogramming？\x3c\/li\x3e\n\x3c\/ol\x3e\n\n\x3cp\x3e在第二代操作系统（如 7094 机）上，若当前作业因等待磁带或其他 I\/O 操作而暂停时，CPU 就只能简单地原地踏步直至该 I\/O 完成。在很多情况下，I\/O 操作等待的时间通常占到 80% ~ 90%, 所以要通过 multiprogramming 的方式来减少 CPU 资源的浪费。\x3c\/p\x3e\n\n\x3cp\x3e具体方案就是将内存分成多个部分，每个部分存放不同的作业（如下图所示），当一个作业等待 I\/O 操作完成时，另一个作业可以使用 CPU。如果内存中可以同时存放足够多的作业，则 CPU 利用率可以接近 100%。（注意：在内存中同时驻留多个作业需要特殊的硬件来对其进行保护，以避免作业对信息被窃取或受到攻击。）\n {% asset_img multi-programmed-system.jpg %}\x3c\/p\x3e",
      "inLanguage" : "en-US",
      "author" : "",
      "creator" : "",
      "publisher": "",
      "accountablePerson" : "",
      "copyrightHolder" : "",
      "copyrightYear" : "2018",
      "datePublished": "2018-04-17 22:00:19 \x2b0000 UTC",
      "dateModified" : "2018-04-17 22:00:19 \x2b0000 UTC",
      "url" : "https:\/\/cuixiaochen.com\/posts\/operation-system-study-notes-2\/",
      "keywords" : [ "operating system", ]
  }
</script>
<title>操作系统学习笔记：第一章习题及解答 - XiaochenCui&#39;s Blog</title>
  <meta property="og:title" content="操作系统学习笔记：第一章习题及解答 - XiaochenCui&#39;s Blog" />
  <meta property="og:type" content="article" />
  <meta name="description" content="习题


什么是 multiprogramming？


在第二代操作系统（如 7094 机）上，若当前作业因等待磁带或其他 I/O 操作而暂停时，CPU 就只能简单地原地踏步直至该 I/O 完成。在很多情况下，I/O 操作等待的时间通常占到 80% ~ 90%, 所以要通过 multiprogramming 的方式来减少 CPU 资源的浪费。

具体方案就是将内存分成多个部分，每个部分存放不同的作业（如下图所示），当一个作业等待 I/O 操作完成时，另一个作业可以使用 CPU。如果内存中可以同时存放足够多的作业，则 CPU 利用率可以接近 100%。（注意：在内存中同时驻留多个作业需要特殊的硬件来对其进行保护，以避免作业对信息被窃取或受到攻击。）
 {% asset_img multi-programmed-system.jpg %}" />

  <link rel="stylesheet" href="https://unpkg.com/flexboxgrid@6.3.1/dist/flexboxgrid.min.css" />
  <link rel="stylesheet"
    href="https://cdnjs.cloudflare.com/ajax/libs/github-markdown-css/2.10.0/github-markdown.min.css" />
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.13.1/styles/tomorrow.min.css" />
  <link rel="stylesheet" href="/css/index.css">
  <link href="/index.xml" rel="alternate" type="application/rss+xml" title="XiaochenCui&#39;s Blog">
  
  <link href="https://fonts.googleapis.com/css?family=Arvo|Permanent+Marker" rel="stylesheet">
  
  <script>
    

    (function (undefined) { }).call('object' === typeof window && window || 'object' === typeof self && self || 'object' === typeof global && global || {});
  </script>

  
</head>

<body>
  <article class="post " id="article">
    <div class="row">
      <div class="col-xs-12 col-sm-10 col-md-8 col-sm-offset-1 col-md-offset-2 col-lg-6 col-lg-offset-3">
        <div class="site-header">
          
<header>
  <div class="signatures site-title">
    <a href="/"></a>
  </div>
</header>
<div class="row end-xs">
  
  
</div>
<div class="header-line"></div>

        </div>
        <header class="post-header">
          <h1 class="post-title">操作系统学习笔记：第一章习题及解答</h1>
          
        </header>

        <div class="post-content markdown-body">
          <h1 id="习题">习题</h1>

<ol>
<li>什么是 multiprogramming？</li>
</ol>

<p>在第二代操作系统（如 7094 机）上，若当前作业因等待磁带或其他 I/O 操作而暂停时，CPU 就只能简单地原地踏步直至该 I/O 完成。在很多情况下，I/O 操作等待的时间通常占到 80% ~ 90%, 所以要通过 multiprogramming 的方式来减少 CPU 资源的浪费。</p>

<p>具体方案就是将内存分成多个部分，每个部分存放不同的作业（如下图所示），当一个作业等待 I/O 操作完成时，另一个作业可以使用 CPU。如果内存中可以同时存放足够多的作业，则 CPU 利用率可以接近 100%。（注意：在内存中同时驻留多个作业需要特殊的硬件来对其进行保护，以避免作业对信息被窃取或受到攻击。）
 {% asset_img multi-programmed-system.jpg %}</p>

<ol>
<li>什么是 SPOOLing ？你是否认为将来的个人计算机会把 SPOOLing 作为标准功能？</li>
</ol>

<p>SPOOLing(Simultaneous Peripheral operation on line), 指任何时刻当一个作业运行结束时，操作系统就能将一个新作业从磁盘读出，装进空出来的内存区域运行。（该技术同时也用于输出）</p>

<p>具体答案还有待后续章节的学习，但我认为 SPOOLing 不会在将来被当作个人计算机的标准功能。因为其需要等一个作业运行结束，意味着用户在操作计算机时会经常遇到计算机卡住的情况，从而带给用户不好的体验（相比于后来出现的分时系统）。</p>

<ol>
<li>在早期计算机中，每个字节的读写直接由 CPU 处理（即没有 <a href="https://www.techopedia.com/definition/2767/direct-memory-access-dma">DMA</a> ）。对于多道程序而言这种组织方式有什么含义？</li>
</ol>

<p>使用多道程序的主要目的是使计算机在等待 I/O 操作时可以完成别的工作。如果没有 DMA ，I/O 操作将会完全占用 CPU 。因此，这种方式不利于对于 CPU 的充分利用。</p>

<ol>
<li>系列计算机的思想在 20 世纪 60 年代由 IBM 引入进 System/360 大型机。现在这种思想已经消亡了还是继续活跃着？</li>
</ol>

<p>依然存在。例如 Intel 生产的 Pentium I，II，III 和 4 仅仅在价格、速度等属性上有所不同，但它们的体系结构都是兼容的。</p>

<ol>
<li>缓慢采用 GUI 的一个原因是支持它的硬件的成本（高昂）。为了支持 25 行 80 列字符的单色文本屏幕应该需要多少视颊 RAM? 对于 1024x768 像素 24 位色彩位图需要多少视频 RAM? 在 1980 年 ($5/KB) 这些 RAM 的成本是多少？现在它的成本是多少？</li>
</ol>

<p>25*80=2000bytes≈2kb, 1024*768*3=2359296bytes≈2359kb。在 1980 年，它们将会分布耗费 $10 和 $11520。现在的 RAM 的成本小于 $1/MB。</p>

<ol>
<li>在建立一个操作系统时有几个设计目的，例如资源利用、及时性、健壮性等。请列举两个可能互相矛盾的设计目的。</li>
</ol>

<p>资源利用与缓存。资源利用要求尽量满足当前所运行程序的资源要求，而缓存则要求缓存频繁访问的数据。所以当前进程可能会占用过多的资源导致缓存空间不足。</p>

<ol>
<li>下面的哪一条指令只能在内核态中使用？
a) 禁止所有的中断。
b) 读日期 - 时间时钟。
c) 设置日期 - 时间时钟。
d) 改变存储器映像。</li>
</ol>

<p>a,c,d</p>

<ol>
<li>考虑一个有两个 CPU 的系统，并且每一个 CPU 有两个线程（超线程）。假设有三个程序 P0，P1，P2，分別以运行时间 5ms，10ms，20ms 开始。运行这些程序需要多少时间？假设这三个程序都是 100% 限于 CPU，在运行时无阻塞，并且一旦设定就不改变 CPU。</li>
</ol>

<p>运行这些程序所需的时间取决于这些程序以怎样的组合被分配到 CPU 上，一共有以下 4 种情况：
 1. (P0,P1) and P2 =&gt; (5ms + 10ms) and 20ms =&gt; 20ms
 1. (P0,P2) and P1 =&gt; (5ms + 20ms) and 10ms =&gt; 25ms
 1. (P1,P2) and P0 =&gt; (10ms + 20ms) and 50ms =&gt; 30ms
 1. (P0,P1,P2) =&gt; (5ms + 10ms + 20ms) =&gt; 35m</p>

<ol>
<li>一台计算机有一个四级流水线，每一级都花费相同的时间执行其工作，即 1ns。这台机器每秒可执行多少条指令？</li>
</ol>

<p>1s / (1ns/ 条） = $10 ^ 9$ 条</p>

<ol>
<li>假设一个计算机系统有高速缓存、内存 (RAM) 以及磁盘，操作系统用虚拟内存。读取缓存中的一个词需要 2ns，RAM 需要 10ns，磁盘需要 10ms。如果缓存的命中率是 95%，内存的是（缓存失效时）99%，读取一个词的平均时间是多少？</li>
</ol>

<p>$2ns\times95\%+10ns\times(1-95\%)\times99\%+10ms\times(1-95\%)(1-99\%) = 5002.395ns$</p>

<ol>
<li>一位校对人员注意到在一部将要出版的操作系统教科书手稿中有一个多次出现的拼写错误。这本书大致有 700 页。每页 50 行，一行 80 个字符。若把文稿用电子扫描，那么，主副本进入图 1-9 中的每个存储系统的层次要花费多少时间？对于内存储方式，考虑所给定的存取时间是每次一个字符，对于磁盘设备，假定存取时间是每次一个 1024 字符的盘块，而对于磁带，假设给定开始时间后的存取时间和磁盘存取时间相同。</li>
</ol>

<p>{% asset_img caching-stuff.jpg %}</p>

<p>答：原稿包含 80*50*700 = 2800000 字符。如果这些字符放在寄存器中，cpu 访问它们需要 2.8ms（在这里我们假设这些字符可以一次性放入寄存器），在 Cache 中需要 5.6ms，在内存中需要 28ms。整本书大约有 2700 个 1024 字节的数据块，因此从磁盘读取它们大约需要 27 秒，从磁带读取大约需要 2 分钟 7 秒。（根据书中的数据计算）</p>

<ol>
<li>在用户程序进行一个系统调用，以读写磁盘文件时，该程序提供指示说明了所需要的文件，一个指向数据缓冲区的指针以及计数。然后，控制权转给操作系统，它调用相关的驱动程序。假设驱动程序启动磁盘并且直到中断发生才终止。在从磁盘读的情况下，很明显，调用者会被阻塞（因为文件中没有数据）。在向磁盘写时会发生什么情况？需要把调用者阻塞一直等到磁盘传送完成为止吗？</li>
</ol>

<p>这道题暂时无法解答</p>

<ol>
<li>什么是陷阱指令？在操作系统中解释它的用途。</li>
</ol>

<p>TRAP 指令将处理器的执行模式从用户态切换到内核态，它使用户可以调用操作系统内核中的函数。</p>

<ol>
<li>陷阱和中断的主要差别是什么？</li>
</ol>

<p>陷阱是由程序造成的，而且与程序同步；中断由外部事件和时钟造成。</p>

<ol>
<li>在分时系统中为什么需要进程表？在只有一个进程存在的个人计算机系统中，该进程控制整个机器直到进程结束，这种机器也需要进程表吗？</li>
</ol>

<p>进程表的作用是在进程暂时被挂起时保存进程打开的所有文件的当前读取位置。单进程操作系统中不需要进程表，因为进程不会被挂起。</p>

<ol>
<li>说明有没有理由要在一个非空的目录中安装一个文件系统？如果要这样做，如何做？</li>
</ol>

<p>这道题暂时无法解答</p>

<ol>
<li>在一个操作系统中系统调用的目的是什么？</li>
</ol>

<p>进入内核，调用操作系统服务</p>

<ol>
<li>对于下列系统调用 ，给出引起失败的条件：fork、exec 以及 unlink。</li>
</ol>

<p>fork: fork 失败的主要原因有两个：(a) 系统中已经有了太多的进程（进程表中没有空闲的槽）；(b) 该实际用户 ID 的进程总数超过了系统限制（在 POSIX.1 中，CHILD_MAX 代表了每个实际用户 ID 的最大进程数，可在运行时通过调用 <code>long sysconf(int _SC_CHLID_MAX)</code> 取得）
 exec: 给定的 pathname/filename 不合法，这里的不合法有两种情况：(a) 不存在，(b) 存在但不是一个可用的 shell 脚本
 unlink: 待我详细阅读相关资料后再给出解答</p>

<ol>
<li>在 <code>count = write(fd, buffer, nbytes);</code> 调用中，能在 count 中而不是 nbytes 中返回值吗？如果能，为什么？</li>
</ol>

<p>能，因为当 write 调用失败时返回 -1，否则返回实际写入当字节数</p>

<ol>
<li><p>有一个文件，其文件描述符是 fd，内含下列字节序列：3，1，4，1，5，9，2，6，5，3，5。
有如下系统调用：</p>

<pre><code class="language-c">lseek(fd, 3, SEEK_SET);
read(fd, &amp;buffer, 4);
</code></pre>

<p>其中 lseek 调用寻找文件中的第 3 个字节。在读操作完成之后，buffer 中的内容是什么？</p></li>
</ol>

<p>1, 5, 9, 2</p>

<ol>
<li>假设一个 10MB 的文件在磁盘连续扇区的同一个轨道上（轨道号：50）。磁盘的磁头臂此时位于第 100 号轨道。要想从磁盘上找回这个文件，需要多长时间？ 假设磁头臂从一个柱面移动到下一个柱面需要 1ms，当文件的开始部分存储在的扇区旋转到磁头下需要 5ms，并且读的速率是 100MB/s。</li>
</ol>

<p>155ms（在 SSD 普及的今天，这道题基本没有意义）</p>

<ol>
<li>块特殊文件和字符特殊文件的基本差别是什么？</li>
</ol>

<p>块特殊文件 (block special file) 提供对设备带缓冲的访问
 字符特殊文件 (character special file) 提供对设备不带缓冲的访问</p>

<ol>
<li>如下图所示，库调用被称为 read，而系统调用自身也被称为 read，这两者都有相问的名字是正常的吗？ 如果不是，哪一个更重要？</li>
</ol>

<p>是正常的，因为系统调用实际上并没有名称。当库函数 read 陷入内核时，它将系统调用的编号放在操作系统所期望的地方（寄存器或堆栈）中，然后由内核根据编号执行相应的系统调用，整个过程中不会用到任何名称。而对于库调用来说名称是很重要的，因为我们写的程序中需要使用这个名称。
 {% asset_img system.jpg.png %}</p>

<ol>
<li>在分布式系统中，C-S 模式很普遍。这种模式能用在单个计算机的系统中吗？</li>
</ol>

<p>可以</p>

<p>未完待续</p>

<h1 id="参考">参考</h1>

<ul>
<li><a href="https://www.techopedia.com/definition/2767/direct-memory-access-dma">What is Direct Memory Access (DMA)? - Definition from Techopedia</a></li>
</ul>
        </div>

        

        <div class="site-footer">
  
  
</div>

      </div>
    </div>
  </article>

  <script src="/js/highlight.pack.js"></script>
<script src="https://unpkg.com/quicklink@0.1.1/dist/quicklink.umd.js"></script>

<script>
  hljs.initHighlightingOnLoad();
  
  var posts = document.getElementById('posts-list');
  posts && quicklink({
    el: posts,
    priority: true,
  });
</script>

  

</body>

</html>