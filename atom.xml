<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>XiaochenCui&#39;s Blog</title>
  
  <subtitle>相隔天堑 却不觉遥远</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://cuixiaochen.com/"/>
  <updated>2018-08-12T10:02:09.519Z</updated>
  <id>https://cuixiaochen.com/</id>
  
  <author>
    <name>Xiaochen Cui</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Cryptography Week 5 - Programming Assignment</title>
    <link href="https://cuixiaochen.com/2018/08/12/cryptography-week-5-program-assigment/"/>
    <id>https://cuixiaochen.com/2018/08/12/cryptography-week-5-program-assigment/</id>
    <published>2018-08-12T09:44:51.000Z</published>
    <updated>2018-08-12T10:02:09.519Z</updated>
    
    <content type="html"><![CDATA[<p>这次我们的任务是求离散对数 (discrete log)，采用的方法是 meet in the middle</p><p>Meet in the middle 最令我们印象深刻的就是其在破解 3DES 时的表现，将暴力破解的时间复杂度减少到了 $2 ^ {56}$<br><a id="more"></a></p><img src="/2018/08/12/cryptography-week-5-program-assigment/pa.png"><p>需要注意的是，modular division 和一般除法不同，需要先求 modular inversion，然后再做 modular multiplication 得到 division</p><p>以下是代码题解：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> gmpy2</span><br><span class="line"><span class="keyword">from</span> gmpy2 <span class="keyword">import</span> (</span><br><span class="line">    mpz,</span><br><span class="line">    powmod,</span><br><span class="line">    mul,</span><br><span class="line">    invert,</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">B = <span class="number">2</span> ** <span class="number">20</span></span><br><span class="line">p = mpz(<span class="string">'13407807929942597099574024998205846127479365820592393377723561443721764030073546976801874298166903427690031858186486050853753882811946569946433649006084171'</span>)</span><br><span class="line">g = mpz(<span class="string">'11717829880366207009516117596335367088558084999998952205599979459063929499736583746670572176471460312928594829675428279466566527115212748467589894601965568'</span>)</span><br><span class="line">h = mpz(<span class="string">'3239475104050450443565264378728065788649097520952449527834792452971981976143292558073856937958553180532878928001494706097394108577585732452307673444020333'</span>)</span><br><span class="line"></span><br><span class="line">hash_table = dict()</span><br><span class="line"><span class="keyword">for</span> x_1 <span class="keyword">in</span> range(B + <span class="number">1</span>):</span><br><span class="line">    key = mul(h, invert(powmod(g, x_1, p), p)) % p</span><br><span class="line">    value = x_1</span><br><span class="line">    hash_table[key] = value</span><br><span class="line"></span><br><span class="line">base = powmod(g, B, p)</span><br><span class="line"><span class="keyword">for</span> x_0 <span class="keyword">in</span> range(B + <span class="number">1</span>):</span><br><span class="line">    target = powmod(base, x_0, p)</span><br><span class="line">    <span class="keyword">if</span> target <span class="keyword">in</span> hash_table:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">x = x_0 * B + hash_table[target]</span><br><span class="line">print(<span class="string">'x: &#123;&#125;'</span>.format(x))</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这次我们的任务是求离散对数 (discrete log)，采用的方法是 meet in the middle&lt;/p&gt;
&lt;p&gt;Meet in the middle 最令我们印象深刻的就是其在破解 3DES 时的表现，将暴力破解的时间复杂度减少到了 $2 ^ {56}$&lt;br&gt;
    
    </summary>
    
      <category term="Exercises of Cryptography" scheme="https://cuixiaochen.com/categories/Exercises-of-Cryptography/"/>
    
    
      <category term="cryptography" scheme="https://cuixiaochen.com/tags/cryptography/"/>
    
  </entry>
  
  <entry>
    <title>Cryptography Week 5 - Problem Set</title>
    <link href="https://cuixiaochen.com/2018/08/12/cryptography-week-5-problem-set/"/>
    <id>https://cuixiaochen.com/2018/08/12/cryptography-week-5-problem-set/</id>
    <published>2018-08-12T05:42:10.000Z</published>
    <updated>2018-08-12T06:49:52.356Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h1><p>本章的主要内容是密钥交换 (key exchange) 和数论 (number theory)</p><p>密钥交换部分先后讲了 TTP (Trusted third parties), Merkle Puzzle 和 Diffie-Hellman protocol</p><p>数论部分的核心概念是 Modular arithmetic，并由此展开 Fermat’s theorem, Euler’s theorem 等定理，同时辅以 order, generator 等概念来做 Modular arithmetic<br><a id="more"></a></p><h1 id="Exercise-explanation"><a href="#Exercise-explanation" class="headerlink" title="Exercise explanation"></a>Exercise explanation</h1><img src="/2018/08/12/cryptography-week-5-problem-set/1.png" width="700"><p>此题比较简单，要注意两点：</p><ol><li>密钥不能以明文形式发送，所以发送的应该是 ticket 而不是 key</li><li>三者所持有的密钥应该相同</li></ol><img src="/2018/08/12/cryptography-week-5-problem-set/2.png" width="700"><p>1 和 4 两个选项需要求解离散对数，是正确选项</p><img src="/2018/08/12/cryptography-week-5-problem-set/3.png" width="700"><img src="/2018/08/12/cryptography-week-5-problem-set/4.png" width="700"><p>由于 pk 是公开的，所以对 ciphertext 加 MAC 不能防止 MIMA</p><img src="/2018/08/12/cryptography-week-5-problem-set/5.png" width="700"><p>本题应使用 Extended Euclidean Algorithm</p><img src="/2018/08/12/cryptography-week-5-problem-set/6.png" width="700"><p>求解 Modular inversion 同样可以用 Extended Euclidean Algorithm</p><img src="/2018/08/12/cryptography-week-5-problem-set/7.png" width="700"><p>使用 Euler’s theorem</p><img src="/2018/08/12/cryptography-week-5-problem-set/8.png" width="700"><p>使用 Fermat’s theorem</p><img src="/2018/08/12/cryptography-week-5-problem-set/9.png" width="700"><p>使用 Fermat’s theorem</p><img src="/2018/08/12/cryptography-week-5-problem-set/10.png" width="700"><img src="/2018/08/12/cryptography-week-5-problem-set/11.png" width="700"><img src="/2018/08/12/cryptography-week-5-problem-set/12.png" width="700"><img src="/2018/08/12/cryptography-week-5-problem-set/13.png" width="700"><img src="/2018/08/12/cryptography-week-5-problem-set/14.png" width="700"><img src="/2018/08/12/cryptography-week-5-problem-set/15.png" width="700">]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Overview&quot;&gt;&lt;a href=&quot;#Overview&quot; class=&quot;headerlink&quot; title=&quot;Overview&quot;&gt;&lt;/a&gt;Overview&lt;/h1&gt;&lt;p&gt;本章的主要内容是密钥交换 (key exchange) 和数论 (number theory)&lt;/p&gt;
&lt;p&gt;密钥交换部分先后讲了 TTP (Trusted third parties), Merkle Puzzle 和 Diffie-Hellman protocol&lt;/p&gt;
&lt;p&gt;数论部分的核心概念是 Modular arithmetic，并由此展开 Fermat’s theorem, Euler’s theorem 等定理，同时辅以 order, generator 等概念来做 Modular arithmetic&lt;br&gt;
    
    </summary>
    
      <category term="Exercises of Cryptography" scheme="https://cuixiaochen.com/categories/Exercises-of-Cryptography/"/>
    
    
      <category term="cryptography" scheme="https://cuixiaochen.com/tags/cryptography/"/>
    
  </entry>
  
  <entry>
    <title>Proof of Fermat&#39;s Little Theorem</title>
    <link href="https://cuixiaochen.com/2018/07/22/fermat-little-theorem/"/>
    <id>https://cuixiaochen.com/2018/07/22/fermat-little-theorem/</id>
    <published>2018-07-22T14:20:44.000Z</published>
    <updated>2018-08-12T06:49:01.611Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h1><p>Fermat’s little theorem states that if $p$ is a prime number, then for any integer $a$, the number $a^p - a$ is an integer multiple of $p$. In the notation of modular arithmetic, this is expressed as</p>$$    \begin{align*}        a^p \equiv a\: (mod p)    \end{align*}$$<p>To be continued</p><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ul><li><a href="https://en.wikipedia.org/wiki/Fermat%27s_little_theorem" target="_blank" rel="noopener">Fermat’s little theorem</a></li><li><a href="https://primes.utm.edu/notes/proofs/FermatsLittleTheorem.html" target="_blank" rel="noopener">Proof of Fermat’s Little Theorem</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Overview&quot;&gt;&lt;a href=&quot;#Overview&quot; class=&quot;headerlink&quot; title=&quot;Overview&quot;&gt;&lt;/a&gt;Overview&lt;/h1&gt;&lt;p&gt;Fermat’s little theorem states that if $p$ is 
      
    
    </summary>
    
      <category term="Fun with number theory" scheme="https://cuixiaochen.com/categories/Fun-with-number-theory/"/>
    
    
      <category term="number theory" scheme="https://cuixiaochen.com/tags/number-theory/"/>
    
  </entry>
  
  <entry>
    <title>新专栏：数论</title>
    <link href="https://cuixiaochen.com/2018/07/22/number-theorem/"/>
    <id>https://cuixiaochen.com/2018/07/22/number-theorem/</id>
    <published>2018-07-22T13:36:00.000Z</published>
    <updated>2018-08-12T06:49:13.807Z</updated>
    
    <content type="html"><![CDATA[<p>一个新的专栏： <a href="categories/Fun-with-number-theory/">Fun with number theory</a>。这个专栏将从费马小定律开始，讲一些简单的数论知识，并介绍这些数论知识在公钥密码学、素数检查、复数计算等方面的应用</p><p>由于本人也是初学者，错误及遗漏之处还请大家多多指正</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;一个新的专栏： &lt;a href=&quot;categories/Fun-with-number-theory/&quot;&gt;Fun with number theory&lt;/a&gt;。这个专栏将从费马小定律开始，讲一些简单的数论知识，并介绍这些数论知识在公钥密码学、素数检查、复数计算等方面的应用&lt;
      
    
    </summary>
    
      <category term="Fun with number theory" scheme="https://cuixiaochen.com/categories/Fun-with-number-theory/"/>
    
    
      <category term="number theory" scheme="https://cuixiaochen.com/tags/number-theory/"/>
    
  </entry>
  
  <entry>
    <title>Vim Lisp Plugin 推荐</title>
    <link href="https://cuixiaochen.com/2018/07/19/lisp-vim/"/>
    <id>https://cuixiaochen.com/2018/07/19/lisp-vim/</id>
    <published>2018-07-19T13:57:14.000Z</published>
    <updated>2018-07-20T11:34:41.030Z</updated>
    
    <content type="html"><![CDATA[<p>使用 lisp 编程的时候括号是一个很让人头疼的问题，vim 自带的 <a href="https://github.com/vim/vim/blob/master/runtime/plugin/matchparen.vim" target="_blank" rel="noopener">matchparen</a> 可以起到一定的帮助，但是还是有两个小问题：</p><ul><li>需要将光标移到括号上才能知道它对应的是哪个括号</li><li>频繁报错，很影响编码效率</li></ul><p>在这里向大家推荐两个插件帮大家更舒服地编写 lisp<br><a id="more"></a></p><h1 id="auto-pairs"><a href="#auto-pairs" class="headerlink" title="auto-pairs"></a>auto-pairs</h1><p><a href="https://github.com/jiangmiao/auto-pairs" target="_blank" rel="noopener">auto-pairs</a> 是一款非常实用的括号自动补全插件</p><h1 id="rainbow"><a href="#rainbow" class="headerlink" title="rainbow"></a>rainbow</h1><p><a href="https://github.com/luochen1990/rainbow" target="_blank" rel="noopener">rainbow</a> 可以给我们的括号着色，既美观又实用，可谓 lisp 神器</p><h2 id="效果图："><a href="#效果图：" class="headerlink" title="效果图："></a>效果图：</h2><img src="/2018/07/19/lisp-vim/rainbow.png"><h2 id="rainbow-的配置"><a href="#rainbow-的配置" class="headerlink" title="rainbow 的配置"></a>rainbow 的配置</h2><h3 id="使-rainbow-默认开启"><a href="#使-rainbow-默认开启" class="headerlink" title="使 rainbow 默认开启"></a>使 rainbow 默认开启</h3><p>与其他常用的 plugin 不同，rainbow 默认是关闭的，我们可以通过配置使其自动开启：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let g:rainbow_active = 1</span><br></pre></td></tr></table></figure><h3 id="颜色"><a href="#颜色" class="headerlink" title="颜色"></a>颜色</h3><p>rainbow 默认配置的颜色辨识度不高，我为其配置了更有辨识度的配色方案：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let g:rainbow_conf = &#123;</span><br><span class="line">\    &apos;guifgs&apos;: [&apos;royalblue3&apos;, &apos;darkorange3&apos;, &apos;seagreen3&apos;, &apos;firebrick&apos;],</span><br><span class="line">\    &apos;ctermfgs&apos;: [&apos;darkred&apos;, &apos;blue&apos;, &apos;yellow&apos;, &apos;cyan&apos;, &apos;magenta&apos;, &apos;brown&apos;],</span><br><span class="line">\&#125;</span><br></pre></td></tr></table></figure><h3 id="只为特定类型的文件启用"><a href="#只为特定类型的文件启用" class="headerlink" title="只为特定类型的文件启用"></a>只为特定类型的文件启用</h3><p>由于 rainbow 会破坏 markdown 等文件编辑界面，在这里我们通过配置使其只为特定文件开启：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Plug &apos;luochen1990/rainbow&apos;, &#123; &apos;for&apos;: &apos;scheme&apos;  &#125;</span><br></pre></td></tr></table></figure><p>我使用的插件管理器是 <a href="https://github.com/junegunn/vim-plug" target="_blank" rel="noopener">plug</a>，由于目前只在编写 scheme 的需要写比较多的括号，所以只为 scheme 源代码文件开启彩虹配色</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;使用 lisp 编程的时候括号是一个很让人头疼的问题，vim 自带的 &lt;a href=&quot;https://github.com/vim/vim/blob/master/runtime/plugin/matchparen.vim&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;matchparen&lt;/a&gt; 可以起到一定的帮助，但是还是有两个小问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;需要将光标移到括号上才能知道它对应的是哪个括号&lt;/li&gt;
&lt;li&gt;频繁报错，很影响编码效率&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在这里向大家推荐两个插件帮大家更舒服地编写 lisp&lt;br&gt;
    
    </summary>
    
    
      <category term="vim" scheme="https://cuixiaochen.com/tags/vim/"/>
    
      <category term="lisp" scheme="https://cuixiaochen.com/tags/lisp/"/>
    
  </entry>
  
  <entry>
    <title>一些关于 Key Exchange Protocol 的 paper</title>
    <link href="https://cuixiaochen.com/2018/07/15/key-exchange-paper/"/>
    <id>https://cuixiaochen.com/2018/07/15/key-exchange-paper/</id>
    <published>2018-07-15T13:48:13.000Z</published>
    <updated>2018-07-15T13:56:10.703Z</updated>
    
    <content type="html"><![CDATA[<ul><li><a href="https://www.boazbarak.org/Papers/merkle.pdf" target="_blank" rel="noopener">Mer Puzzles are Optimal, B.Barak, M.Mahmoody-Ghidary, Crypto ‘09</a><br>当我们只使用 symmetric ciphers 和 hash functions 的时候，Merkle Puzzles 是 key exchange 的最优选择。即我们无法在这样的限制下超越 quadratic gap</li><li><a href="http://www.shoup.net/papers/skey.pdf" target="_blank" rel="noopener">On Formal models of key exchange (sections 7-9) V.Shoup, 1999</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://www.boazbarak.org/Papers/merkle.pdf&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Mer Puzzles are Optimal, B.Barak, M.Mahmoody-G
      
    
    </summary>
    
    
      <category term="cryptography" scheme="https://cuixiaochen.com/tags/cryptography/"/>
    
  </entry>
  
  <entry>
    <title>Closed Form Expression For Fibonacci Numbers 的证明</title>
    <link href="https://cuixiaochen.com/2018/07/11/fib/"/>
    <id>https://cuixiaochen.com/2018/07/11/fib/</id>
    <published>2018-07-10T23:11:39.000Z</published>
    <updated>2018-07-22T13:23:00.797Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h1><p>此题出自 SICP 第一章练习题 1.13</p><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>Prove that $Fib(n)$ is the closest integer to $\phi^n/\sqrt5$, where $\phi=(1+\sqrt5)/2$. Hint: Let $\psi=(1-\sqrt5)/2$. Use induction and definition of the Fibonacci numbers (see section 1.2.2) to prove that $Fib(n)=(\phi^n-\psi^n)/\sqrt5$.<br><a id="more"></a></p><h1 id="证明"><a href="#证明" class="headerlink" title="证明"></a>证明</h1><h2 id="phi-和-psi-的性质"><a href="#phi-和-psi-的性质" class="headerlink" title="$\phi$ 和 $\psi$ 的性质"></a>$\phi$ 和 $\psi$ 的性质</h2><p>由题目所设 $\phi=(1+\sqrt5)/2$ 易得：</p>$$    \begin{align*}        \phi^2 = \phi+1 \\        1/\phi + 1 = \phi \\    \end{align*}$$<p>由 $\psi=(1-\sqrt5)/2$ 易得：</p>$$    \begin{align*}        \psi^2 = \psi + 1 \\        1/\psi + 1 = \psi\\    \end{align*}$$<h2 id="归纳证明法证明-Fib-n-phi-n-psi-n-sqrt5"><a href="#归纳证明法证明-Fib-n-phi-n-psi-n-sqrt5" class="headerlink" title="归纳证明法证明 $Fib(n)=(\phi^n-\psi^n)/\sqrt5$"></a>归纳证明法证明 $Fib(n)=(\phi^n-\psi^n)/\sqrt5$</h2><p>$\text{for } n=0:$<br>$$    \begin{align*}        (\phi^n-\psi^n)/\sqrt5 =& (\phi^0-\psi^0)/\sqrt5 \\                               =& 0 \\    \end{align*}$$</p><p>$\text{for } n=1:$<br>$$    \begin{align*}        (\phi^n-\psi^n)/\sqrt5 =& (\phi^1-\psi^1)/\sqrt5 \\                               =& 1 \\    \end{align*}$$</p><p>$\text{for } n=2:$<br>$$    \begin{align*}        (\phi^n-\psi^n)/\sqrt5 =& (\phi^2-\psi^2)/\sqrt5 \\                               =& 1 \\    \end{align*}$$</p><p>现在开始采用归纳证明法</p><p>假设下列两个等式成立：</p>$$    \begin{align*}        Fib(n)   =& (\phi^n-\psi^n)/\sqrt5 \\        Fib(n-1) =& (\phi^{n-1}-\psi^{n-1})/\sqrt5 \\    \end{align*}$$<p>我们现在需要证明以下等式成立：</p>$$    \begin{align*}        Fib(n+1) =& (\phi^{n+1}-\psi^{n+1})/\sqrt5 \\    \end{align*}$$<p>通过 Fibonacci 序列的性质与之前提到的 $\phi$ 和 $\psi$ 的性质，可给出如下的证明过程：</p>$$    \begin{align*}        Fib(n+1) =& Fib(n) + Fib(n-1) \\                 =& (\phi^n-\psi^n)/\sqrt5 + (\phi^{n-1}-\psi^{n-1})/\sqrt5 \\                 =& ((\phi^n-\psi^n) + (\phi^{n-1}-\psi^{n-1}))/\sqrt5 \\                 =& ((\phi^n+\phi^{n-1}) - (\psi^n+\psi^{n-1}))/\sqrt5 \\                 =& (\phi^{n+1} * (\phi^{-1}+\phi^{-2}) - \psi^{n+1} * (\psi^{-1}+\psi^{-2})) / \sqrt5 \\                 =& (\phi^{n+1} * \phi^{-1} * (1+\phi^{-1}) - \psi^{n+1} * \psi^{-1} * (1+\psi^{-1})) / \sqrt5 \\                 =& (\phi^{n+1} * 1/\phi * (1+1/\phi) - \psi^{n+1} * 1/\psi * (1+1/\psi)) / \sqrt5 \\                 =& (\phi^{n+1} * 1/\phi * \phi - \psi^{n+1} * 1/\psi * \psi) / \sqrt5 \\                 =& (\phi^{n+1} - \psi^{n+1}) / \sqrt5 \\    \end{align*}$$<h2 id="最后一步"><a href="#最后一步" class="headerlink" title="最后一步"></a>最后一步</h2><p>我们首先简单转化一下之前证明过的等式：</p>$$    \begin{align*}        Fib(n) =& (\phi^n-\psi^n)/\sqrt5 \\        Fib(n) =& \phi^n/\sqrt5 - \psi^n/\sqrt5 \\        \phi^n/\sqrt5 - Fib(n) =& \psi^n/\sqrt5 \\    \end{align*}$$<p>做以上变换是因为我们的目的是证明 $Fib(n)$ 和 $\phi^n/\sqrt5$ 之间的关系。现在我们需要做的就是证明这两者的差总是小于 $1/2$。即证明：</p>$$    \begin{align*}        \psi^n/\sqrt5 \leq 1/2    \end{align*}$$<p>即证明：</p>$$    \begin{align*}        \psi^n \leq \sqrt5/2    \end{align*}$$<p>由于 $\psi=(1-\sqrt5)/2$，我们可以计算求得：</p>$$    \begin{align*}        \psi \approx -0.618304    \end{align*}$$<p>由于 $Fib(n)$ 总是整数且 $n \geq 0$，$|\psi| &lt; 1$，可以得出：</p>$$    \begin{align*}        \psi^n \leq 1    \end{align*}$$<p>同时：</p>$$    \begin{align*}        \sqrt5/2 \approx 1.118    \end{align*}$$<p>因为 $\psi^n \leq 1$，且 $\sqrt5/2 &gt; 1$，所以：</p>$$    \begin{align*}        \psi^n < \sqrt5/2    \end{align*}$$<p>因此，$Fib(n)$ 是最接近 $\psi^n/\sqrt5$ 的整数。</p><p>完。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="http://www.billthelizard.com/2009/12/sicp-exercise-113-fibonacci-and-golden.html" target="_blank" rel="noopener">Bill the Lizard</a></li><li><a href="https://en.wikipedia.org/wiki/Fibonacci_number#Closed-form_expression" target="_blank" rel="noopener">Fibonacci number</a></li><li><a href="https://artofproblemsolving.com/wiki/index.php?title=Binet%27s_Formula" target="_blank" rel="noopener">Binet’s Formula - Art of Problem Solving</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;概览&quot;&gt;&lt;a href=&quot;#概览&quot; class=&quot;headerlink&quot; title=&quot;概览&quot;&gt;&lt;/a&gt;概览&lt;/h1&gt;&lt;p&gt;此题出自 SICP 第一章练习题 1.13&lt;/p&gt;
&lt;h1 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h1&gt;&lt;p&gt;Prove that $Fib(n)$ is the closest integer to $\phi^n/\sqrt5$, where $\phi=(1+\sqrt5)/2$. Hint: Let $\psi=(1-\sqrt5)/2$. Use induction and definition of the Fibonacci numbers (see section 1.2.2) to prove that $Fib(n)=(\phi^n-\psi^n)/\sqrt5$.&lt;br&gt;
    
    </summary>
    
      <category term="Fun with number theory" scheme="https://cuixiaochen.com/categories/Fun-with-number-theory/"/>
    
    
      <category term="sicp" scheme="https://cuixiaochen.com/tags/sicp/"/>
    
      <category term="number theory" scheme="https://cuixiaochen.com/tags/number-theory/"/>
    
  </entry>
  
  <entry>
    <title>Counting Change 问题的详细分析及解答</title>
    <link href="https://cuixiaochen.com/2018/07/08/count-change/"/>
    <id>https://cuixiaochen.com/2018/07/08/count-change/</id>
    <published>2018-07-08T06:26:39.000Z</published>
    <updated>2018-07-10T14:43:00.423Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>Counting change 问题来源于 SICP 第一章 1.2 节，书中给出了树形递归解法，并将迭代解法作为了课后练习。本文将会详细解答此题的迭代解法并给出运行时间的对比。<br><a id="more"></a></p><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>给了半美元、四分之一美元、10 美分、5 美分和 1 美分的硬币，将 1 美元换成零钱，一共有多少种不同方式？</p><h1 id="消除递归"><a href="#消除递归" class="headerlink" title="消除递归"></a>消除递归</h1><p>消除递归最通用的方法是使用辅助栈 (auxiliary stack)。简单来说就是将参数推入栈中，然后开始迭代，直到得到我们想要的结果。</p><p>具体到本题，我们将使用自底向上的动态规划 (dynamic programming) 来解决问题，同时因为我们身（天）经（天）百（刷）战（题），很容易在给出一般性的动态规划解法之后进行优化，将所需的栈空间压缩到 O(1)。</p><h1 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h1><p>设 $f(x, n)$ 为使用最小面值的 n 种硬币换 x 美分的方法总数。</p><p>我们从 $f(x, 1)$ 开始分析。此时 $n=1$，表示只使用 1 美分硬币换 x 美分。显然得出，$f(0, 1)=1$。同时（a 为最小面值硬币的面值）：</p>$$    \begin{align*}        \underset{x>0}{f(x, 1)}=\left\{                                    \begin{array}{ll}                                        1, & \text{for } x \bmod a \equiv 0\\                                        0, & \text{for } x \bmod a \neq 0\\                                    \end{array}                                \right.    \end{align*}$$<p>因为此题中最小面值的硬币面值为 1 美分，所以 $\underset{x&gt;0}{f(x, 1)}=1$</p><p>接下来，我们开始推导到 n=2 时到情况，即使用面值最小的 2 种硬币换 x 美分。设 a 为面值第二小的硬币的面值（在此题中为 5）。则有：</p>$$    \begin{align*}        f(x, 2)=\left\{                    \begin{array}{ll}                        f(x, 1)+f(x-a, 2), & \text{for } x > 0\\                        1, & \text{for } x \equiv 0\\                        0, & \text{for } x < 0\\                    \end{array}                \right.    \end{align*}$$<p>同理可给出一般性的方程：$f(x, n)=f(x, n-1)+f(x-a, n)$（其中 a 为 n 种硬币中最大面值硬币的面值）。</p><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>在这里我们给出 scheme 的实现，空间占用为 $O(n^2)$，时间复杂度为 $O(n^2)$</p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">count-change</span> amount)</span><br><span class="line">  (<span class="name">cc</span> amount <span class="number">5</span>))</span><br><span class="line"></span><br><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">cc</span> amount n)</span><br><span class="line">  (<span class="name"><span class="builtin-name">cond</span></span> ((<span class="name"><span class="builtin-name">&lt;</span></span> amount <span class="number">0</span>) <span class="number">0</span>)</span><br><span class="line">        ((<span class="name"><span class="builtin-name">=</span></span> n <span class="number">1</span>) <span class="number">1</span>)</span><br><span class="line">        (<span class="name"><span class="builtin-name">else</span></span> (<span class="name"><span class="builtin-name">+</span></span> (<span class="name">cc</span> amount</span><br><span class="line">                     (<span class="name"><span class="builtin-name">-</span></span> n <span class="number">1</span>))</span><br><span class="line">                 (<span class="name">cc</span> (<span class="name"><span class="builtin-name">-</span></span> amount (<span class="name">get-value</span> n))</span><br><span class="line">                     n)))))</span><br><span class="line"></span><br><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">get-value</span> n)</span><br><span class="line">  (<span class="name"><span class="builtin-name">cond</span></span> ((<span class="name"><span class="builtin-name">=</span></span> n <span class="number">1</span>) <span class="number">1</span>)</span><br><span class="line">        ((<span class="name"><span class="builtin-name">=</span></span> n <span class="number">2</span>) <span class="number">5</span>)</span><br><span class="line">        ((<span class="name"><span class="builtin-name">=</span></span> n <span class="number">3</span>) <span class="number">10</span>)</span><br><span class="line">        ((<span class="name"><span class="builtin-name">=</span></span> n <span class="number">4</span>) <span class="number">25</span>)</span><br><span class="line">        ((<span class="name"><span class="builtin-name">=</span></span> n <span class="number">5</span>) <span class="number">50</span>)))</span><br></pre></td></tr></table></figure><h2 id="改进"><a href="#改进" class="headerlink" title="改进"></a>改进</h2><p>简单改进一下，即可将空间占用降低至 $O(1)$，同时时间复杂度不变</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">待填坑</span><br></pre></td></tr></table></figure><h1 id="与原有树形递归解法的比较"><a href="#与原有树形递归解法的比较" class="headerlink" title="与原有树形递归解法的比较"></a>与原有树形递归解法的比较</h1><h2 id="运行时间"><a href="#运行时间" class="headerlink" title="运行时间"></a>运行时间</h2><p>我们在硬件相同、运行环境相同的情况下分别用这两种解法计算 (count-change 2000)</p><p>树形递归解法：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ time racket -t chapter-1/count-change-tree-recusive.scm</span><br><span class="line">11712101</span><br><span class="line">racket -t chapter-1/count-change-tree-recusive.scm  74.17s user 0.25s system 99% cpu 1:14.45 total</span><br></pre></td></tr></table></figure><p>迭代解法 (DP)：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ time racket -t chapter-1/count-change-iteration.scm</span><br><span class="line">11712101</span><br><span class="line">racket -t chapter-1/count-change-iteration.scm  0.40s user 0.08s system 95% cpu 0.501 total</span><br></pre></td></tr></table></figure><p>可以看到，在 x 为 2000 时，树形递归解法消耗的时间是迭代解法的 148 倍。且由于前者的时间复杂度为指数级别，随着 x 的增加，其消耗时间的增长速度会越来越快。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://stackoverflow.com/questions/1485022/sicp-making-change" target="_blank" rel="noopener">SICP making change</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;p&gt;Counting change 问题来源于 SICP 第一章 1.2 节，书中给出了树形递归解法，并将迭代解法作为了课后练习。本文将会详细解答此题的迭代解法并给出运行时间的对比。&lt;br&gt;
    
    </summary>
    
    
      <category term="sicp" scheme="https://cuixiaochen.com/tags/sicp/"/>
    
      <category term="algorithm" scheme="https://cuixiaochen.com/tags/algorithm/"/>
    
      <category term="dynamic programming" scheme="https://cuixiaochen.com/tags/dynamic-programming/"/>
    
  </entry>
  
  <entry>
    <title>SICP 学习环境的搭建</title>
    <link href="https://cuixiaochen.com/2018/07/07/sicp-env/"/>
    <id>https://cuixiaochen.com/2018/07/07/sicp-env/</id>
    <published>2018-07-07T11:11:23.000Z</published>
    <updated>2018-07-07T12:06:10.936Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>If art interprets our dream, the computer executes them in the guise of programs!<br>– Alan J. Perlis</p></blockquote><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>SICP 从 lisp 语法开始，为我们构成了一个包含计算机理论学科的闭环系统。今天开始我们要借助这本书更深入地理解程序的本质，<br><a id="more"></a></p><p>在运行环境方面，有两种选择：<a href="https://www.gnu.org/software/mit-scheme/" target="_blank" rel="noopener">mit-scheme</a>, <a href="https://racket-lang.org/" target="_blank" rel="noopener">racket</a>。其中 racket 提供图形化界面的 DrRacket 以及命令行界面 racket。笔者倾向于使用命令行界面的 racket 作为运行环境，并使用 vim 作为代码编辑器。接下来我将简单介绍一下这两种运行环境的安装及基本使用，并列出一些讲解进阶使用的文章供大家更舒服地编写 scheme。</p><h1 id="mit-scheme"><a href="#mit-scheme" class="headerlink" title="mit-scheme"></a>mit-scheme</h1><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p><code>brew install mit-scheme</code></p><h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><p>相比于 racket 的 REPL，mit-scheme 缺少了诸如自动补全、快速跳转之类的功能</p><h1 id="racket"><a href="#racket" class="headerlink" title="racket"></a>racket</h1><h2 id="安装-1"><a href="#安装-1" class="headerlink" title="安装"></a>安装</h2><p>可以从 <a href="https://racket-lang.org/" target="_blank" rel="noopener">racket</a> 下载安装包进行安装，也可以直接通过命令行 <code>brew cask install racket</code> 安装完整的 racket 客户端。如果通过 <code>brew install racket</code> 安装，则仅会安装一个最精简的、不包括 DrRacket 的 racket 客户端。</p><h2 id="加载-scheme-源文件"><a href="#加载-scheme-源文件" class="headerlink" title="加载 scheme 源文件"></a>加载 scheme 源文件</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">racket -f &lt;file&gt;  # 详见 racket -h</span><br></pre></td></tr></table></figure><p>或在 REPL 中执行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; (load &quot;example.scm&quot;)</span><br></pre></td></tr></table></figure><h1 id="拓展阅读"><a href="#拓展阅读" class="headerlink" title="拓展阅读"></a>拓展阅读</h1><p>由于笔者还未做深入研究，在这里先列出一些链接。</p><ul><li><a href="https://racket-zh.org/faq" target="_blank" rel="noopener">Racket 常见问题</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;If art interprets our dream, the computer executes them in the guise of programs!&lt;br&gt;– Alan J. Perlis&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;SICP 从 lisp 语法开始，为我们构成了一个包含计算机理论学科的闭环系统。今天开始我们要借助这本书更深入地理解程序的本质，&lt;br&gt;
    
    </summary>
    
    
      <category term="sicp" scheme="https://cuixiaochen.com/tags/sicp/"/>
    
      <category term="scheme" scheme="https://cuixiaochen.com/tags/scheme/"/>
    
      <category term="functional programming" scheme="https://cuixiaochen.com/tags/functional-programming/"/>
    
  </entry>
  
  <entry>
    <title>Cryptography Week 4 - Programming Assignment</title>
    <link href="https://cuixiaochen.com/2018/06/28/cryptography-week-4-program-assigment/"/>
    <id>https://cuixiaochen.com/2018/06/28/cryptography-week-4-program-assigment/</id>
    <published>2018-06-28T12:54:02.000Z</published>
    <updated>2018-08-12T09:52:33.741Z</updated>
    
    <content type="html"><![CDATA[<p>这次我们的目标是利用 <a href="https://en.wikipedia.org/wiki/Padding_oracle_attack" target="_blank" rel="noopener">Padding oracle attack</a> 破解加密过的消息，padding oracle attack 的原理相对来讲比较简单，但是在具体的编程破解过程中需要注意几个问题：</p><ul><li>发送 chosen ciphertext 的间隔时间不能太短，不然会收到 500 响应</li><li>在第一个字节被成功 decrypt 之后，可根据 padding 格式跳过一些字节，节省一些时间<a id="more"></a></li><li>当一个 block 被完全 decrypt 之后，需要将 ciphertext 的最后一个 block 丢弃，使当前 decrypt 的 message block 被服务器认为是最后一个 message block，这样才能利用 padding oracle</li><li>除以上几点外还有一些 trival 的小坑需要留心，在此不做赘述</li></ul><img src="/2018/06/28/cryptography-week-4-program-assigment/pp.png"><p>最终代码：<a href="https://github.com/XiaochenCui/cryptography-homework/blob/master/week_4/padding_oracle.py" target="_blank" rel="noopener">github</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这次我们的目标是利用 &lt;a href=&quot;https://en.wikipedia.org/wiki/Padding_oracle_attack&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Padding oracle attack&lt;/a&gt; 破解加密过的消息，padding oracle attack 的原理相对来讲比较简单，但是在具体的编程破解过程中需要注意几个问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;发送 chosen ciphertext 的间隔时间不能太短，不然会收到 500 响应&lt;/li&gt;
&lt;li&gt;在第一个字节被成功 decrypt 之后，可根据 padding 格式跳过一些字节，节省一些时间
    
    </summary>
    
      <category term="Exercises of Cryptography" scheme="https://cuixiaochen.com/categories/Exercises-of-Cryptography/"/>
    
    
      <category term="cryptography" scheme="https://cuixiaochen.com/tags/cryptography/"/>
    
  </entry>
  
  <entry>
    <title>Cryptography Week 4 - Problem Set</title>
    <link href="https://cuixiaochen.com/2018/06/28/cryptography-week-4-problem-set/"/>
    <id>https://cuixiaochen.com/2018/06/28/cryptography-week-4-problem-set/</id>
    <published>2018-06-28T12:23:36.000Z</published>
    <updated>2018-08-12T06:50:31.612Z</updated>
    
    <content type="html"><![CDATA[<img src="/2018/06/28/cryptography-week-4-problem-set/1.png" width="700"><p>我们可以从 <a href="https://en.wikipedia.org/wiki/Padding_oracle_attack" target="_blank" rel="noopener">Padding oracle attack</a> 中找到伪造密文的思路：<br>设：$1 \oplus x = 5$, IV 中的对应字节为 $y$<br>则：当 $y’ = y \oplus x$ 时，$y \oplus 1 \equiv y’ \oplus 5$<br>所以：将 $y$ 更改为 $y’$ 可使 message 中的相应字节变更为 5<br><a id="more"></a></p><img src="/2018/06/28/cryptography-week-4-problem-set/2.png" width="700"><p>第二个选项中提供的加密系统由于不会输出 bottom，所以一定不提供 authenticated encryption<br>第三个选项中的加密系统只需保持 $c_1 \equiv c_2$，即可成功进行 chosen ciphertext attack</p><img src="/2018/06/28/cryptography-week-4-problem-set/3.png" width="700"><p>Dan Boneh 教授已经强调过无数次：”Never implements encrypt method by yourself”</p><p>4 ~ 10 题都比较简单，在此不做讲解<br><img src="/2018/06/28/cryptography-week-4-problem-set/4.png" width="700"></p><img src="/2018/06/28/cryptography-week-4-problem-set/5.png" width="700"><img src="/2018/06/28/cryptography-week-4-problem-set/6.png" width="700"><img src="/2018/06/28/cryptography-week-4-problem-set/7.png" width="700"><img src="/2018/06/28/cryptography-week-4-problem-set/8.png" width="700"><img src="/2018/06/28/cryptography-week-4-problem-set/9.png" width="700"><img src="/2018/06/28/cryptography-week-4-problem-set/10.png" width="700">]]></content>
    
    <summary type="html">
    
      &lt;img src=&quot;/2018/06/28/cryptography-week-4-problem-set/1.png&quot; width=&quot;700&quot;&gt;
&lt;p&gt;我们可以从 &lt;a href=&quot;https://en.wikipedia.org/wiki/Padding_oracle_attack&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Padding oracle attack&lt;/a&gt; 中找到伪造密文的思路：&lt;br&gt;设：$1 \oplus x = 5$, IV 中的对应字节为 $y$&lt;br&gt;则：当 $y’ = y \oplus x$ 时，$y \oplus 1 \equiv y’ \oplus 5$&lt;br&gt;所以：将 $y$ 更改为 $y’$ 可使 message 中的相应字节变更为 5&lt;br&gt;
    
    </summary>
    
      <category term="Exercises of Cryptography" scheme="https://cuixiaochen.com/categories/Exercises-of-Cryptography/"/>
    
    
      <category term="cryptography" scheme="https://cuixiaochen.com/tags/cryptography/"/>
    
  </entry>
  
  <entry>
    <title>一些关于 Authenticated Encryption 的 paper（二）</title>
    <link href="https://cuixiaochen.com/2018/06/25/some-pater-about-auth-enc-2/"/>
    <id>https://cuixiaochen.com/2018/06/25/some-pater-about-auth-enc-2/</id>
    <published>2018-06-25T14:17:46.000Z</published>
    <updated>2018-06-25T14:27:48.369Z</updated>
    
    <content type="html"><![CDATA[<ul><li><a href="https://eprint.iacr.org/2010/264.pdf" target="_blank" rel="noopener">Cryptographic Extraction and Key Derivation: The HKDF Scheme. H.Krawczyk, Crypto 2010</a></li><li><a href="http://web.cs.ucdavis.edu/~rogaway/papers/keywrap.pdf" target="_blank" rel="noopener">Deterministic Authenticated-Encryption: A Provable-Security Treatment of the Keywrap Problem. P.Rogaway, T.Shrimption, Enrocrypt 2006</a><a id="more"></a></li><li><a href="https://eprint.iacr.org/2003/147.pdf" target="_blank" rel="noopener">A Parallelizable Enciphering Mode. S.Halevi, P.Rogaway, CT-RSA 2004</a></li><li><a href="http://web.cs.ucdavis.edu/~rogaway/papers/offsets.pdf" target="_blank" rel="noopener">Efficient Instantiations of Tweakable Blockciphers and Refinements to Modes OCB and PMAC. P.Rogaway, Asiacrypt 2004</a></li><li><a href="http://web.cs.ucdavis.edu/~rogaway/papers/thorp.pdf" target="_blank" rel="noopener">How to Encipher Messages on a Small Domain: Deterministic Encryption and the Thorp Shuffle. B.Morris, P.Rogaway, T.Stegers, Crypto 2009</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://eprint.iacr.org/2010/264.pdf&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Cryptographic Extraction and Key Derivation: The HKDF Scheme. H.Krawczyk, Crypto 2010&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://web.cs.ucdavis.edu/~rogaway/papers/keywrap.pdf&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Deterministic Authenticated-Encryption: A Provable-Security Treatment of the Keywrap Problem. P.Rogaway, T.Shrimption, Enrocrypt 2006&lt;/a&gt;
    
    </summary>
    
    
      <category term="cryptography" scheme="https://cuixiaochen.com/tags/cryptography/"/>
    
  </entry>
  
  <entry>
    <title>Architecture - 东风集团传统能源车平台</title>
    <link href="https://cuixiaochen.com/2018/06/21/architect-fuel/"/>
    <id>https://cuixiaochen.com/2018/06/21/architect-fuel/</id>
    <published>2018-06-21T15:03:16.000Z</published>
    <updated>2018-06-25T14:30:28.355Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h1><p>本文将主要从消息总线、存储方案、查询方案以及指令下发等方面介绍东风传统能源车平台的技术架构。<br><a id="more"></a><br>此平台主要提供对车辆的监控及控制。</p><h2 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h2><p>通信协议基于 TCP 并兼容 GB32960。</p><p>注 1：由于硬件限制，我们并未使用 mqtt。</p><p>注 2：由于保密级别的限制，在此不对协议做过多介绍</p><h2 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h2><p>现有平台的容量预计为 10 万台车。车载终端在正常行驶情况下每 30 秒向平台发送一次数据包，数据包中包含车辆的实时信息，数据包大小按 1KB 记。当车辆出现异常时，车载终端以每秒一次的频率向平台发送报警数据包。</p><p>由此可粗略估算得出：QPS 大概为 5000，每天新增数据包总量大约为 500G。</p><h1 id="基础设施选择"><a href="#基础设施选择" class="headerlink" title="基础设施选择"></a>基础设施选择</h1><h2 id="存储"><a href="#存储" class="headerlink" title="存储"></a>存储</h2><p>由于所有数据包都需要存储以在日后做车况分析、数据统计以及故障排查，所以我们只能选择列式存储，具体的方案是使用 HBASE。业务逻辑相关的数据使用 MySQL/PostgreSQL 进行存储。</p><h2 id="消息总线"><a href="#消息总线" class="headerlink" title="消息总线"></a>消息总线</h2><p>由于该平台对 availability 和 durability 的要求极高，所以必须要有一个稳健的消息总线，数据包在到达系统的第一时间进入消息总线，以保证系统的 reliability 以及 fault tolerance。</p><p>消息总线的选择主要有 <a href="https://kafka.apache.org/documentation/#introduction" target="_blank" rel="noopener">Kafka</a>, <a href="https://redis.io/topics/streams-intro" target="_blank" rel="noopener">Redis Streams</a> 以及 <a href="https://www.rabbitmq.com/" target="_blank" rel="noopener">Rabbitmq</a>。</p><p>Kafka 的主要优势在于数据可靠性以及较高的性能。</p><p>Redis Streams 的主要优势在于其性能最高，而且由于我们的系统本来也需要 Redis 的支持，选择 Redis Streams 可以利用已有的 infrastructure。但由于 Redis 在接受到数据后先将其贮存到内存，随后再通过持久化的方式写入磁盘，可靠性不如 Kafka。</p><p>Rabbitmq 的主要优势在于其完整支持 <a href="https://www.amqp.org/" target="_blank" rel="noopener">AMQP</a> 协议，但其开启持久化后性能不足。</p><p>综上，我们选择 Apache Kafka 作为系统的消息总线。</p><h2 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h2><p>使用 Redis</p><h1 id="系统架构"><a href="#系统架构" class="headerlink" title="系统架构"></a>系统架构</h1><h2 id="架构简图"><a href="#架构简图" class="headerlink" title="架构简图"></a>架构简图</h2><p>系统架构简图如下，有部分省略</p><img src="/2018/06/21/architect-fuel/fuel.png"><p>未完待续</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;概览&quot;&gt;&lt;a href=&quot;#概览&quot; class=&quot;headerlink&quot; title=&quot;概览&quot;&gt;&lt;/a&gt;概览&lt;/h1&gt;&lt;p&gt;本文将主要从消息总线、存储方案、查询方案以及指令下发等方面介绍东风传统能源车平台的技术架构。&lt;br&gt;
    
    </summary>
    
    
      <category term="architecture" scheme="https://cuixiaochen.com/tags/architecture/"/>
    
  </entry>
  
  <entry>
    <title>一些关于 Authenticated Encryption 的 paper</title>
    <link href="https://cuixiaochen.com/2018/06/18/some-paper-about-auth-enc/"/>
    <id>https://cuixiaochen.com/2018/06/18/some-paper-about-auth-enc/</id>
    <published>2018-06-18T13:12:28.000Z</published>
    <updated>2018-06-18T13:34:21.507Z</updated>
    
    <content type="html"><![CDATA[<ul><li><a href="https://iacr.org/archive/crypto2001/21390309.pdf" target="_blank" rel="noopener">The Order of Encryption and Authentication for Protecting Communications, H.Krawczyk, Crypto 2001.</a><br>比较了 encrypt-then-MAC 和 MAC-then-encrypt</li><li><a href="http://web.cs.ucdavis.edu/~rogaway/papers/ad.pdf" target="_blank" rel="noopener">Authenticated-Encryption with Associated-Data, P.Rogaway, Proc. of CCS 2002.</a><br>讨论了 OCB<a id="more"></a></li><li><a href="https://www.iacr.org/cryptodb/archive/2003/CRYPTO/1069/1069.pdf" target="_blank" rel="noopener">Password Interception in a SSL/TLS Channel, B.Canvel, A.Hiltgen, S.Vaudenay, M.Vuagnoux, Crypto 2003.</a><br>介绍了 padding oracle attack</li><li><a href="http://www.isg.rhul.ac.uk/~kp/SandPfinal.pdf" target="_blank" rel="noopener">Plaintext Recovery Attacks Against SSH, M.Albrecht, K.Paterson and G.Watson, IEEE S&amp;P 2009.</a><br>介绍了 length attack</li><li><a href="https://www.cs.columbia.edu/~smb/papers/badesp.pdf" target="_blank" rel="noopener">Problem areas for the IP security protocols, S.Bellovin, Usenix Security 1996.</a><br>介绍了一些对于没有提供 integrity 而只是提供 CPA security 的协议的攻击方法，并借此告诉我们在加密中只提供 CPA security 是不安全的</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://iacr.org/archive/crypto2001/21390309.pdf&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;The Order of Encryption and Authentication for Protecting Communications, H.Krawczyk, Crypto 2001.&lt;/a&gt;&lt;br&gt;比较了 encrypt-then-MAC 和 MAC-then-encrypt&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://web.cs.ucdavis.edu/~rogaway/papers/ad.pdf&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Authenticated-Encryption with Associated-Data, P.Rogaway, Proc. of CCS 2002.&lt;/a&gt;&lt;br&gt;讨论了 OCB
    
    </summary>
    
    
      <category term="cryptography" scheme="https://cuixiaochen.com/tags/cryptography/"/>
    
  </entry>
  
  <entry>
    <title>Cryptography Week 3 - Programming Assignment</title>
    <link href="https://cuixiaochen.com/2018/06/12/cryptography-week-3-program-assignment/"/>
    <id>https://cuixiaochen.com/2018/06/12/cryptography-week-3-program-assignment/</id>
    <published>2018-06-11T23:44:36.000Z</published>
    <updated>2018-08-12T06:50:27.562Z</updated>
    
    <content type="html"><![CDATA[<p>本周的任务是实现对大文件的分块哈希，使得浏览器可以在仅收到一部分文件的时候进行 MAC 校验（假设初始 MAC 已通过可信赖的途径分发给浏览器）<br><a id="more"></a></p><img src="/2018/06/12/cryptography-week-3-program-assignment/pa.png"><p>代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> binascii</span><br><span class="line"><span class="keyword">from</span> Crypto.Hash <span class="keyword">import</span> SHA256</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">file_block_generator</span><span class="params">(content)</span>:</span></span><br><span class="line">    block_count, reminder = divmod(len(content), <span class="number">1024</span>)</span><br><span class="line">    <span class="keyword">for</span> block_index <span class="keyword">in</span> range(block_count + <span class="number">1</span>)[::<span class="number">-1</span>]:</span><br><span class="line">        start = block_index * <span class="number">1024</span></span><br><span class="line">        end = <span class="number">1024</span> * (block_index + <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">if</span> end &gt; len(content):</span><br><span class="line">            end = len(content)</span><br><span class="line">        block = content[start:end]</span><br><span class="line">        <span class="keyword">yield</span> block</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">blocked_hash</span><span class="params">(content)</span>:</span></span><br><span class="line">    h = <span class="keyword">None</span></span><br><span class="line">    <span class="keyword">for</span> block <span class="keyword">in</span> file_block_generator(content):</span><br><span class="line">        <span class="keyword">if</span> h:</span><br><span class="line">            block = block + h</span><br><span class="line">        h = SHA256.new()</span><br><span class="line">        h.update(block)</span><br><span class="line">        h = h.digest()</span><br><span class="line">    <span class="keyword">return</span> h</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="keyword">import</span> sys</span><br><span class="line">    f = open(sys.argv[<span class="number">1</span>], <span class="string">'rb'</span>)</span><br><span class="line">    h = blocked_hash(f.read())</span><br><span class="line">    print(binascii.hexlify(h))</span><br></pre></td></tr></table></figure><p>由于本题比较简单，在此不做过多讲解</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本周的任务是实现对大文件的分块哈希，使得浏览器可以在仅收到一部分文件的时候进行 MAC 校验（假设初始 MAC 已通过可信赖的途径分发给浏览器）&lt;br&gt;
    
    </summary>
    
      <category term="Exercises of Cryptography" scheme="https://cuixiaochen.com/categories/Exercises-of-Cryptography/"/>
    
    
      <category term="cryptography" scheme="https://cuixiaochen.com/tags/cryptography/"/>
    
  </entry>
  
  <entry>
    <title>Cryptography Week 3 - Problem Set</title>
    <link href="https://cuixiaochen.com/2018/06/11/cryptography-week-3-problem-set/"/>
    <id>https://cuixiaochen.com/2018/06/11/cryptography-week-3-problem-set/</id>
    <published>2018-06-11T12:55:20.000Z</published>
    <updated>2018-08-12T06:50:23.621Z</updated>
    
    <content type="html"><![CDATA[<p>这周的习题比较简单，不需要过多讲解</p><img src="/2018/06/11/cryptography-week-3-problem-set/1.png" width="700"><a id="more"></a><img src="/2018/06/11/cryptography-week-3-problem-set/2.png" width="700"><img src="/2018/06/11/cryptography-week-3-problem-set/3.png" width="700"><img src="/2018/06/11/cryptography-week-3-problem-set/4.png" width="700"><img src="/2018/06/11/cryptography-week-3-problem-set/5.png" width="700"><img src="/2018/06/11/cryptography-week-3-problem-set/6.png" width="700"><img src="/2018/06/11/cryptography-week-3-problem-set/7.png" width="700"><img src="/2018/06/11/cryptography-week-3-problem-set/8.png" width="700"><img src="/2018/06/11/cryptography-week-3-problem-set/9.png" width="700"><img src="/2018/06/11/cryptography-week-3-problem-set/10.png" width="700">]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这周的习题比较简单，不需要过多讲解&lt;/p&gt;
&lt;img src=&quot;/2018/06/11/cryptography-week-3-problem-set/1.png&quot; width=&quot;700&quot;&gt;
    
    </summary>
    
      <category term="Exercises of Cryptography" scheme="https://cuixiaochen.com/categories/Exercises-of-Cryptography/"/>
    
    
      <category term="cryptography" scheme="https://cuixiaochen.com/tags/cryptography/"/>
    
  </entry>
  
  <entry>
    <title>一些关于 MAC 的 paper</title>
    <link href="https://cuixiaochen.com/2018/06/09/some-paper-about-mac/"/>
    <id>https://cuixiaochen.com/2018/06/09/some-paper-about-mac/</id>
    <published>2018-06-09T06:41:14.000Z</published>
    <updated>2018-06-11T13:27:39.307Z</updated>
    
    <content type="html"><![CDATA[<ul><li><a href="http://web.cs.ucdavis.edu/~rogaway/papers/3k.pdf" target="_blank" rel="noopener">J.Bloack, P.Rogaway: CBC MACs for Arbitray-Length Messages: The Three-Key Constructions. J.Cryptology 18(2):111-131 (2005)</a><br>讲了 CMAC 的基础构型：three key construction</li><li><a href="https://pdfs.semanticscholar.org/0f8a/9d5bf4ef5a3863470f3faf38da2672f0fca1.pdf" target="_blank" rel="noopener">K.Pietrzak: A Tight Bound for EMAC. ICALP (2) 2006: 168-179</a><br>证明了 CBC-MAC 的超集是 PRF<a id="more"></a></li><li><a href="https://iacr.org/archive/eurocrypt2002/23320380/pmac.ps" target="_blank" rel="noopener">J.Block, P.Rogaway: A Block-Cipher Mode of Operation for Parallelizable Message Authentication. EUROCRYPT 2002: 384-397</a><br>讲了 PMAC 的构造</li><li><a href="https://eprint.iacr.org/2006/043.pdf" target="_blank" rel="noopener">M.Bellare: New Proofs for NMAC and HMAC:Security Without Collision-Resistance. CRYPTO 2006:602-619</a><br>谈论了 NMAC 和 HMAC 的安全性</li><li><a href="https://www.iacr.org/archive/eurocrypt2008/49650197/49650197.pdf" target="_blank" rel="noopener">Y.Dodis, K.Pietrazk, P.Puniya: A New Mode of Operation for Block Ciphers and Length-Preserving MACs. EUROCRYPT 2008: 198-219</a><br>这篇论文角度比较新奇，先假设 AES 并不是 PRG，而只是一个 regular unpredictable function，然后在这样的前提下成功地构建出了可用于 long message 的 MAC</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://web.cs.ucdavis.edu/~rogaway/papers/3k.pdf&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;J.Bloack, P.Rogaway: CBC MACs for Arbitray-Length Messages: The Three-Key Constructions. J.Cryptology 18(2):111-131 (2005)&lt;/a&gt;&lt;br&gt;讲了 CMAC 的基础构型：three key construction&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://pdfs.semanticscholar.org/0f8a/9d5bf4ef5a3863470f3faf38da2672f0fca1.pdf&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;K.Pietrzak: A Tight Bound for EMAC. ICALP (2) 2006: 168-179&lt;/a&gt;&lt;br&gt;证明了 CBC-MAC 的超集是 PRF
    
    </summary>
    
    
      <category term="cryptography" scheme="https://cuixiaochen.com/tags/cryptography/"/>
    
  </entry>
  
  <entry>
    <title>Cryptography Week 2 - Programming Assignment</title>
    <link href="https://cuixiaochen.com/2018/06/05/cryptography-week-2-programming-assignment/"/>
    <id>https://cuixiaochen.com/2018/06/05/cryptography-week-2-programming-assignment/</id>
    <published>2018-06-05T01:33:29.000Z</published>
    <updated>2018-08-12T06:50:19.060Z</updated>
    
    <content type="html"><![CDATA[<p>这次我们的任务是实现 CBC 和 CTR，要求用 AES 做为 PRF，所以我们只需要使用 AES 的加密算法。<br><a id="more"></a></p><img src="/2018/06/05/cryptography-week-2-programming-assignment/pa.png"><p>在这里我们仅贴出核心代码，完整代码在：<a href="https://github.com/XiaochenCui/cryptography-homework" target="_blank" rel="noopener">https://github.com/XiaochenCui/cryptography-homework</a></p><h1 id="CBC-Cipher-Block-Chaining"><a href="#CBC-Cipher-Block-Chaining" class="headerlink" title="CBC (Cipher Block Chaining)"></a>CBC (Cipher Block Chaining)</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">encrypt</span><span class="params">(msg, key, iv)</span>:</span></span><br><span class="line">    cipher = AES.new(key, AES.MODE_ECB)</span><br><span class="line">    cipher_block = iv</span><br><span class="line">    ciphertext = iv</span><br><span class="line">    <span class="keyword">for</span> msg_block <span class="keyword">in</span> msg_block_generator(msg, padding=<span class="keyword">True</span>):</span><br><span class="line">        cipher_block = cipher.encrypt(xor(cipher_block, msg_block))</span><br><span class="line">        ciphertext += cipher_block</span><br><span class="line">    <span class="keyword">return</span> ciphertext</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">decrypt</span><span class="params">(cipher_text, key)</span>:</span></span><br><span class="line">    cipher = AES.new(key, AES.MODE_ECB)</span><br><span class="line">    iv, cipher_text = cipher_text[:<span class="number">16</span>], cipher_text[<span class="number">16</span>:]</span><br><span class="line">    msg = <span class="string">b''</span></span><br><span class="line">    <span class="keyword">for</span> cipher_block <span class="keyword">in</span> cipher_block_generator(cipher_text):</span><br><span class="line">        msg_block = xor(cipher.decrypt(cipher_block), iv)</span><br><span class="line">        iv = cipher_block</span><br><span class="line">        msg += msg_block</span><br><span class="line">    <span class="keyword">if</span> msg[<span class="number">-16</span>:] == <span class="string">b'\x16'</span> * <span class="number">16</span>:</span><br><span class="line">        <span class="keyword">return</span> msg[:<span class="number">-16</span>]</span><br><span class="line">    pad_bytes = msg[<span class="number">-1</span>]</span><br><span class="line">    reminder = len(msg) - pad_bytes</span><br><span class="line">    <span class="keyword">if</span> msg[reminder:] == bytes([pad_bytes]) * pad_bytes:</span><br><span class="line">        <span class="keyword">return</span> msg[:reminder]</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        print(<span class="string">'Cipher_text is invalid'</span>)</span><br></pre></td></tr></table></figure><h1 id="CTR-Counter-mode"><a href="#CTR-Counter-mode" class="headerlink" title="CTR (Counter mode)"></a>CTR (Counter mode)</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">encrypt</span><span class="params">(msg, key, iv)</span>:</span></span><br><span class="line">    cipher = AES.new(key, AES.MODE_ECB)</span><br><span class="line">    ciphertext = <span class="string">b''</span></span><br><span class="line">    <span class="keyword">for</span> i, msg_block <span class="keyword">in</span> enumerate(msg_block_generator(msg, padding=<span class="keyword">False</span>)):</span><br><span class="line">        cipher_block = cipher.encrypt(byte.add(iv, i))</span><br><span class="line">        cipher_block = byte.xor(msg_block, cipher_block)</span><br><span class="line">        ciphertext += cipher_block</span><br><span class="line">    <span class="keyword">return</span> ciphertext</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">decrypt</span><span class="params">(cipher_text, key)</span>:</span></span><br><span class="line">    iv, cipher_text = cipher_text[:<span class="number">16</span>], cipher_text[<span class="number">16</span>:]</span><br><span class="line">    cipher = AES.new(key, AES.MODE_ECB)</span><br><span class="line">    msg = <span class="string">b''</span></span><br><span class="line">    <span class="keyword">for</span> i, cipher_block <span class="keyword">in</span> enumerate(cipher_block_generator(cipher_text)):</span><br><span class="line">        iv_encrypted = cipher.encrypt(byte.add(iv, i))</span><br><span class="line">        msg_block = byte.xor(cipher_block, iv_encrypted)</span><br><span class="line">        msg += msg_block</span><br><span class="line">    <span class="keyword">return</span> msg</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这次我们的任务是实现 CBC 和 CTR，要求用 AES 做为 PRF，所以我们只需要使用 AES 的加密算法。&lt;br&gt;
    
    </summary>
    
      <category term="Exercises of Cryptography" scheme="https://cuixiaochen.com/categories/Exercises-of-Cryptography/"/>
    
    
      <category term="cryptography" scheme="https://cuixiaochen.com/tags/cryptography/"/>
    
  </entry>
  
  <entry>
    <title>Cryptography Week 2 - Problem Set</title>
    <link href="https://cuixiaochen.com/2018/05/20/Cryptography-Week-2-Problem-Set/"/>
    <id>https://cuixiaochen.com/2018/05/20/Cryptography-Week-2-Problem-Set/</id>
    <published>2018-05-20T13:44:00.000Z</published>
    <updated>2018-08-12T06:50:09.815Z</updated>
    
    <content type="html"><![CDATA[<img src="/2018/05/20/Cryptography-Week-2-Problem-Set/1.png" width="700"><a id="more"></a>$2^{128}\approx3.4e+38$<img src="/2018/05/20/Cryptography-Week-2-Problem-Set/2.png" width="700"><img src="/2018/05/20/Cryptography-Week-2-Problem-Set/3.png" width="700"><img src="/2018/05/20/Cryptography-Week-2-Problem-Set/4.png" width="700">$$\begin{align*}        m = 0^{64}:& \\        &L_1 = 0^{32} R_1 \\        &R_1 = 0^{32} \oplus F(k_1, 0^{32}) \\        &L_2 = 0^{32} \oplus F(k_1, 0^{32}) \\        &R_2 = 0^{32} \oplus F(k_2, 0^{32}\oplus F(k_1,0^{32})) \\        m = 1^{32}0^{32}:& \\        &L_1 = 0^{32} R_1 \\        &R_1 = 1^{32} \oplus F(k_1, 0^{32}) \\        &L_2 = 1^{32} \oplus F(k_1, 0^{32}) \\        &R_2 = 0^{32} \oplus F(k_2, 1^{32}\oplus F(k_1,0^{32})) \\\end{align*}$$<p>Therefore:<br>$$    \underset{m = 0^{64}}{L_2} \oplus \underset{m = 1^{32}0^{32}}{L_2} \equiv 1^{32}$$</p><img src="/2018/05/20/Cryptography-Week-2-Problem-Set/5.png" width="700">$$\begin{align*}        c' &= F(k, IV \oplus m_1) \\        &= F(k, F(k, c_0) \oplus c_0 \oplus c_0) \\        &= F(k, F(k, c_0) \oplus c_0 \oplus F(k, c_0)) \\        &= F(k, c_0)\end{align*}$$<p>Therefore:<br>$$    c_1 = c'_0$$</p><img src="/2018/05/20/Cryptography-Week-2-Problem-Set/6.png" width="700"><img src="/2018/05/20/Cryptography-Week-2-Problem-Set/7.png" width="700"><img src="/2018/05/20/Cryptography-Week-2-Problem-Set/8.png" width="700"><img src="/2018/05/20/Cryptography-Week-2-Problem-Set/9.png" width="700">]]></content>
    
    <summary type="html">
    
      &lt;img src=&quot;/2018/05/20/Cryptography-Week-2-Problem-Set/1.png&quot; width=&quot;700&quot;&gt;
    
    </summary>
    
      <category term="Exercises of Cryptography" scheme="https://cuixiaochen.com/categories/Exercises-of-Cryptography/"/>
    
    
      <category term="cryptography" scheme="https://cuixiaochen.com/tags/cryptography/"/>
    
  </entry>
  
  <entry>
    <title>Redis 学习资料</title>
    <link href="https://cuixiaochen.com/2018/04/30/redis-study-references/"/>
    <id>https://cuixiaochen.com/2018/04/30/redis-study-references/</id>
    <published>2018-04-30T15:11:04.000Z</published>
    <updated>2018-07-15T15:01:27.028Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Source-Code"><a href="#Source-Code" class="headerlink" title="Source Code"></a>Source Code</h1><ul><li><a href="https://github.com/antirez/redis" target="_blank" rel="noopener">redis</a></li><li><a href="https://github.com/huangz1990/redis-3.0-annotated" target="_blank" rel="noopener">redis-3.0-annotated</a><br>带有详细注释的 Redis 3.0 代码<a id="more"></a></li></ul><h1 id="Books"><a href="#Books" class="headerlink" title="Books"></a>Books</h1><ul><li><a href="https://book.douban.com/subject/25900156/" target="_blank" rel="noopener">Redis 设计与实现</a><br>通俗易懂，深入浅出</li><li><a href="https://book.douban.com/subject/26612779/" target="_blank" rel="noopener">Redis 实战</a><br>入门书籍，价值不大</li></ul><h1 id="Archives"><a href="#Archives" class="headerlink" title="Archives"></a>Archives</h1><h2 id="Redlock"><a href="#Redlock" class="headerlink" title="Redlock"></a>Redlock</h2><ul><li><a href="https://redis.io/topics/distlock" target="_blank" rel="noopener">Distributed locks with Redis</a></li><li><a href="https://martin.kleppmann.com/2016/02/08/how-to-do-distributed-locking.html" target="_blank" rel="noopener">How to do distributed locking - Martin Kleppmann</a></li><li><a href="http://antirez.com/news/101" target="_blank" rel="noopener">Is Redlock safe? - antirez</a></li><li><a href="http://zhangtielei.com/posts/blog-redlock-reasoning.html" target="_blank" rel="noopener">基于 Redis 的分布式锁到底安全吗（上）？</a></li><li><a href="http://zhangtielei.com/posts/blog-redlock-reasoning-part2.html" target="_blank" rel="noopener">基于 Redis 的分布式锁到底安全吗（下）？</a></li></ul><h2 id="RESP-REdis-Serialization-Protocol"><a href="#RESP-REdis-Serialization-Protocol" class="headerlink" title="RESP(REdis Serialization Protocol)"></a>RESP(REdis Serialization Protocol)</h2><ul><li><a href="https://redis.io/topics/protocol" target="_blank" rel="noopener">Redis Protocol specification</a></li><li><a href="https://www.compose.com/articles/how-to-talk-raw-redis/" target="_blank" rel="noopener">How to talk raw Redis</a></li></ul><h2 id="Persistence"><a href="#Persistence" class="headerlink" title="Persistence"></a>Persistence</h2><ul><li><a href="http://oldblog.antirez.com/post/redis-persistence-demystified.html" target="_blank" rel="noopener">Redis persistence demystified</a></li></ul><h2 id="RDB"><a href="#RDB" class="headerlink" title="RDB"></a>RDB</h2><ul><li><a href="https://github.com/sripathikrishnan/redis-rdb-tools/wiki/Redis-RDB-Dump-File-Format" target="_blank" rel="noopener">Redis RDB Dump File Format</a></li><li><a href="https://github.com/sripathikrishnan/redis-rdb-tools/blob/master/docs/RDB_Version_History.textile" target="_blank" rel="noopener">Redis RDB Version History</a></li></ul><h1 id="Maillists"><a href="#Maillists" class="headerlink" title="Maillists"></a>Maillists</h1><ul><li><a href="https://groups.google.com/forum/#!forum/redis-db" target="_blank" rel="noopener">Redis DB</a></li><li><a href="https://groups.google.com/forum/#!forum/redis-dev" target="_blank" rel="noopener">redis-dev</a></li></ul><h1 id="Twitter"><a href="#Twitter" class="headerlink" title="Twitter"></a>Twitter</h1><ul><li><a href="https://twitter.com/redisfeed" target="_blank" rel="noopener">@redisfeed</a></li><li><a href="https://twitter.com/antirez" target="_blank" rel="noopener">@antirez</a></li></ul><p>待补充</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Source-Code&quot;&gt;&lt;a href=&quot;#Source-Code&quot; class=&quot;headerlink&quot; title=&quot;Source Code&quot;&gt;&lt;/a&gt;Source Code&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/antirez/redis&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;redis&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/huangz1990/redis-3.0-annotated&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;redis-3.0-annotated&lt;/a&gt;&lt;br&gt;带有详细注释的 Redis 3.0 代码
    
    </summary>
    
    
      <category term="redis" scheme="https://cuixiaochen.com/tags/redis/"/>
    
  </entry>
  
</feed>
