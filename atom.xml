<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>XiaochenCui&#39;s Blog</title>
  
  <subtitle>相隔天堑 却不觉遥远</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://cuixiaochen.com/"/>
  <updated>2018-07-10T14:43:00.423Z</updated>
  <id>https://cuixiaochen.com/</id>
  
  <author>
    <name>Xiaochen Cui</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Counting Change 问题的详细分析及解答</title>
    <link href="https://cuixiaochen.com/2018/07/08/count-change/"/>
    <id>https://cuixiaochen.com/2018/07/08/count-change/</id>
    <published>2018-07-08T06:26:39.000Z</published>
    <updated>2018-07-10T14:43:00.423Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>Counting change 问题来源于 SICP 第一章 1.2 节，书中给出了树形递归解法，并将迭代解法作为了课后练习。本文将会详细解答此题的迭代解法并给出运行时间的对比。<br><a id="more"></a></p><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>给了半美元、四分之一美元、10 美分、5 美分和 1 美分的硬币，将 1 美元换成零钱，一共有多少种不同方式？</p><h1 id="消除递归"><a href="#消除递归" class="headerlink" title="消除递归"></a>消除递归</h1><p>消除递归最通用的方法是使用辅助栈 (auxiliary stack)。简单来说就是将参数推入栈中，然后开始迭代，直到得到我们想要的结果。</p><p>具体到本题，我们将使用自底向上的动态规划 (dynamic programming) 来解决问题，同时因为我们身（天）经（天）百（刷）战（题），很容易在给出一般性的动态规划解法之后进行优化，将所需的栈空间压缩到 O(1)。</p><h1 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h1><p>设 $f(x, n)$ 为使用最小面值的 n 种硬币换 x 美分的方法总数。</p><p>我们从 $f(x, 1)$ 开始分析。此时 $n=1$，表示只使用 1 美分硬币换 x 美分。显然得出，$f(0, 1)=1$。同时（a 为最小面值硬币的面值）：</p>$$    \begin{align*}        \underset{x>0}{f(x, 1)}=\left\{                                    \begin{array}{ll}                                        1, & \text{for } x \bmod a \equiv 0\\                                        0, & \text{for } x \bmod a \neq 0\\                                    \end{array}                                \right.    \end{align*}$$<p>因为此题中最小面值的硬币面值为 1 美分，所以 $\underset{x&gt;0}{f(x, 1)}=1$</p><p>接下来，我们开始推导到 n=2 时到情况，即使用面值最小的 2 种硬币换 x 美分。设 a 为面值第二小的硬币的面值（在此题中为 5）。则有：</p>$$    \begin{align*}        f(x, 2)=\left\{                    \begin{array}{ll}                        f(x, 1)+f(x-a, 2), & \text{for } x > 0\\                        1, & \text{for } x \equiv 0\\                        0, & \text{for } x < 0\\                    \end{array}                \right.    \end{align*}$$<p>同理可给出一般性的方程：$f(x, n)=f(x, n-1)+f(x-a, n)$（其中 a 为 n 种硬币中最大面值硬币的面值）。</p><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>在这里我们给出 scheme 的实现，空间占用为 $O(n^2)$，时间复杂度为 $O(n^2)$</p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">count-change</span> amount)</span><br><span class="line">  (<span class="name">cc</span> amount <span class="number">5</span>))</span><br><span class="line"></span><br><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">cc</span> amount n)</span><br><span class="line">  (<span class="name"><span class="builtin-name">cond</span></span> ((<span class="name"><span class="builtin-name">&lt;</span></span> amount <span class="number">0</span>) <span class="number">0</span>)</span><br><span class="line">        ((<span class="name"><span class="builtin-name">=</span></span> n <span class="number">1</span>) <span class="number">1</span>)</span><br><span class="line">        (<span class="name"><span class="builtin-name">else</span></span> (<span class="name"><span class="builtin-name">+</span></span> (<span class="name">cc</span> amount</span><br><span class="line">                     (<span class="name"><span class="builtin-name">-</span></span> n <span class="number">1</span>))</span><br><span class="line">                 (<span class="name">cc</span> (<span class="name"><span class="builtin-name">-</span></span> amount (<span class="name">get-value</span> n))</span><br><span class="line">                     n)))))</span><br><span class="line"></span><br><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">get-value</span> n)</span><br><span class="line">  (<span class="name"><span class="builtin-name">cond</span></span> ((<span class="name"><span class="builtin-name">=</span></span> n <span class="number">1</span>) <span class="number">1</span>)</span><br><span class="line">        ((<span class="name"><span class="builtin-name">=</span></span> n <span class="number">2</span>) <span class="number">5</span>)</span><br><span class="line">        ((<span class="name"><span class="builtin-name">=</span></span> n <span class="number">3</span>) <span class="number">10</span>)</span><br><span class="line">        ((<span class="name"><span class="builtin-name">=</span></span> n <span class="number">4</span>) <span class="number">25</span>)</span><br><span class="line">        ((<span class="name"><span class="builtin-name">=</span></span> n <span class="number">5</span>) <span class="number">50</span>)))</span><br></pre></td></tr></table></figure><h2 id="改进"><a href="#改进" class="headerlink" title="改进"></a>改进</h2><p>简单改进一下，即可将空间占用降低至 $O(1)$，同时时间复杂度不变</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">待填坑</span><br></pre></td></tr></table></figure><h1 id="与原有树形递归解法的比较"><a href="#与原有树形递归解法的比较" class="headerlink" title="与原有树形递归解法的比较"></a>与原有树形递归解法的比较</h1><h2 id="运行时间"><a href="#运行时间" class="headerlink" title="运行时间"></a>运行时间</h2><p>我们在硬件相同、运行环境相同的情况下分别用这两种解法计算 (count-change 2000)</p><p>树形递归解法：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ time racket -t chapter-1/count-change-tree-recusive.scm</span><br><span class="line">11712101</span><br><span class="line">racket -t chapter-1/count-change-tree-recusive.scm  74.17s user 0.25s system 99% cpu 1:14.45 total</span><br></pre></td></tr></table></figure><p>迭代解法 (DP)：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ time racket -t chapter-1/count-change-iteration.scm</span><br><span class="line">11712101</span><br><span class="line">racket -t chapter-1/count-change-iteration.scm  0.40s user 0.08s system 95% cpu 0.501 total</span><br></pre></td></tr></table></figure><p>可以看到，在 x 为 2000 时，树形递归解法消耗的时间是迭代解法的 148 倍。且由于前者的时间复杂度为指数级别，随着 x 的增加，其消耗时间的增长速度会越来越快。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://stackoverflow.com/questions/1485022/sicp-making-change" target="_blank" rel="noopener">SICP making change</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;p&gt;Counting change 问题来源于 SICP 第一章 1.2 节，书中给出了树形递归解法，并将迭代解法作为了课后练习。本文将会详细解答此题的迭代解法并给出运行时间的对比。&lt;br&gt;
    
    </summary>
    
    
      <category term="sicp" scheme="https://cuixiaochen.com/tags/sicp/"/>
    
      <category term="algorithm" scheme="https://cuixiaochen.com/tags/algorithm/"/>
    
      <category term="dynamic programming" scheme="https://cuixiaochen.com/tags/dynamic-programming/"/>
    
  </entry>
  
  <entry>
    <title>SICP 学习环境的搭建</title>
    <link href="https://cuixiaochen.com/2018/07/07/sicp-env/"/>
    <id>https://cuixiaochen.com/2018/07/07/sicp-env/</id>
    <published>2018-07-07T11:11:23.000Z</published>
    <updated>2018-07-07T12:06:10.936Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>If art interprets our dream, the computer executes them in the guise of programs!<br>– Alan J. Perlis</p></blockquote><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>SICP 从 lisp 语法开始，为我们构成了一个包含计算机理论学科的闭环系统。今天开始我们要借助这本书更深入地理解程序的本质，<br><a id="more"></a></p><p>在运行环境方面，有两种选择：<a href="https://www.gnu.org/software/mit-scheme/" target="_blank" rel="noopener">mit-scheme</a>, <a href="https://racket-lang.org/" target="_blank" rel="noopener">racket</a>。其中 racket 提供图形化界面的 DrRacket 以及命令行界面 racket。笔者倾向于使用命令行界面的 racket 作为运行环境，并使用 vim 作为代码编辑器。接下来我将简单介绍一下这两种运行环境的安装及基本使用，并列出一些讲解进阶使用的文章供大家更舒服地编写 scheme。</p><h1 id="mit-scheme"><a href="#mit-scheme" class="headerlink" title="mit-scheme"></a>mit-scheme</h1><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p><code>brew install mit-scheme</code></p><h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><p>相比于 racket 的 REPL，mit-scheme 缺少了诸如自动补全、快速跳转之类的功能</p><h1 id="racket"><a href="#racket" class="headerlink" title="racket"></a>racket</h1><h2 id="安装-1"><a href="#安装-1" class="headerlink" title="安装"></a>安装</h2><p>可以从 <a href="https://racket-lang.org/" target="_blank" rel="noopener">racket</a> 下载安装包进行安装，也可以直接通过命令行 <code>brew cask install racket</code> 安装完整的 racket 客户端。如果通过 <code>brew install racket</code> 安装，则仅会安装一个最精简的、不包括 DrRacket 的 racket 客户端。</p><h2 id="加载-scheme-源文件"><a href="#加载-scheme-源文件" class="headerlink" title="加载 scheme 源文件"></a>加载 scheme 源文件</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">racket -f &lt;file&gt;  # 详见 racket -h</span><br></pre></td></tr></table></figure><p>或在 REPL 中执行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; (load &quot;example.scm&quot;)</span><br></pre></td></tr></table></figure><h1 id="拓展阅读"><a href="#拓展阅读" class="headerlink" title="拓展阅读"></a>拓展阅读</h1><p>由于笔者还未做深入研究，在这里先列出一些链接。</p><ul><li><a href="https://racket-zh.org/faq" target="_blank" rel="noopener">Racket 常见问题</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;If art interprets our dream, the computer executes them in the guise of programs!&lt;br&gt;– Alan J. Perlis&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;SICP 从 lisp 语法开始，为我们构成了一个包含计算机理论学科的闭环系统。今天开始我们要借助这本书更深入地理解程序的本质，&lt;br&gt;
    
    </summary>
    
    
      <category term="sicp" scheme="https://cuixiaochen.com/tags/sicp/"/>
    
      <category term="scheme" scheme="https://cuixiaochen.com/tags/scheme/"/>
    
      <category term="functional programming" scheme="https://cuixiaochen.com/tags/functional-programming/"/>
    
  </entry>
  
  <entry>
    <title>Cryptography Week 4 - Programming Project</title>
    <link href="https://cuixiaochen.com/2018/06/28/cryptography-week-4-program-assigment/"/>
    <id>https://cuixiaochen.com/2018/06/28/cryptography-week-4-program-assigment/</id>
    <published>2018-06-28T12:54:02.000Z</published>
    <updated>2018-06-30T08:19:07.799Z</updated>
    
    <content type="html"><![CDATA[<p>这次我们的目标是利用 <a href="https://en.wikipedia.org/wiki/Padding_oracle_attack" target="_blank" rel="noopener">Padding oracle attack</a> 破解加密过的消息，padding oracle attack 的原理相对来讲比较简单，但是在具体的编程破解过程中需要注意几个问题：</p><ul><li>发送 chosen ciphertext 的间隔时间不能太短，不然会收到 500 响应</li><li>在第一个字节被成功 decrypt 之后，可根据 padding 格式跳过一些字节，节省一些时间<a id="more"></a></li><li>当一个 block 被完全 decrypt 之后，需要将 ciphertext 的最后一个 block 丢弃，使当前 decrypt 的 message block 被服务器认为是最后一个 message block，这样才能利用 padding oracle</li><li>除以上几点外还有一些 trival 的小坑需要留心，在此不做赘述</li></ul><img src="/2018/06/28/cryptography-week-4-program-assigment/pp.png"><p>最终代码：<a href="https://github.com/XiaochenCui/cryptography-homework/blob/master/week_4/padding_oracle.py" target="_blank" rel="noopener">github</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这次我们的目标是利用 &lt;a href=&quot;https://en.wikipedia.org/wiki/Padding_oracle_attack&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Padding oracle attack&lt;/a&gt; 破解加密过的消息，padding oracle attack 的原理相对来讲比较简单，但是在具体的编程破解过程中需要注意几个问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;发送 chosen ciphertext 的间隔时间不能太短，不然会收到 500 响应&lt;/li&gt;
&lt;li&gt;在第一个字节被成功 decrypt 之后，可根据 padding 格式跳过一些字节，节省一些时间
    
    </summary>
    
    
      <category term="cryptography" scheme="https://cuixiaochen.com/tags/cryptography/"/>
    
  </entry>
  
  <entry>
    <title>Cryptography Week 4 - Problem Set</title>
    <link href="https://cuixiaochen.com/2018/06/28/cryptography-week-4-problem-set/"/>
    <id>https://cuixiaochen.com/2018/06/28/cryptography-week-4-problem-set/</id>
    <published>2018-06-28T12:23:36.000Z</published>
    <updated>2018-06-29T12:14:21.646Z</updated>
    
    <content type="html"><![CDATA[<img src="/2018/06/28/cryptography-week-4-problem-set/1.png" width="700"><p>我们可以从 <a href="https://en.wikipedia.org/wiki/Padding_oracle_attack" target="_blank" rel="noopener">Padding oracle attack</a> 中找到伪造密文的思路：<br>设：$1 \oplus x = 5$, IV 中的对应字节为 $y$<br>则：当 $y’ = y \oplus x$ 时，$y \oplus 1 \equiv y’ \oplus 5$<br>所以：将 $y$ 更改为 $y’$ 可使 message 中的相应字节变更为 5<br><a id="more"></a></p><img src="/2018/06/28/cryptography-week-4-problem-set/2.png" width="700"><p>第二个选项中提供的加密系统由于不会输出 bottom，所以一定不提供 authenticated encryption<br>第三个选项中的加密系统只需保持 $c_1 \equiv c_2$，即可成功进行 chosen ciphertext attack</p><img src="/2018/06/28/cryptography-week-4-problem-set/3.png" width="700"><p>Dan Boneh 教授已经强调过无数次：”Never implements encrypt method by yourself”</p><p>4 ~ 10 题都比较简单，在此不做讲解<br><img src="/2018/06/28/cryptography-week-4-problem-set/4.png" width="700"></p><img src="/2018/06/28/cryptography-week-4-problem-set/5.png" width="700"><img src="/2018/06/28/cryptography-week-4-problem-set/6.png" width="700"><img src="/2018/06/28/cryptography-week-4-problem-set/7.png" width="700"><img src="/2018/06/28/cryptography-week-4-problem-set/8.png" width="700"><img src="/2018/06/28/cryptography-week-4-problem-set/9.png" width="700"><img src="/2018/06/28/cryptography-week-4-problem-set/10.png" width="700">]]></content>
    
    <summary type="html">
    
      &lt;img src=&quot;/2018/06/28/cryptography-week-4-problem-set/1.png&quot; width=&quot;700&quot;&gt;
&lt;p&gt;我们可以从 &lt;a href=&quot;https://en.wikipedia.org/wiki/Padding_oracle_attack&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Padding oracle attack&lt;/a&gt; 中找到伪造密文的思路：&lt;br&gt;设：$1 \oplus x = 5$, IV 中的对应字节为 $y$&lt;br&gt;则：当 $y’ = y \oplus x$ 时，$y \oplus 1 \equiv y’ \oplus 5$&lt;br&gt;所以：将 $y$ 更改为 $y’$ 可使 message 中的相应字节变更为 5&lt;br&gt;
    
    </summary>
    
    
      <category term="cryptography" scheme="https://cuixiaochen.com/tags/cryptography/"/>
    
  </entry>
  
  <entry>
    <title>一些关于 Authenticated Encryption 的 paper（二）</title>
    <link href="https://cuixiaochen.com/2018/06/25/some-pater-about-auth-enc-2/"/>
    <id>https://cuixiaochen.com/2018/06/25/some-pater-about-auth-enc-2/</id>
    <published>2018-06-25T14:17:46.000Z</published>
    <updated>2018-06-25T14:27:48.369Z</updated>
    
    <content type="html"><![CDATA[<ul><li><a href="https://eprint.iacr.org/2010/264.pdf" target="_blank" rel="noopener">Cryptographic Extraction and Key Derivation: The HKDF Scheme. H.Krawczyk, Crypto 2010</a></li><li><a href="http://web.cs.ucdavis.edu/~rogaway/papers/keywrap.pdf" target="_blank" rel="noopener">Deterministic Authenticated-Encryption: A Provable-Security Treatment of the Keywrap Problem. P.Rogaway, T.Shrimption, Enrocrypt 2006</a><a id="more"></a></li><li><a href="https://eprint.iacr.org/2003/147.pdf" target="_blank" rel="noopener">A Parallelizable Enciphering Mode. S.Halevi, P.Rogaway, CT-RSA 2004</a></li><li><a href="http://web.cs.ucdavis.edu/~rogaway/papers/offsets.pdf" target="_blank" rel="noopener">Efficient Instantiations of Tweakable Blockciphers and Refinements to Modes OCB and PMAC. P.Rogaway, Asiacrypt 2004</a></li><li><a href="http://web.cs.ucdavis.edu/~rogaway/papers/thorp.pdf" target="_blank" rel="noopener">How to Encipher Messages on a Small Domain: Deterministic Encryption and the Thorp Shuffle. B.Morris, P.Rogaway, T.Stegers, Crypto 2009</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://eprint.iacr.org/2010/264.pdf&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Cryptographic Extraction and Key Derivation: The HKDF Scheme. H.Krawczyk, Crypto 2010&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://web.cs.ucdavis.edu/~rogaway/papers/keywrap.pdf&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Deterministic Authenticated-Encryption: A Provable-Security Treatment of the Keywrap Problem. P.Rogaway, T.Shrimption, Enrocrypt 2006&lt;/a&gt;
    
    </summary>
    
    
      <category term="cryptography" scheme="https://cuixiaochen.com/tags/cryptography/"/>
    
  </entry>
  
  <entry>
    <title>Architecture - 东风集团传统能源车平台</title>
    <link href="https://cuixiaochen.com/2018/06/21/architect-fuel/"/>
    <id>https://cuixiaochen.com/2018/06/21/architect-fuel/</id>
    <published>2018-06-21T15:03:16.000Z</published>
    <updated>2018-06-25T14:30:28.355Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h1><p>本文将主要从消息总线、存储方案、查询方案以及指令下发等方面介绍东风传统能源车平台的技术架构。<br><a id="more"></a><br>此平台主要提供对车辆的监控及控制。</p><h2 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h2><p>通信协议基于 TCP 并兼容 GB32960。</p><p>注 1：由于硬件限制，我们并未使用 mqtt。</p><p>注 2：由于保密级别的限制，在此不对协议做过多介绍</p><h2 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h2><p>现有平台的容量预计为 10 万台车。车载终端在正常行驶情况下每 30 秒向平台发送一次数据包，数据包中包含车辆的实时信息，数据包大小按 1KB 记。当车辆出现异常时，车载终端以每秒一次的频率向平台发送报警数据包。</p><p>由此可粗略估算得出：QPS 大概为 5000，每天新增数据包总量大约为 500G。</p><h1 id="基础设施选择"><a href="#基础设施选择" class="headerlink" title="基础设施选择"></a>基础设施选择</h1><h2 id="存储"><a href="#存储" class="headerlink" title="存储"></a>存储</h2><p>由于所有数据包都需要存储以在日后做车况分析、数据统计以及故障排查，所以我们只能选择列式存储，具体的方案是使用 HBASE。业务逻辑相关的数据使用 MySQL/PostgreSQL 进行存储。</p><h2 id="消息总线"><a href="#消息总线" class="headerlink" title="消息总线"></a>消息总线</h2><p>由于该平台对 availability 和 durability 的要求极高，所以必须要有一个稳健的消息总线，数据包在到达系统的第一时间进入消息总线，以保证系统的 reliability 以及 fault tolerance。</p><p>消息总线的选择主要有 <a href="https://kafka.apache.org/documentation/#introduction" target="_blank" rel="noopener">Kafka</a>, <a href="https://redis.io/topics/streams-intro" target="_blank" rel="noopener">Redis Streams</a> 以及 <a href="https://www.rabbitmq.com/" target="_blank" rel="noopener">Rabbitmq</a>。</p><p>Kafka 的主要优势在于数据可靠性以及较高的性能。</p><p>Redis Streams 的主要优势在于其性能最高，而且由于我们的系统本来也需要 Redis 的支持，选择 Redis Streams 可以利用已有的 infrastructure。但由于 Redis 在接受到数据后先将其贮存到内存，随后再通过持久化的方式写入磁盘，可靠性不如 Kafka。</p><p>Rabbitmq 的主要优势在于其完整支持 <a href="https://www.amqp.org/" target="_blank" rel="noopener">AMQP</a> 协议，但其开启持久化后性能不足。</p><p>综上，我们选择 Apache Kafka 作为系统的消息总线。</p><h2 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h2><p>使用 Redis</p><h1 id="系统架构"><a href="#系统架构" class="headerlink" title="系统架构"></a>系统架构</h1><h2 id="架构简图"><a href="#架构简图" class="headerlink" title="架构简图"></a>架构简图</h2><p>系统架构简图如下，有部分省略</p><img src="/2018/06/21/architect-fuel/fuel.png"><p>未完待续</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;概览&quot;&gt;&lt;a href=&quot;#概览&quot; class=&quot;headerlink&quot; title=&quot;概览&quot;&gt;&lt;/a&gt;概览&lt;/h1&gt;&lt;p&gt;本文将主要从消息总线、存储方案、查询方案以及指令下发等方面介绍东风传统能源车平台的技术架构。&lt;br&gt;
    
    </summary>
    
    
      <category term="architecture" scheme="https://cuixiaochen.com/tags/architecture/"/>
    
  </entry>
  
  <entry>
    <title>一些关于 Authenticated Encryption 的 paper</title>
    <link href="https://cuixiaochen.com/2018/06/18/some-paper-about-auth-enc/"/>
    <id>https://cuixiaochen.com/2018/06/18/some-paper-about-auth-enc/</id>
    <published>2018-06-18T13:12:28.000Z</published>
    <updated>2018-06-18T13:34:21.507Z</updated>
    
    <content type="html"><![CDATA[<ul><li><a href="https://iacr.org/archive/crypto2001/21390309.pdf" target="_blank" rel="noopener">The Order of Encryption and Authentication for Protecting Communications, H.Krawczyk, Crypto 2001.</a><br>比较了 encrypt-then-MAC 和 MAC-then-encrypt</li><li><a href="http://web.cs.ucdavis.edu/~rogaway/papers/ad.pdf" target="_blank" rel="noopener">Authenticated-Encryption with Associated-Data, P.Rogaway, Proc. of CCS 2002.</a><br>讨论了 OCB<a id="more"></a></li><li><a href="https://www.iacr.org/cryptodb/archive/2003/CRYPTO/1069/1069.pdf" target="_blank" rel="noopener">Password Interception in a SSL/TLS Channel, B.Canvel, A.Hiltgen, S.Vaudenay, M.Vuagnoux, Crypto 2003.</a><br>介绍了 padding oracle attack</li><li><a href="http://www.isg.rhul.ac.uk/~kp/SandPfinal.pdf" target="_blank" rel="noopener">Plaintext Recovery Attacks Against SSH, M.Albrecht, K.Paterson and G.Watson, IEEE S&amp;P 2009.</a><br>介绍了 length attack</li><li><a href="https://www.cs.columbia.edu/~smb/papers/badesp.pdf" target="_blank" rel="noopener">Problem areas for the IP security protocols, S.Bellovin, Usenix Security 1996.</a><br>介绍了一些对于没有提供 integrity 而只是提供 CPA security 的协议的攻击方法，并借此告诉我们在加密中只提供 CPA security 是不安全的</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://iacr.org/archive/crypto2001/21390309.pdf&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;The Order of Encryption and Authentication for Protecting Communications, H.Krawczyk, Crypto 2001.&lt;/a&gt;&lt;br&gt;比较了 encrypt-then-MAC 和 MAC-then-encrypt&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://web.cs.ucdavis.edu/~rogaway/papers/ad.pdf&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Authenticated-Encryption with Associated-Data, P.Rogaway, Proc. of CCS 2002.&lt;/a&gt;&lt;br&gt;讨论了 OCB
    
    </summary>
    
    
      <category term="cryptography" scheme="https://cuixiaochen.com/tags/cryptography/"/>
    
  </entry>
  
  <entry>
    <title>Cryptography Week 3 - Programming Assignment</title>
    <link href="https://cuixiaochen.com/2018/06/12/cryptography-week-3-program-assignment/"/>
    <id>https://cuixiaochen.com/2018/06/12/cryptography-week-3-program-assignment/</id>
    <published>2018-06-11T23:44:36.000Z</published>
    <updated>2018-06-11T23:54:00.106Z</updated>
    
    <content type="html"><![CDATA[<p>本周的任务是实现对大文件的分块哈希，使得浏览器可以在仅收到一部分文件的时候进行 MAC 校验（假设初始 MAC 已通过可信赖的途径分发给浏览器）<br><a id="more"></a></p><img src="/2018/06/12/cryptography-week-3-program-assignment/pa.png"><p>代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> binascii</span><br><span class="line"><span class="keyword">from</span> Crypto.Hash <span class="keyword">import</span> SHA256</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">file_block_generator</span><span class="params">(content)</span>:</span></span><br><span class="line">    block_count, reminder = divmod(len(content), <span class="number">1024</span>)</span><br><span class="line">    <span class="keyword">for</span> block_index <span class="keyword">in</span> range(block_count + <span class="number">1</span>)[::<span class="number">-1</span>]:</span><br><span class="line">        start = block_index * <span class="number">1024</span></span><br><span class="line">        end = <span class="number">1024</span> * (block_index + <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">if</span> end &gt; len(content):</span><br><span class="line">            end = len(content)</span><br><span class="line">        block = content[start:end]</span><br><span class="line">        <span class="keyword">yield</span> block</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">blocked_hash</span><span class="params">(content)</span>:</span></span><br><span class="line">    h = <span class="keyword">None</span></span><br><span class="line">    <span class="keyword">for</span> block <span class="keyword">in</span> file_block_generator(content):</span><br><span class="line">        <span class="keyword">if</span> h:</span><br><span class="line">            block = block + h</span><br><span class="line">        h = SHA256.new()</span><br><span class="line">        h.update(block)</span><br><span class="line">        h = h.digest()</span><br><span class="line">    <span class="keyword">return</span> h</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="keyword">import</span> sys</span><br><span class="line">    f = open(sys.argv[<span class="number">1</span>], <span class="string">'rb'</span>)</span><br><span class="line">    h = blocked_hash(f.read())</span><br><span class="line">    print(binascii.hexlify(h))</span><br></pre></td></tr></table></figure><p>由于本题比较简单，在此不做过多讲解</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本周的任务是实现对大文件的分块哈希，使得浏览器可以在仅收到一部分文件的时候进行 MAC 校验（假设初始 MAC 已通过可信赖的途径分发给浏览器）&lt;br&gt;
    
    </summary>
    
    
      <category term="cryptography" scheme="https://cuixiaochen.com/tags/cryptography/"/>
    
  </entry>
  
  <entry>
    <title>Cryptography Week 3 - Problem Set</title>
    <link href="https://cuixiaochen.com/2018/06/11/cryptography-week-3-problem-set/"/>
    <id>https://cuixiaochen.com/2018/06/11/cryptography-week-3-problem-set/</id>
    <published>2018-06-11T12:55:20.000Z</published>
    <updated>2018-06-11T13:28:35.851Z</updated>
    
    <content type="html"><![CDATA[<p>这周的习题比较简单，不需要过多讲解</p><img src="/2018/06/11/cryptography-week-3-problem-set/1.png" width="700"><a id="more"></a><img src="/2018/06/11/cryptography-week-3-problem-set/2.png" width="700"><img src="/2018/06/11/cryptography-week-3-problem-set/3.png" width="700"><img src="/2018/06/11/cryptography-week-3-problem-set/4.png" width="700"><img src="/2018/06/11/cryptography-week-3-problem-set/5.png" width="700"><img src="/2018/06/11/cryptography-week-3-problem-set/6.png" width="700"><img src="/2018/06/11/cryptography-week-3-problem-set/7.png" width="700"><img src="/2018/06/11/cryptography-week-3-problem-set/8.png" width="700"><img src="/2018/06/11/cryptography-week-3-problem-set/9.png" width="700"><img src="/2018/06/11/cryptography-week-3-problem-set/10.png" width="700">]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这周的习题比较简单，不需要过多讲解&lt;/p&gt;
&lt;img src=&quot;/2018/06/11/cryptography-week-3-problem-set/1.png&quot; width=&quot;700&quot;&gt;
    
    </summary>
    
    
      <category term="cryptography" scheme="https://cuixiaochen.com/tags/cryptography/"/>
    
  </entry>
  
  <entry>
    <title>一些关于 MAC 的 paper</title>
    <link href="https://cuixiaochen.com/2018/06/09/some-paper-about-mac/"/>
    <id>https://cuixiaochen.com/2018/06/09/some-paper-about-mac/</id>
    <published>2018-06-09T06:41:14.000Z</published>
    <updated>2018-06-11T13:27:39.307Z</updated>
    
    <content type="html"><![CDATA[<ul><li><a href="http://web.cs.ucdavis.edu/~rogaway/papers/3k.pdf" target="_blank" rel="noopener">J.Bloack, P.Rogaway: CBC MACs for Arbitray-Length Messages: The Three-Key Constructions. J.Cryptology 18(2):111-131 (2005)</a><br>讲了 CMAC 的基础构型：three key construction</li><li><a href="https://pdfs.semanticscholar.org/0f8a/9d5bf4ef5a3863470f3faf38da2672f0fca1.pdf" target="_blank" rel="noopener">K.Pietrzak: A Tight Bound for EMAC. ICALP (2) 2006: 168-179</a><br>证明了 CBC-MAC 的超集是 PRF<a id="more"></a></li><li><a href="https://iacr.org/archive/eurocrypt2002/23320380/pmac.ps" target="_blank" rel="noopener">J.Block, P.Rogaway: A Block-Cipher Mode of Operation for Parallelizable Message Authentication. EUROCRYPT 2002: 384-397</a><br>讲了 PMAC 的构造</li><li><a href="https://eprint.iacr.org/2006/043.pdf" target="_blank" rel="noopener">M.Bellare: New Proofs for NMAC and HMAC:Security Without Collision-Resistance. CRYPTO 2006:602-619</a><br>谈论了 NMAC 和 HMAC 的安全性</li><li><a href="https://www.iacr.org/archive/eurocrypt2008/49650197/49650197.pdf" target="_blank" rel="noopener">Y.Dodis, K.Pietrazk, P.Puniya: A New Mode of Operation for Block Ciphers and Length-Preserving MACs. EUROCRYPT 2008: 198-219</a><br>这篇论文角度比较新奇，先假设 AES 并不是 PRG，而只是一个 regular unpredictable function，然后在这样的前提下成功地构建出了可用于 long message 的 MAC</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://web.cs.ucdavis.edu/~rogaway/papers/3k.pdf&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;J.Bloack, P.Rogaway: CBC MACs for Arbitray-Length Messages: The Three-Key Constructions. J.Cryptology 18(2):111-131 (2005)&lt;/a&gt;&lt;br&gt;讲了 CMAC 的基础构型：three key construction&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://pdfs.semanticscholar.org/0f8a/9d5bf4ef5a3863470f3faf38da2672f0fca1.pdf&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;K.Pietrzak: A Tight Bound for EMAC. ICALP (2) 2006: 168-179&lt;/a&gt;&lt;br&gt;证明了 CBC-MAC 的超集是 PRF
    
    </summary>
    
    
      <category term="cryptography" scheme="https://cuixiaochen.com/tags/cryptography/"/>
    
  </entry>
  
  <entry>
    <title>Cryptography Week 2 - Programming Assignment</title>
    <link href="https://cuixiaochen.com/2018/06/05/cryptography-week-2-programming-assignment/"/>
    <id>https://cuixiaochen.com/2018/06/05/cryptography-week-2-programming-assignment/</id>
    <published>2018-06-05T01:33:29.000Z</published>
    <updated>2018-06-09T12:30:27.285Z</updated>
    
    <content type="html"><![CDATA[<p>这次我们的任务是实现 CBC 和 CTR，要求用 AES 做为 PRF，所以我们只需要使用 AES 的加密算法。<br><a id="more"></a></p><img src="/2018/06/05/cryptography-week-2-programming-assignment/pa.png"><p>在这里我们仅贴出核心代码，完整代码在：<a href="https://github.com/XiaochenCui/cryptography-homework" target="_blank" rel="noopener">https://github.com/XiaochenCui/cryptography-homework</a></p><h1 id="CBC-Cipher-Block-Chaining"><a href="#CBC-Cipher-Block-Chaining" class="headerlink" title="CBC (Cipher Block Chaining)"></a>CBC (Cipher Block Chaining)</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">encrypt</span><span class="params">(msg, key, iv)</span>:</span></span><br><span class="line">    cipher = AES.new(key, AES.MODE_ECB)</span><br><span class="line">    cipher_block = iv</span><br><span class="line">    ciphertext = iv</span><br><span class="line">    <span class="keyword">for</span> msg_block <span class="keyword">in</span> msg_block_generator(msg, padding=<span class="keyword">True</span>):</span><br><span class="line">        cipher_block = cipher.encrypt(xor(cipher_block, msg_block))</span><br><span class="line">        ciphertext += cipher_block</span><br><span class="line">    <span class="keyword">return</span> ciphertext</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">decrypt</span><span class="params">(cipher_text, key)</span>:</span></span><br><span class="line">    cipher = AES.new(key, AES.MODE_ECB)</span><br><span class="line">    iv, cipher_text = cipher_text[:<span class="number">16</span>], cipher_text[<span class="number">16</span>:]</span><br><span class="line">    msg = <span class="string">b''</span></span><br><span class="line">    <span class="keyword">for</span> cipher_block <span class="keyword">in</span> cipher_block_generator(cipher_text):</span><br><span class="line">        msg_block = xor(cipher.decrypt(cipher_block), iv)</span><br><span class="line">        iv = cipher_block</span><br><span class="line">        msg += msg_block</span><br><span class="line">    <span class="keyword">if</span> msg[<span class="number">-16</span>:] == <span class="string">b'\x16'</span> * <span class="number">16</span>:</span><br><span class="line">        <span class="keyword">return</span> msg[:<span class="number">-16</span>]</span><br><span class="line">    pad_bytes = msg[<span class="number">-1</span>]</span><br><span class="line">    reminder = len(msg) - pad_bytes</span><br><span class="line">    <span class="keyword">if</span> msg[reminder:] == bytes([pad_bytes]) * pad_bytes:</span><br><span class="line">        <span class="keyword">return</span> msg[:reminder]</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        print(<span class="string">'Cipher_text is invalid'</span>)</span><br></pre></td></tr></table></figure><h1 id="CTR-Counter-mode"><a href="#CTR-Counter-mode" class="headerlink" title="CTR (Counter mode)"></a>CTR (Counter mode)</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">encrypt</span><span class="params">(msg, key, iv)</span>:</span></span><br><span class="line">    cipher = AES.new(key, AES.MODE_ECB)</span><br><span class="line">    ciphertext = <span class="string">b''</span></span><br><span class="line">    <span class="keyword">for</span> i, msg_block <span class="keyword">in</span> enumerate(msg_block_generator(msg, padding=<span class="keyword">False</span>)):</span><br><span class="line">        cipher_block = cipher.encrypt(byte.add(iv, i))</span><br><span class="line">        cipher_block = byte.xor(msg_block, cipher_block)</span><br><span class="line">        ciphertext += cipher_block</span><br><span class="line">    <span class="keyword">return</span> ciphertext</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">decrypt</span><span class="params">(cipher_text, key)</span>:</span></span><br><span class="line">    iv, cipher_text = cipher_text[:<span class="number">16</span>], cipher_text[<span class="number">16</span>:]</span><br><span class="line">    cipher = AES.new(key, AES.MODE_ECB)</span><br><span class="line">    msg = <span class="string">b''</span></span><br><span class="line">    <span class="keyword">for</span> i, cipher_block <span class="keyword">in</span> enumerate(cipher_block_generator(cipher_text)):</span><br><span class="line">        iv_encrypted = cipher.encrypt(byte.add(iv, i))</span><br><span class="line">        msg_block = byte.xor(cipher_block, iv_encrypted)</span><br><span class="line">        msg += msg_block</span><br><span class="line">    <span class="keyword">return</span> msg</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这次我们的任务是实现 CBC 和 CTR，要求用 AES 做为 PRF，所以我们只需要使用 AES 的加密算法。&lt;br&gt;
    
    </summary>
    
    
      <category term="cryptography" scheme="https://cuixiaochen.com/tags/cryptography/"/>
    
  </entry>
  
  <entry>
    <title>Cryptography Week 2 - Problem Set</title>
    <link href="https://cuixiaochen.com/2018/05/20/Cryptography-Week-2-Problem-Set/"/>
    <id>https://cuixiaochen.com/2018/05/20/Cryptography-Week-2-Problem-Set/</id>
    <published>2018-05-20T13:44:00.000Z</published>
    <updated>2018-06-29T12:26:37.380Z</updated>
    
    <content type="html"><![CDATA[<img src="/2018/05/20/Cryptography-Week-2-Problem-Set/1.png" width="700"><a id="more"></a>$2^{128}\approx3.4e+38$<img src="/2018/05/20/Cryptography-Week-2-Problem-Set/2.png" width="700"><img src="/2018/05/20/Cryptography-Week-2-Problem-Set/3.png" width="700"><img src="/2018/05/20/Cryptography-Week-2-Problem-Set/4.png" width="700">$$\begin{align*}        m = 0^{64}:& \\        &L_1 = 0^{32} R_1 \\        &R_1 = 0^{32} \oplus F(k_1, 0^{32}) \\        &L_2 = 0^{32} \oplus F(k_1, 0^{32}) \\        &R_2 = 0^{32} \oplus F(k_2, 0^{32}\oplus F(k_1,0^{32})) \\        m = 1^{32}0^{32}:& \\        &L_1 = 0^{32} R_1 \\        &R_1 = 1^{32} \oplus F(k_1, 0^{32}) \\        &L_2 = 1^{32} \oplus F(k_1, 0^{32}) \\        &R_2 = 0^{32} \oplus F(k_2, 1^{32}\oplus F(k_1,0^{32})) \\\end{align*}$$<p>Therefore:<br>$$    \underset{m = 0^{64}}{L_2} \oplus \underset{m = 1^{32}0^{32}}{L_2} \equiv 1^{32}$$</p><img src="/2018/05/20/Cryptography-Week-2-Problem-Set/5.png" width="700">$$\begin{align*}        c' &= F(k, IV \oplus m_1) \\        &= F(k, F(k, c_0) \oplus c_0 \oplus c_0) \\        &= F(k, F(k, c_0) \oplus c_0 \oplus F(k, c_0)) \\        &= F(k, c_0)\end{align*}$$<p>Therefore:<br>$$    c_1 = c'_0$$</p><img src="/2018/05/20/Cryptography-Week-2-Problem-Set/6.png" width="700"><img src="/2018/05/20/Cryptography-Week-2-Problem-Set/7.png" width="700"><img src="/2018/05/20/Cryptography-Week-2-Problem-Set/8.png" width="700"><img src="/2018/05/20/Cryptography-Week-2-Problem-Set/9.png" width="700">]]></content>
    
    <summary type="html">
    
      &lt;img src=&quot;/2018/05/20/Cryptography-Week-2-Problem-Set/1.png&quot; width=&quot;700&quot;&gt;
    
    </summary>
    
    
      <category term="cryptography" scheme="https://cuixiaochen.com/tags/cryptography/"/>
    
  </entry>
  
  <entry>
    <title>Redis 学习资料</title>
    <link href="https://cuixiaochen.com/2018/04/30/redis-study-references/"/>
    <id>https://cuixiaochen.com/2018/04/30/redis-study-references/</id>
    <published>2018-04-30T15:11:04.000Z</published>
    <updated>2018-05-10T15:01:28.517Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Repos"><a href="#Repos" class="headerlink" title="Repos"></a>Repos</h1><ul><li><a href="https://github.com/antirez/redis" target="_blank" rel="noopener">redis</a></li><li><a href="https://github.com/huangz1990/redis-3.0-annotated" target="_blank" rel="noopener">redis-3.0-annotated</a><br>带有详细注释的 Redis 3.0 代码<a id="more"></a></li></ul><h1 id="Books"><a href="#Books" class="headerlink" title="Books"></a>Books</h1><ul><li><a href="https://book.douban.com/subject/25900156/" target="_blank" rel="noopener">Redis 设计与实现</a><br>通俗易懂，深入浅出</li><li><a href="https://book.douban.com/subject/26612779/" target="_blank" rel="noopener">Redis 实战</a><br>入门书籍，价值不大</li></ul><h1 id="Blogs"><a href="#Blogs" class="headerlink" title="Blogs"></a>Blogs</h1><h2 id="Redlock"><a href="#Redlock" class="headerlink" title="Redlock"></a>Redlock</h2><ul><li><a href="https://redis.io/topics/distlock" target="_blank" rel="noopener">Distributed locks with Redis</a></li><li><a href="https://martin.kleppmann.com/2016/02/08/how-to-do-distributed-locking.html" target="_blank" rel="noopener">How to do distributed locking - Martin Kleppmann</a></li><li><a href="http://antirez.com/news/101" target="_blank" rel="noopener">Is Redlock safe? - antirez</a></li><li><a href="http://zhangtielei.com/posts/blog-redlock-reasoning.html" target="_blank" rel="noopener">基于 Redis 的分布式锁到底安全吗（上）？</a></li><li><a href="http://zhangtielei.com/posts/blog-redlock-reasoning-part2.html" target="_blank" rel="noopener">基于 Redis 的分布式锁到底安全吗（下）？</a></li></ul><h2 id="RESP-REdis-Serialization-Protocol"><a href="#RESP-REdis-Serialization-Protocol" class="headerlink" title="RESP(REdis Serialization Protocol)"></a>RESP(REdis Serialization Protocol)</h2><ul><li><a href="https://redis.io/topics/protocol" target="_blank" rel="noopener">Redis Protocol specification</a></li><li><a href="https://www.compose.com/articles/how-to-talk-raw-redis/" target="_blank" rel="noopener">How to talk raw Redis</a></li></ul><h2 id="Persistence"><a href="#Persistence" class="headerlink" title="Persistence"></a>Persistence</h2><ul><li><a href="http://oldblog.antirez.com/post/redis-persistence-demystified.html" target="_blank" rel="noopener">Redis persistence demystified</a></li></ul><h2 id="RDB"><a href="#RDB" class="headerlink" title="RDB"></a>RDB</h2><ul><li><a href="https://github.com/sripathikrishnan/redis-rdb-tools/wiki/Redis-RDB-Dump-File-Format" target="_blank" rel="noopener">Redis RDB Dump File Format</a></li><li><a href="https://github.com/sripathikrishnan/redis-rdb-tools/blob/master/docs/RDB_Version_History.textile" target="_blank" rel="noopener">Redis RDB Version History</a></li></ul><h1 id="Maillists"><a href="#Maillists" class="headerlink" title="Maillists"></a>Maillists</h1><ul><li><a href="https://groups.google.com/forum/#!forum/redis-db" target="_blank" rel="noopener">Redis DB</a></li><li><a href="https://groups.google.com/forum/#!forum/redis-dev" target="_blank" rel="noopener">redis-dev</a></li></ul><h1 id="Twitter"><a href="#Twitter" class="headerlink" title="Twitter"></a>Twitter</h1><ul><li><a href="https://twitter.com/redisfeed" target="_blank" rel="noopener">@redisfeed</a></li><li><a href="https://twitter.com/antirez" target="_blank" rel="noopener">@antirez</a></li></ul><p>待补充</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Repos&quot;&gt;&lt;a href=&quot;#Repos&quot; class=&quot;headerlink&quot; title=&quot;Repos&quot;&gt;&lt;/a&gt;Repos&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/antirez/redis&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;redis&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/huangz1990/redis-3.0-annotated&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;redis-3.0-annotated&lt;/a&gt;&lt;br&gt;带有详细注释的 Redis 3.0 代码
    
    </summary>
    
    
      <category term="redis" scheme="https://cuixiaochen.com/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>操作系统学习笔记：第一章习题及解答</title>
    <link href="https://cuixiaochen.com/2018/04/17/operation-system-study-notes-2/"/>
    <id>https://cuixiaochen.com/2018/04/17/operation-system-study-notes-2/</id>
    <published>2018-04-17T14:00:19.000Z</published>
    <updated>2018-04-30T15:42:06.866Z</updated>
    
    <content type="html"><![CDATA[<h1 id="习题"><a href="#习题" class="headerlink" title="习题"></a>习题</h1><ol><li><p>什么是 multiprogramming？</p><p>在第二代操作系统（如 7094 机）上，若当前作业因等待磁带或其他 I/O 操作而暂停时，CPU 就只能简单地原地踏步直至该 I/O 完成。在很多情况下，I/O 操作等待的时间通常占到 80% ~ 90%, 所以要通过 multiprogramming 的方式来减少 CPU 资源的浪费。</p><p>具体方案就是将内存分成多个部分，每个部分存放不同的作业（如下图所示），当一个作业等待 I/O 操作完成时，另一个作业可以使用 CPU。如果内存中可以同时存放足够多的作业，则 CPU 利用率可以接近 100%。（注意：在内存中同时驻留多个作业需要特殊的硬件来对其进行保护，以避免作业对信息被窃取或受到攻击。）</p><img src="/2018/04/17/operation-system-study-notes-2/multi-programmed-system.jpg"><a id="more"></a></li><li><p>什么是 SPOOLing ？你是否认为将来的个人计算机会把 SPOOLing 作为标准功能？</p><p>SPOOLing(Simultaneous Peripheral operation on line), 指任何时刻当一个作业运行结束时，操作系统就能将一个新作业从磁盘读出，装进空出来的内存区域运行。（该技术同时也用于输出）</p><p>具体答案还有待后续章节的学习，但我认为 SPOOLing 不会在将来被当作个人计算机的标准功能。因为其需要等一个作业运行结束，意味着用户在操作计算机时会经常遇到计算机卡住的情况，从而带给用户不好的体验（相比于后来出现的分时系统）。</p></li><li><p>在早期计算机中，每个字节的读写直接由 CPU 处理（即没有 <a href="https://www.techopedia.com/definition/2767/direct-memory-access-dma" target="_blank" rel="noopener">DMA</a> ）。对于多道程序而言这种组织方式有什么含义？</p><p>使用多道程序的主要目的是使计算机在等待 I/O 操作时可以完成别的工作。如果没有 DMA ，I/O 操作将会完全占用 CPU 。因此，这种方式不利于对于 CPU 的充分利用。</p></li><li><p>系列计算机的思想在 20 世纪 60 年代由 IBM 引入进 System/360 大型机。现在这种思想已经消亡了还是继续活跃着？</p><p>依然存在。例如 Intel 生产的 Pentium I，II，III 和 4 仅仅在价格、速度等属性上有所不同，但它们的体系结构都是兼容的。</p></li><li><p>缓慢采用 GUI 的一个原因是支持它的硬件的成本（高昂）。为了支持 25 行 80 列字符的单色文本屏幕应该需要多少视颊 RAM? 对于 1024x768 像素 24 位色彩位图需要多少视频 RAM? 在 1980 年 ($5/KB) 这些 RAM 的成本是多少？现在它的成本是多少？</p><p>25*80=2000bytes≈2kb, 1024*768*3=2359296bytes≈2359kb。在 1980 年，它们将会分布耗费 $10 和 $11520。现在的 RAM 的成本小于 $1/MB。</p></li><li><p>在建立一个操作系统时有几个设计目的，例如资源利用、及时性、健壮性等。请列举两个可能互相矛盾的设计目的。</p><p>资源利用与缓存。资源利用要求尽量满足当前所运行程序的资源要求，而缓存则要求缓存频繁访问的数据。所以当前进程可能会占用过多的资源导致缓存空间不足。</p></li><li><p>下面的哪一条指令只能在内核态中使用？<br>a) 禁止所有的中断。<br>b) 读日期 - 时间时钟。<br>c) 设置日期 - 时间时钟。<br>d) 改变存储器映像。</p><p>a,c,d</p></li><li><p>考虑一个有两个 CPU 的系统，并且每一个 CPU 有两个线程（超线程）。假设有三个程序 P0，P1，P2，分別以运行时间 5ms，10ms，20ms 开始。运行这些程序需要多少时间？假设这三个程序都是 100% 限于 CPU，在运行时无阻塞，并且一旦设定就不改变 CPU。</p><p>运行这些程序所需的时间取决于这些程序以怎样的组合被分配到 CPU 上，一共有以下 4 种情况：</p><ol><li>(P0,P1) and P2 =&gt; (5ms + 10ms) and 20ms =&gt; 20ms</li><li>(P0,P2) and P1 =&gt; (5ms + 20ms) and 10ms =&gt; 25ms</li><li>(P1,P2) and P0 =&gt; (10ms + 20ms) and 50ms =&gt; 30ms</li><li>(P0,P1,P2) =&gt; (5ms + 10ms + 20ms) =&gt; 35m</li></ol></li><li><p>一台计算机有一个四级流水线，每一级都花费相同的时间执行其工作，即 1ns。这台机器每秒可执行多少条指令？</p><p>1s / (1ns/ 条） = $10 ^ 9$ 条</p></li><li><p>假设一个计算机系统有高速缓存、内存 (RAM) 以及磁盘，操作系统用虚拟内存。读取缓存中的一个词需要 2ns，RAM 需要 10ns，磁盘需要 10ms。如果缓存的命中率是 95%，内存的是（缓存失效时）99%，读取一个词的平均时间是多少？</p><p>$2ns\times95\%+10ns\times(1-95\%)\times99\%+10ms\times(1-95\%)(1-99\%) = 5002.395ns$</p></li><li><p>一位校对人员注意到在一部将要出版的操作系统教科书手稿中有一个多次出现的拼写错误。这本书大致有 700 页。每页 50 行，一行 80 个字符。若把文稿用电子扫描，那么，主副本进入图 1-9 中的每个存储系统的层次要花费多少时间？对于内存储方式，考虑所给定的存取时间是每次一个字符，对于磁盘设备，假定存取时间是每次一个 1024 字符的盘块，而对于磁带，假设给定开始时间后的存取时间和磁盘存取时间相同。</p><img src="/2018/04/17/operation-system-study-notes-2/caching-stuff.jpg"><p>答：原稿包含 80*50*700 = 2800000 字符。如果这些字符放在寄存器中，cpu 访问它们需要 2.8ms（在这里我们假设这些字符可以一次性放入寄存器），在 Cache 中需要 5.6ms，在内存中需要 28ms。整本书大约有 2700 个 1024 字节的数据块，因此从磁盘读取它们大约需要 27 秒，从磁带读取大约需要 2 分钟 7 秒。（根据书中的数据计算）</p></li><li><p>在用户程序进行一个系统调用，以读写磁盘文件时，该程序提供指示说明了所需要的文件，一个指向数据缓冲区的指针以及计数。然后，控制权转给操作系统，它调用相关的驱动程序。假设驱动程序启动磁盘并且直到中断发生才终止。在从磁盘读的情况下，很明显，调用者会被阻塞（因为文件中没有数据）。在向磁盘写时会发生什么情况？需要把调用者阻塞一直等到磁盘传送完成为止吗？</p><p>这道题暂时无法解答</p></li><li><p>什么是陷阱指令？在操作系统中解释它的用途。</p><p>TRAP 指令将处理器的执行模式从用户态切换到内核态，它使用户可以调用操作系统内核中的函数。</p></li><li><p>陷阱和中断的主要差别是什么？</p><p>陷阱是由程序造成的，而且与程序同步；中断由外部事件和时钟造成。</p></li><li><p>在分时系统中为什么需要进程表？在只有一个进程存在的个人计算机系统中，该进程控制整个机器直到进程结束，这种机器也需要进程表吗？</p><p>进程表的作用是在进程暂时被挂起时保存进程打开的所有文件的当前读取位置。单进程操作系统中不需要进程表，因为进程不会被挂起。</p></li><li><p>说明有没有理由要在一个非空的目录中安装一个文件系统？如果要这样做，如何做？</p><p>这道题暂时无法解答</p></li><li><p>在一个操作系统中系统调用的目的是什么？</p><p>进入内核，调用操作系统服务</p></li><li><p>对于下列系统调用 ，给出引起失败的条件：fork、exec 以及 unlink。</p><p>fork: fork 失败的主要原因有两个：(a) 系统中已经有了太多的进程（进程表中没有空闲的槽）；(b) 该实际用户 ID 的进程总数超过了系统限制（在 POSIX.1 中，CHILD_MAX 代表了每个实际用户 ID 的最大进程数，可在运行时通过调用 <code>long sysconf(int _SC_CHLID_MAX)</code> 取得）<br>exec: 给定的 pathname/filename 不合法，这里的不合法有两种情况：(a) 不存在，(b) 存在但不是一个可用的 shell 脚本<br>unlink: 待我详细阅读相关资料后再给出解答</p></li><li><p>在 <code>count = write(fd, buffer, nbytes);</code> 调用中，能在 count 中而不是 nbytes 中返回值吗？如果能，为什么？</p><p>能，因为当 write 调用失败时返回 -1，否则返回实际写入当字节数</p></li><li><p>有一个文件，其文件描述符是 fd，内含下列字节序列：3，1，4，1，5，9，2，6，5，3，5。<br>有如下系统调用：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">lseek(fd, <span class="number">3</span>, SEEK_SET);</span><br><span class="line">read(fd, &amp;buffer, <span class="number">4</span>);</span><br></pre></td></tr></table></figure><p>其中 lseek 调用寻找文件中的第 3 个字节。在读操作完成之后，buffer 中的内容是什么？</p><p>1, 5, 9, 2</p></li><li><p>假设一个 10MB 的文件在磁盘连续扇区的同一个轨道上（轨道号：50）。磁盘的磁头臂此时位于第 100 号轨道。要想从磁盘上找回这个文件，需要多长时间？ 假设磁头臂从一个柱面移动到下一个柱面需要 1ms，当文件的开始部分存储在的扇区旋转到磁头下需要 5ms，并且读的速率是 100MB/s。</p><p>155ms（在 SSD 普及的今天，这道题基本没有意义）</p></li><li><p>块特殊文件和字符特殊文件的基本差别是什么？</p><p>块特殊文件 (block special file) 提供对设备带缓冲的访问<br>字符特殊文件 (character special file) 提供对设备不带缓冲的访问</p></li><li><p>如下图所示，库调用被称为 read，而系统调用自身也被称为 read，这两者都有相问的名字是正常的吗？ 如果不是，哪一个更重要？</p><p>是正常的，因为系统调用实际上并没有名称。当库函数 read 陷入内核时，它将系统调用的编号放在操作系统所期望的地方（寄存器或堆栈）中，然后由内核根据编号执行相应的系统调用，整个过程中不会用到任何名称。而对于库调用来说名称是很重要的，因为我们写的程序中需要使用这个名称。</p><img src="/2018/04/17/operation-system-study-notes-2/system.jpg.png"></li><li><p>在分布式系统中，C-S 模式很普遍。这种模式能用在单个计算机的系统中吗？</p><p>可以</p><p>未完待续</p></li></ol><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://www.techopedia.com/definition/2767/direct-memory-access-dma" target="_blank" rel="noopener">What is Direct Memory Access (DMA)? - Definition from Techopedia</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;习题&quot;&gt;&lt;a href=&quot;#习题&quot; class=&quot;headerlink&quot; title=&quot;习题&quot;&gt;&lt;/a&gt;习题&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;什么是 multiprogramming？&lt;/p&gt;
&lt;p&gt;在第二代操作系统（如 7094 机）上，若当前作业因等待磁带或其他 I/O 操作而暂停时，CPU 就只能简单地原地踏步直至该 I/O 完成。在很多情况下，I/O 操作等待的时间通常占到 80% ~ 90%, 所以要通过 multiprogramming 的方式来减少 CPU 资源的浪费。&lt;/p&gt;
&lt;p&gt;具体方案就是将内存分成多个部分，每个部分存放不同的作业（如下图所示），当一个作业等待 I/O 操作完成时，另一个作业可以使用 CPU。如果内存中可以同时存放足够多的作业，则 CPU 利用率可以接近 100%。（注意：在内存中同时驻留多个作业需要特殊的硬件来对其进行保护，以避免作业对信息被窃取或受到攻击。）&lt;/p&gt;
&lt;img src=&quot;/2018/04/17/operation-system-study-notes-2/multi-programmed-system.jpg&quot;&gt;
    
    </summary>
    
    
      <category term="operating system" scheme="https://cuixiaochen.com/tags/operating-system/"/>
    
  </entry>
  
  <entry>
    <title>Arrays in bash</title>
    <link href="https://cuixiaochen.com/2018/03/30/array-in-shell-script/"/>
    <id>https://cuixiaochen.com/2018/03/30/array-in-shell-script/</id>
    <published>2018-03-30T15:11:33.000Z</published>
    <updated>2018-05-20T15:29:42.793Z</updated>
    
    <content type="html"><![CDATA[<p>Shell script 中的 array 一直是一个比较模糊的概念，在网上找到的相关文章也讲得不太详细。本文参考了多篇文章，以尽量详尽地讲解一下 bash 中的 array。<br><a id="more"></a></p><h1 id="Array-基础语法"><a href="#Array-基础语法" class="headerlink" title="Array 基础语法"></a>Array 基础语法</h1><h2 id="Array-初始化"><a href="#Array-初始化" class="headerlink" title="Array 初始化"></a>Array 初始化</h2><p>Array 有多种方式进行初始化：</p><ul><li>使用 <code>array_name[xx]</code></li><li>使用显式声明语句 <code>declare -a array_name</code></li><li><code>array_name=( XXX YYY ZZZ ... )</code> （括号旁边的空格不是必需的）</li><li><code>array_name=([xx]=XXX [yy]=YYY ...)</code></li></ul><p>下面我们通过代码演示一下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># array_name[xx]</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Array members need not be consecutive or contiguous.</span></span><br><span class="line"><span class="comment"># Some members of the array can be left uninitialized.</span></span><br><span class="line"><span class="comment"># Gaps in the array are okay.</span></span><br><span class="line"></span><br><span class="line">array_1[11]=24</span><br><span class="line">array_1[15]=37</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;array_1[11]&#125;</span> <span class="comment"># output 24</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;array_1[12]&#125;</span> <span class="comment"># output blank (null variable)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># declare -a array_name</span></span><br><span class="line"><span class="built_in">declare</span> -a array2</span><br><span class="line"></span><br><span class="line"><span class="comment"># array_name=( XXX YYY ZZZ ... )</span></span><br><span class="line">array_3=( zero one two three four )</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;array_3[0]&#125;</span> <span class="comment"># output zero</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># array_name=([xx]=XXX [yy]=YYY ...)</span></span><br><span class="line">array_4=([17]=seventeen [24]=twenty-four)</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;array_4[17]&#125;</span> <span class="comment"># output seventeen</span></span><br></pre></td></tr></table></figure><p>下面举一个实际应用中初始化 array 的例子：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">base64_charset=( &#123;A..Z&#125; &#123;a..z&#125; &#123;0..9&#125; + / = )</span><br><span class="line">               <span class="comment">#  Using extended brace expansion</span></span><br><span class="line">               <span class="comment">#+ to initialize the elements of the array.</span></span><br><span class="line">               <span class="comment">#  Excerpted from vladz's "base64.sh" script</span></span><br><span class="line">               <span class="comment">#+ in the "Contributed Scripts" appendix.</span></span><br></pre></td></tr></table></figure><p>可以看到，用 <code>array=( element1 element2 ... elementN )</code> 这种方式初始化 array 非常方便</p><h2 id="输出整个-array"><a href="#输出整个-array" class="headerlink" title="输出整个 array"></a>输出整个 array</h2><ul><li><code>echo ${array_name[@]}</code></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">base64_charset=(&#123;A..Z&#125; &#123;a..z&#125; &#123;0..9&#125; + / =)</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;base64_charset[@]&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># output:</span></span><br><span class="line"><span class="comment">#A B C D E F G H I J K L M N O P Q R S T U V W X Y Z a b c d e f g h i j k l m n o p q r s t u v w x y z 0 1 2 3 4 5 6 7 8 9 + / =</span></span><br></pre></td></tr></table></figure><h2 id="取-array-中元素的值"><a href="#取-array-中元素的值" class="headerlink" title="取 array 中元素的值"></a>取 array 中元素的值</h2><p>在中括号中加数字或字符串索引可以取到 array 中某一元素的值：<code>${array_name[xx]}</code></p><p>正常情况下，不要放置字符串索引，除非你精通 array</p><ul><li>当索引为数字时，会返回相应的值（在那个索引的值被指定的情况下）</li><li>当索引为字符串且不是变量名时，无论那个字符串是什么，都会返回 array 中最后一个字符串索引对应元素的值</li><li>当索引为变量名时，其会被展开（不需要加 <code>$</code> 符号）</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">array_0=([far]=faraway [he]=hello [24]=kube [no]=love [17]=docker)</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;array_0[17]&#125;</span>     <span class="comment"># docker</span></span><br><span class="line">                        <span class="comment"># Output corresponding value if key exist</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;array_0[far]&#125;</span>    <span class="comment"># love</span></span><br><span class="line">                        <span class="comment"># Output last element's value whose key is string</span></span><br><span class="line"></span><br><span class="line">far=<span class="string">"hi"</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;array_0[far]&#125;</span>   <span class="comment"># love</span></span><br><span class="line"></span><br><span class="line">far=24</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;array_0[far]&#125;</span>   <span class="comment"># kube</span></span><br></pre></td></tr></table></figure><h2 id="Array-中的元素索引"><a href="#Array-中的元素索引" class="headerlink" title="Array 中的元素索引"></a>Array 中的元素索引</h2><ul><li>整数索引从 0 开始</li><li>元素的整数索引不必是连续的，即元素之间可以有 gap</li></ul><h2 id="取-array-长度"><a href="#取-array-长度" class="headerlink" title="取 array 长度"></a>取 array 长度</h2><ul><li><code>${#array_name}</code> array 中第一个元素的长度</li><li><code>${#array_name[*]}</code> array 的长度</li><li><code>${#array_name[@]}</code> array 的长度</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">array=( zero one two three four five )</span><br><span class="line"><span class="comment"># Element 0   1   2    3     4    5</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;#array&#125;</span>         <span class="comment">#  4</span></span><br><span class="line">                       <span class="comment">#  Length of first element of array.</span></span><br><span class="line">                       <span class="comment">#  (Alternate notation)</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;#array[*]&#125;</span>      <span class="comment">#  6</span></span><br><span class="line">                       <span class="comment">#  Number of elements in array.</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;#array[@]&#125;</span>      <span class="comment">#  6</span></span><br><span class="line">                       <span class="comment">#  Number of elements in array.</span></span><br></pre></td></tr></table></figure><h2 id="取-array-中某一元素的长度"><a href="#取-array-中某一元素的长度" class="headerlink" title="取 array 中某一元素的长度"></a>取 array 中某一元素的长度</h2><p><code>${#array_name[n]}</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">array=( zero one two three four five )</span><br><span class="line"><span class="comment"># Element 0   1   2    3     4    5</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;#array[0]&#125;</span>      <span class="comment">#  4</span></span><br><span class="line">                       <span class="comment">#  Length of first element of array.</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;#array[1]&#125;</span>      <span class="comment">#  3</span></span><br><span class="line">                       <span class="comment">#  Length of second element of array.</span></span><br><span class="line">                       <span class="comment">#  Arrays in Bash have zero-based indexing.</span></span><br></pre></td></tr></table></figure><h2 id="对-array-进行切片"><a href="#对-array-进行切片" class="headerlink" title="对 array 进行切片"></a>对 array 进行切片</h2><p>Array 对切片和 python 中的切片很像：</p><ul><li><code>${array_name[@]:start}</code> 从 start 开始的所有元素（包含 start ）</li><li><code>${array_name[@]:start:end}</code> 从 start 到 end 的所有元素（包含 start，不包含 end ）</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">arrayZ=( one two three four five five )</span><br><span class="line"></span><br><span class="line">echo $&#123;arrayZ[@]:0&#125;     # one two three four five five</span><br><span class="line">#                ^        All elements.</span><br><span class="line"></span><br><span class="line">echo $&#123;arrayZ[@]:1&#125;     # two three four five five</span><br><span class="line">#                ^        All elements following element[0].</span><br><span class="line"></span><br><span class="line">echo $&#123;arrayZ[@]:1:2&#125;   # two three</span><br><span class="line">#                  ^      Only the two elements after element[0].</span><br><span class="line"></span><br><span class="line">echo $&#123;arrayZ[@]:1:4&#125;   # two three four five</span><br></pre></td></tr></table></figure><h2 id="一切皆是-array"><a href="#一切皆是-array" class="headerlink" title="一切皆是 array"></a>一切皆是 array</h2><p>需要注意的是，即使我们并没有按照前面提到的几种方法将一个变量声明为 array, 我们仍然可以对其进行 array 相关的操作。<br>换句话来说：<strong>所有变量都可以被看作 array</strong> 。</p><p>比如说，下面这个例子中的变量 <code>string</code> 其实也是一个 array（包含一个元素）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">string=abcABC123ABCabc</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;string[@]&#125;</span>               <span class="comment"># abcABC123ABCabc</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;string[*]&#125;</span>               <span class="comment"># abcABC123ABCabc</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;string[0]&#125;</span>               <span class="comment"># abcABC123ABCabc</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;string[1]&#125;</span>               <span class="comment"># No output!</span></span><br><span class="line">                                <span class="comment"># Why?</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;#string[@]&#125;</span>              <span class="comment"># 1</span></span><br><span class="line">                                <span class="comment"># One element in the array.</span></span><br><span class="line">                                <span class="comment"># The string itself.</span></span><br></pre></td></tr></table></figure><h1 id="Array-进阶语法"><a href="#Array-进阶语法" class="headerlink" title="Array 进阶语法"></a>Array 进阶语法</h1><h2 id="对-array-中的第一个元素切片"><a href="#对-array-中的第一个元素切片" class="headerlink" title="对 array 中的第一个元素切片"></a>对 array 中的第一个元素切片</h2><ul><li><code>$(array_name:start)</code> 返回 array_name[0][start:] （包含 start ）</li><li><code>$(array_name:start:end)</code> 返回 array_name[0][start:end] （包含 start ，包含 end ）</li></ul><p>示例：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">array=( zero one two three four five )</span><br><span class="line"><span class="comment"># Element 0   1   2    3     4    5</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;array[0]&#125;</span>       <span class="comment">#  zero</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;array:0&#125;</span>        <span class="comment">#  zero</span></span><br><span class="line">                       <span class="comment">#  Parameter expansion of first element,</span></span><br><span class="line">                       <span class="comment">#+ starting at position # 0 (1st character).</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;array:1&#125;</span>        <span class="comment">#  ero</span></span><br><span class="line">                       <span class="comment">#  Parameter expansion of first element,</span></span><br><span class="line">                       <span class="comment">#+ starting at position # 1 (2nd character).</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;array:1:2&#125;</span>      <span class="comment">#  er</span></span><br><span class="line">                       <span class="comment">#  Parameter expansion of first element,</span></span><br><span class="line">                       <span class="comment">#+ starting at position # 1 (2nd character).</span></span><br></pre></td></tr></table></figure></p><h2 id="切除子字符串"><a href="#切除子字符串" class="headerlink" title="切除子字符串"></a>切除子字符串</h2><p><code>${array_name[scope][flag][pattern]}</code></p><p>scope:</p><ul><li><code>@</code> | <code>*</code>   表示对全部元素进行操作</li><li>n 表示对只第 n 个元素进行操作</li></ul><p>flag:</p><ul><li><code>#</code> 最短匹配，从头部开始</li><li><code>##</code> 最长匹配，从头部开始</li><li><code>%</code> 最短匹配，从尾部开始</li><li><code>%%</code> 最长匹配，从尾部开始</li></ul><p>pattern: 通配符，可以使用 * 匹配任意长度字符串</p><ul><li><code>${array_name[@]#pattern}</code> 移除 pattern 的最短匹配（从字符串头部开始匹配）</li><li><code>${array_name[@]##pattern}</code> 移除 pattern 的最长匹配（从字符串头部开始匹配）</li><li><code>${array_name[@]*pattern}</code> 移除 pattern 的最短匹配（从字符串尾部开始匹配）</li><li><code>${array_name[@]**pattern}</code> 移除 pattern 的最长匹配（从字符串尾部开始匹配）</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Substring Removal</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Removes shortest match from front of string(s).</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;arrayZ[@]#f*r&#125;</span>   <span class="comment"># one two three five five</span></span><br><span class="line"><span class="comment">#               ^       # Applied to all elements of the array.</span></span><br><span class="line">                        <span class="comment"># Matches "four" and removes it.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Longest match from front of string(s)</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;arrayZ[@]##t*e&#125;</span>  <span class="comment"># one two four five five</span></span><br><span class="line"><span class="comment">#               ^^      # Applied to all elements of the array.</span></span><br><span class="line">                        <span class="comment"># Matches "three" and removes it.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Shortest match from back of string(s)</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;arrayZ[@]%h*e&#125;</span>   <span class="comment"># one two t four five five</span></span><br><span class="line"><span class="comment">#               ^       # Applied to all elements of the array.</span></span><br><span class="line">                        <span class="comment"># Matches "hree" and removes it.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Longest match from back of string(s)</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;arrayZ[@]%%t*e&#125;</span>  <span class="comment"># one two four five five</span></span><br><span class="line"><span class="comment">#               ^^      # Applied to all elements of the array.</span></span><br><span class="line">                        <span class="comment"># Matches "three" and removes it.</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;arrayZ[1]#t*&#125;</span>    <span class="comment"># one wo three five five</span></span><br><span class="line">                        <span class="comment"># Applied to second element of the array.</span></span><br><span class="line">                        <span class="comment"># Matches "t" and removes it.</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;arrayZ[1]##t*&#125;</span>    <span class="comment"># one three five five</span></span><br><span class="line">                        <span class="comment"># Applied to second element of the array.</span></span><br><span class="line">                        <span class="comment"># Matches "two" and removes it.</span></span><br></pre></td></tr></table></figure><h1 id="Array-演进史"><a href="#Array-演进史" class="headerlink" title="Array 演进史"></a>Array 演进史</h1><p>在 bash-2.0 中，bash 增加了对于用整数作为数组索引的支持，且索引部分可以使用算术表达式：</p><blockquote><p>The shell now supports integer-indexed arrays of unlimited length, with a new compound assignment syntax and changes to the appropriate builtin commands (declare/typeset, read, readonly, etc.).  The array index may be an arithmetic expression.</p><p>– <a href="http://tiswww.case.edu/php/chet/bash/NEWS" target="_blank" rel="noopener">bash release note</a></p></blockquote><p>未完待续</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="http://tiswww.case.edu/php/chet/bash/NEWS" target="_blank" rel="noopener">bash release note</a></li><li><a href="http://tldp.org/LDP/abs/html/arrays.html" target="_blank" rel="noopener">Arrays</a></li><li><a href="https://peniwize.wordpress.com/2011/04/09/how-to-read-all-lines-of-a-file-into-a-bash-array/" target="_blank" rel="noopener">How to read all lines of a file into a bash array | Peniwize’s Weblog</a></li><li><a href="http://mywiki.wooledge.org/BashGuide/Arrays" target="_blank" rel="noopener">http://mywiki.wooledge.org/BashGuide/Arrays</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Shell script 中的 array 一直是一个比较模糊的概念，在网上找到的相关文章也讲得不太详细。本文参考了多篇文章，以尽量详尽地讲解一下 bash 中的 array。&lt;br&gt;
    
    </summary>
    
    
      <category term="shell script" scheme="https://cuixiaochen.com/tags/shell-script/"/>
    
  </entry>
  
  <entry>
    <title>Cryptography Week 1 - Programming Assignment</title>
    <link href="https://cuixiaochen.com/2018/03/26/Cryptography-Week1-Programming-Assignment/"/>
    <id>https://cuixiaochen.com/2018/03/26/Cryptography-Week1-Programming-Assignment/</id>
    <published>2018-03-26T15:07:34.000Z</published>
    <updated>2018-06-29T12:26:30.742Z</updated>
    
    <content type="html"><![CDATA[<p>在 Week1 的学习中，我们已经知道 Many Time Pad 是不安全的，现在我们来动手破解它。<br><a id="more"></a></p><h1 id="简要证明"><a href="#简要证明" class="headerlink" title="简要证明"></a>简要证明</h1><img src="/2018/03/26/Cryptography-Week1-Programming-Assignment/02-stream-v2-annotated.001.jpeg"><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><img src="/2018/03/26/Cryptography-Week1-Programming-Assignment/topic.png"><h1 id="破解思路"><a href="#破解思路" class="headerlink" title="破解思路"></a>破解思路</h1><p>我们首先定义合法字符集为{英文字母，[,], [.], [“], [ ]}<br>由于所有密文都是用同一密钥加密的，所以对于密文 $c_1$, $c_2$:<br>$$\begin{align*}        result =& c_1 \oplus c_2 \oplus x (x 为合法字符）\\        result =& m_1 \oplus key \oplus m_2 \oplus key \oplus x (m_1, m_2, k 均为密文 c_1, c_2 以及密钥串 key 在同一位置的值）\\\end{align*}$$<br>排除意外碰撞，当且仅当 $m_1 \equiv x$ 或 $m_2 \equiv x$ 时，result 为合法字符</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> binascii</span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</span><br><span class="line"><span class="keyword">import</span> string</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ciphertexts_hex = [</span><br><span class="line">    <span class="string">"315c4eeaa8b5f8aaf9174145bf43e1784b8fa00dc71d885a804e5ee9fa40b16349c146fb778cdf2d3aff021dfff5b403b510d0d0455468aeb98622b137dae857553ccd8883a7bc37520e06e515d22c954eba5025b8cc57ee59418ce7dc6bc41556bdb36bbca3e8774301fbcaa3b83b220809560987815f65286764703de0f3d524400a19b159610b11ef3e"</span>,</span><br><span class="line">    ...</span><br><span class="line">    <span class="string">"32510ba9babebbbefd001547a810e67149caee11d945cd7fc81a05e9f85aac650e9052ba6a8cd8257bf14d13e6f0a803b54fde9e77472dbff89d71b57bddef121336cb85ccb8f3315f4b52e301d16e9f52f904"</span>,</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Transfer cipher to bytes</span></span><br><span class="line">ciphertexts = list(map(binascii.unhexlify, ciphertexts_hex))</span><br><span class="line"></span><br><span class="line"><span class="comment"># Get character range</span></span><br><span class="line">valid_character_range = (string.ascii_letters + <span class="string">".,: "</span>).encode(<span class="string">"ascii"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Target cipher is the cipher we want to crack</span></span><br><span class="line">target_cipher = ciphertexts[<span class="number">-1</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># dic_list stores the probability distribution of letters at each position</span></span><br><span class="line">dic_list = [defaultdict(int) <span class="keyword">for</span> _ <span class="keyword">in</span> range(len(target_cipher))]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> xored_cipher <span class="keyword">in</span> ciphertexts[:<span class="number">10</span>]:</span><br><span class="line">    <span class="keyword">for</span> character_index, character <span class="keyword">in</span> enumerate(target_cipher):</span><br><span class="line">        <span class="keyword">if</span> character_index &lt; len(xored_cipher):</span><br><span class="line">            xored_character = xored_cipher[character_index]</span><br><span class="line">            <span class="comment"># Assume each letter in turn</span></span><br><span class="line">            <span class="keyword">for</span> word <span class="keyword">in</span> valid_character_range:</span><br><span class="line">                <span class="keyword">if</span> character_index &lt; len(xored_cipher):</span><br><span class="line">                    <span class="comment"># Derivation:</span></span><br><span class="line">                    <span class="comment"># xor = key ^ m1 ^ key ^ m2 ^ word</span></span><br><span class="line">                    <span class="comment">#     = m1 ^ m2 ^ word</span></span><br><span class="line">                    <span class="comment"># If m1 == word:</span></span><br><span class="line">                    <span class="comment"># then xor = m2 (xor is valid)</span></span><br><span class="line">                    <span class="comment"># or m2 == word:</span></span><br><span class="line">                    <span class="comment"># then xor = m1 (xor is valid)</span></span><br><span class="line">                    xor = character ^ xored_character ^ word</span><br><span class="line">                    <span class="keyword">if</span> xor <span class="keyword">in</span> valid_character_range:</span><br><span class="line">                        m2 = chr(xor)</span><br><span class="line">                        key = xored_character ^ xor</span><br><span class="line">                        m1 = chr(character ^ key)</span><br><span class="line">                        dic_list[character_index][m2] += <span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">print(<span class="string">''</span>.join([max(dic, key=dic.get) <span class="keyword">for</span> dic <span class="keyword">in</span> dic_list]))</span><br></pre></td></tr></table></figure><p>运行得到的值为：<br><code>The sicuet cesiage is: Wrzn using a stream cipher, tever use the key more than onye</code></p><p>可以看到，并没有得到准确的原文，这里有两个因素：</p><ul><li>合法字符集的范围可能不准确</li><li>我们并不能判断 $c_1 \equiv c_2 \equiv x$ 为 $m_1$ 还是 $m_2$</li></ul><p>dic_list 中的每个 dict 都表示了相应位置每个合法字符的可能性，通过列出每个 dict 出现频次最高的 3 个字符，我们可以还原出原文：</p><blockquote><p>The secret message is: when using a stream cipher, never use the key more than once</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在 Week1 的学习中，我们已经知道 Many Time Pad 是不安全的，现在我们来动手破解它。&lt;br&gt;
    
    </summary>
    
    
      <category term="cryptography" scheme="https://cuixiaochen.com/tags/cryptography/"/>
    
  </entry>
  
  <entry>
    <title>42065</title>
    <link href="https://cuixiaochen.com/2018/03/11/42065/"/>
    <id>https://cuixiaochen.com/2018/03/11/42065/</id>
    <published>2018-03-11T15:19:43.000Z</published>
    <updated>2018-04-30T15:42:06.807Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>Lego Technic 42065 RC Tracked Racer 是乐高遥控系列中最迷你的一款，由 370 块积木组成，国内售价在 500 到 800 不等。此车虽然小，可是“麻雀虽小，五脏俱全”，附带有一个遥控模组以及两个电机，被广大乐高玩家称为“买电机送积木”。同时，由于动力比十分高，42065 的机动性也是乐高科技系列里最强的。</p><h1 id="开箱"><a href="#开箱" class="headerlink" title="开箱"></a>开箱</h1><img src="/2018/03/11/42065/IMG_0602.jpg"><a id="more"></a><h1 id="成品展示"><a href="#成品展示" class="headerlink" title="成品展示"></a>成品展示</h1><p>42065 的拼装较为简单，一到两个小时就可以搞定。</p><img src="/2018/03/11/42065/IMG_0610.jpg"><img src="/2018/03/11/42065/IMG_0611.jpg"><h1 id="改装"><a href="#改装" class="headerlink" title="改装"></a>改装</h1><p>Youtube 上的一个玩家改装得很好，非常有参考价值：</p><div class="video-container"><iframe src="//www.youtube.com/embed/sFjIwYFcyA8" frameborder="0" allowfullscreen></iframe></div><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>42065 总体上来讲挺好玩，唯一的缺点就是由于结构非常精简，不太牢固，可以参考上面的改装视频进行加固。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h1&gt;&lt;p&gt;Lego Technic 42065 RC Tracked Racer 是乐高遥控系列中最迷你的一款，由 370 块积木组成，国内售价在 500 到 800 不等。此车虽然小，可是“麻雀虽小，五脏俱全”，附带有一个遥控模组以及两个电机，被广大乐高玩家称为“买电机送积木”。同时，由于动力比十分高，42065 的机动性也是乐高科技系列里最强的。&lt;/p&gt;
&lt;h1 id=&quot;开箱&quot;&gt;&lt;a href=&quot;#开箱&quot; class=&quot;headerlink&quot; title=&quot;开箱&quot;&gt;&lt;/a&gt;开箱&lt;/h1&gt;&lt;img src=&quot;/2018/03/11/42065/IMG_0602.jpg&quot;&gt;
    
    </summary>
    
    
      <category term="lego" scheme="https://cuixiaochen.com/tags/lego/"/>
    
  </entry>
  
  <entry>
    <title>Django 操作数据库时的 9 条小提示（译）</title>
    <link href="https://cuixiaochen.com/2018/02/01/9-Django-Tips-for-Working-with-Databases-Translate/"/>
    <id>https://cuixiaochen.com/2018/02/01/9-Django-Tips-for-Working-with-Databases-Translate/</id>
    <published>2018-02-01T08:06:39.000Z</published>
    <updated>2018-04-30T15:42:06.847Z</updated>
    
    <content type="html"><![CDATA[<p>本文翻译自 <a href="https://medium.com/" target="_blank" rel="noopener">Medium</a> 上的 <a href="https://medium.com/@hakibenita/9-django-tips-for-working-with-databases-beba787ed7d3" target="_blank" rel="noopener">9 Django Tips for Working with Databases</a>, 原作者 <a href="https://medium.com/@hakibenita" target="_blank" rel="noopener">Haki Benita</a>。</p><a id="more"></a><h1 id="用-filter-做聚合-aggregation-操作"><a href="#用-filter-做聚合-aggregation-操作" class="headerlink" title="用 filter 做聚合 (aggregation) 操作"></a>用 filter 做聚合 (aggregation) 操作</h1><p>在 Django 2.0 之前，如果我们想获取诸如用户总数或者已激活的用户总数等信息，通常需要诉诸于使用 <a href="https://docs.djangoproject.com/en/2.0/ref/models/conditional-expressions/" target="_blank" rel="noopener">condition 表达式</a>:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.contrib.auth.models <span class="keyword">import</span> User</span><br><span class="line"><span class="keyword">from</span> django.db.models <span class="keyword">import</span> (</span><br><span class="line">    Count,</span><br><span class="line">    Sum,</span><br><span class="line">    Case,</span><br><span class="line">    When,</span><br><span class="line">    Value,</span><br><span class="line">    IntegerField,</span><br><span class="line">)</span><br><span class="line">User.objects.aggregate(</span><br><span class="line">    total_users=Count(<span class="string">'id'</span>),</span><br><span class="line">    total_active_users=Sum(Case(</span><br><span class="line">        When(is_active=<span class="keyword">True</span>, then=Value(<span class="number">1</span>)),</span><br><span class="line">        default=Value(<span class="number">0</span>),</span><br><span class="line">        output_field=IntegerField(),</span><br><span class="line">    )),</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>在 Django 2.0 中加入的在聚合函数中使用 filter 参数简化了这一操作：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.contrib.auth.models <span class="keyword">import</span> User</span><br><span class="line"><span class="keyword">from</span> django.db.models <span class="keyword">import</span> Count, F</span><br><span class="line">User.objects.aggregate(</span><br><span class="line">    total_users=Count(<span class="string">'id'</span>),</span><br><span class="line">    total_active_users=Count(<span class="string">'id'</span>, filter=F(<span class="string">'is_active'</span>)),</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>假设我们正在使用 PostgerSQL, 上面两条查询对应的 SQL 语句是：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">    <span class="keyword">COUNT</span>(<span class="keyword">id</span>) <span class="keyword">AS</span> total_users,</span><br><span class="line">    <span class="keyword">SUM</span>(<span class="keyword">CASE</span> <span class="keyword">WHEN</span> is_active <span class="keyword">THEN</span> <span class="number">1</span> <span class="keyword">ELSE</span> <span class="number">0</span> <span class="keyword">END</span>) <span class="keyword">AS</span> total_active_users</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">    auth_users;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">    <span class="keyword">COUNT</span>(<span class="keyword">id</span>) <span class="keyword">AS</span> total_users,</span><br><span class="line">    <span class="keyword">COUNT</span>(<span class="keyword">id</span>) FILTER (<span class="keyword">WHERE</span> is_active) <span class="keyword">AS</span> total_active_users</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">    auth_users;</span><br></pre></td></tr></table></figure><p>第二条查询使用了 FILTER(WHERE…) 语句。</p><h1 id="QuerySet-的结果作为-namedtuples-返回"><a href="#QuerySet-的结果作为-namedtuples-返回" class="headerlink" title="QuerySet 的结果作为 namedtuples 返回"></a>QuerySet 的结果作为 namedtuples 返回</h1><p>在 Django 2.0 中 <a href="https://docs.djangoproject.com/en/2.0/ref/models/querysets/#django.db.models.query.QuerySet.values_list" target="_blank" rel="noopener">values_list 可以接收一个叫做 named 的参数</a>。当 named 为 True 的时候，values_list 将会返回一个由 namedtuple 组成的列表：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&gt; user.objects.values_list(</span><br><span class="line">    <span class="string">'first_name'</span>,</span><br><span class="line">    <span class="string">'last_name'</span>,</span><br><span class="line">)[<span class="number">0</span>]</span><br><span class="line">(‘Haki’, ‘Benita’)</span><br><span class="line">&gt; user_names = User.objects.values_list(</span><br><span class="line">    <span class="string">'first_name'</span>,</span><br><span class="line">    <span class="string">'last_name'</span>,</span><br><span class="line">    named=<span class="keyword">True</span>,</span><br><span class="line">)</span><br><span class="line">&gt; user_names[<span class="number">0</span>]</span><br><span class="line">Row(first_name=<span class="string">'Haki'</span>, last_name=<span class="string">'Benita'</span>)</span><br><span class="line">&gt; user_names[<span class="number">0</span>].first_name</span><br><span class="line"><span class="string">'Haki'</span></span><br><span class="line">&gt; user_names[<span class="number">0</span>].last_name</span><br><span class="line"><span class="string">'Benita'</span></span><br></pre></td></tr></table></figure><h1 id="自定义函数"><a href="#自定义函数" class="headerlink" title="自定义函数"></a>自定义函数</h1><p>Django ORM 非常实用而且功能丰富，但是它不可能满足所有的数据库。幸运的是 ORM 允许我们用自定义函数来对它进行扩展。</p><p>假设我们有一个 Report model，其中包含一个 duration 字段。如果要获取平均延期时间的话：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.db.models <span class="keyword">import</span> Avg</span><br><span class="line">Report.objects.aggregate(avg_duration=Avg(‘duration’))</span><br><span class="line">&gt; &#123;<span class="string">'avg_duration'</span>: datetime.timedelta(<span class="number">0</span>, <span class="number">0</span>, <span class="number">55432</span>)&#125;</span><br></pre></td></tr></table></figure><p>但是当我们想要获取标准差的时候：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.db.models <span class="keyword">import</span> Avg, StdDev</span><br><span class="line">Report.objects.aggregate(</span><br><span class="line">    avg_duration=Avg(<span class="string">'duration'</span>),</span><br><span class="line">    std_duration=StdDev(<span class="string">'duration'</span>),</span><br><span class="line">)</span><br><span class="line">ProgrammingError: function stddev_pop(interval) does <span class="keyword">not</span> exist</span><br><span class="line">LINE <span class="number">1</span>: SELECT STDDEV_POP(<span class="string">"report"</span>.<span class="string">"duration"</span>) AS <span class="string">"std_dura...</span></span><br><span class="line"><span class="string">               ^</span></span><br><span class="line"><span class="string">HINT:  No function matches the given name and argument types. You might need to add explicit type casts.</span></span><br></pre></td></tr></table></figure><p>这就出现了问题，因为 PostgreSQL 不支持对于 interval type 的 stddev 操作。我们得先把 interval 转换成 number, 然后再对其进行 <code>STDDEV_POP</code> 操作。</p><p>解决方法之一就是在 duration 上执行 epoch 操作：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">SELECT</span><br><span class="line">    AVG(duration),</span><br><span class="line">    STDDEV_POP(EXTRACT(EPOCH FROM duration))</span><br><span class="line">FROM</span><br><span class="line">    report;</span><br><span class="line">      avg       |    stddev_pop</span><br><span class="line">----------------+------------------</span><br><span class="line"> 00:00:00.55432 | 1.06310113695549</span><br><span class="line">(1 row)</span><br></pre></td></tr></table></figure><p>通过<a href="https://docs.djangoproject.com/en/2.0/ref/models/expressions/#func-expressions" target="_blank" rel="noopener">自定义函数</a>，我们可以在 Django 中进行这个操作：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># common/db.py</span></span><br><span class="line"><span class="keyword">from</span> django.db.models <span class="keyword">import</span> Func</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Epoch</span><span class="params">(Func)</span>:</span></span><br><span class="line">   function = <span class="string">'EXTRACT'</span></span><br><span class="line">   template = <span class="string">"%(function)s('epoch' from %(expressions)s)"</span></span><br></pre></td></tr></table></figure><p>然后使用这个新的函数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">from django.db.models import Avg, StdDev, F</span><br><span class="line">from common.db import Epoch</span><br><span class="line">Report.objects.aggregate(</span><br><span class="line">    avg_duration=Avg(&apos;duration&apos;),</span><br><span class="line">    std_duration=StdDev(Epoch(F(&apos;duration&apos;))),</span><br><span class="line">)</span><br><span class="line">&#123;&apos;avg_duration&apos;: datetime.timedelta(0, 0, 55432),</span><br><span class="line"> &apos;std_duration&apos;: 1.06310113695549&#125;</span><br></pre></td></tr></table></figure><p>注意我们在 Epoch 中使用了 <a href="https://docs.djangoproject.com/en/2.0/ref/models/expressions/#f-expressions" target="_blank" rel="noopener">F 表达式</a></p><p>『译者注』可能某些读者没接触过 PostgreSQL, 我在这里贴出一些链接，帮助大家了解一下本段中涉及到的 PostgreSQL 关键字：</p><ul><li><a href="http://www.postgresqltutorial.com/postgresql-interval/" target="_blank" rel="noopener">interval data type</a></li><li><a href="https://w3resource.com/PostgreSQL/extract-function.php" target="_blank" rel="noopener">EXTRACT</a></li><li><a href="https://www.cloudera.com/documentation/enterprise/5-3-x/topics/impala_stddev.html" target="_blank" rel="noopener">STDDEV_POP</a></li></ul><h1 id="语句超时"><a href="#语句超时" class="headerlink" title="语句超时"></a>语句超时</h1><p>这可能是本文给出的最重要、最简洁的建议。在编写应用时出错是难以避免的事情，我们无法预料并处理所有的边界情况 (edge case)，所以<strong>我们必须设置边界</strong>。</p><p>不同于那些非阻塞的 app 服务器（如 Tornado, asyncio 或 Node），Django 使用阻塞式的工作进程。这意味着<strong>如果一个用户执行了一项长耗时操作，则在这项操作完成前，工作进程会一直阻塞且无法被其他用户使用</strong>。</p><p>虽然没人会在生产环境中使用单个工作进程，我们仍然应该确保单个查询不会占用过多的时间。</p><p>在大多数 Django 应用中数据库查询都会占用很多时间，所以<strong><a href="https://www.postgresql.org/docs/9.6/static/runtime-config-client.html#GUC-STATEMENT-TIMEOUT" target="_blank" rel="noopener">为 SQL 查询设置超时</a> 是一个很好的习惯</strong>。</p><p>我们通常会在 wsgi.py 中做全局超时设置：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># wsgi.py</span></span><br><span class="line"><span class="keyword">from</span> django.db.backends.signals <span class="keyword">import</span> connection_created</span><br><span class="line"><span class="keyword">from</span> django.dispatch <span class="keyword">import</span> receiver</span><br><span class="line"><span class="meta">@receiver(connection_created)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">setup_postgres</span><span class="params">(connection, **kwargs)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> connection.vendor != <span class="string">'postgresql'</span>:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Timeout statements after 30 seconds.</span></span><br><span class="line">    <span class="keyword">with</span> connection.cursor() <span class="keyword">as</span> cursor:</span><br><span class="line">        cursor.execute(<span class="string">"""</span></span><br><span class="line"><span class="string">            SET statement_timeout TO 30000;</span></span><br><span class="line"><span class="string">        """</span>)</span><br></pre></td></tr></table></figure><p>这样做使得超时设置只会影响工作进程，而不会影响统计查询与 cronjob。</p><p>同时，我们应该使用<a href="https://docs.djangoproject.com/en/2.0/ref/databases/#persistent-connections" target="_blank" rel="noopener">持久化数据库连接</a>，使得我们不需要为每一个请求付出建立数据库连接的代价。</p><p>边注：另一项非常耗时的操作是网络通讯，所以我们也应该在调用远程服务时设置超时：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">import requests</span><br><span class="line">response = requests.get(</span><br><span class="line">    &apos;https://api.slow-as-hell.com&apos;,</span><br><span class="line">    timeout=3000,</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h1 id="限制"><a href="#限制" class="headerlink" title="限制"></a>限制</h1><p>这一条建议同样与设置边界有关。有时候我们会希望用户输入一些数据，然后我们呈现出一份图表给他们。这一类的视图通常会在生产环境中产生一些奇怪的行为。</p><p>用户希望导出所有订单的情况并不罕见，当前标签页“卡住”时打开另一个标签页进行尝试也是很常见的情形。</p><p>这就是我们为什么要对查询做限制。</p><p>我们来试着做一个查询，返回不超过 100 行：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 一个错误的示范</span></span><br><span class="line">data = list(Sale.objects.all())[:<span class="number">100</span>]</span><br></pre></td></tr></table></figure><p>这是一个错误的示范，程序将会把海量订单载入内存，然后截取前 100 项。</p><p>我们尝试改进一下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">data = Sale.objects.all()[:<span class="number">100</span>]</span><br></pre></td></tr></table></figure><p>这个语句比之前的要好一些，Django 将会在查询中使用 limit 来获取前 100 行。</p><p>在这里遇到了另一个问题：当用户查询所有订单时，程序仍然会只返回 100 行数据。</p><p>我们继续改进之前的程序，当订单总数大于 100 时，抛出一个异常：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">LIMIT = <span class="number">100</span></span><br><span class="line"><span class="keyword">if</span> Sales.objects.count() &gt; LIMIT:</span><br><span class="line">    <span class="keyword">raise</span> ExceededLimit(LIMIT)</span><br><span class="line"><span class="keyword">return</span> Sale.objects.all()[:LIMIT]</span><br></pre></td></tr></table></figure><p>这个片段能正常工作，但现在程序将会进行两次查询。</p><p>我们继续改进：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">LIMIT = <span class="number">100</span></span><br><span class="line">data = Sale.objects.all()[:(LIMIT + <span class="number">1</span>)]</span><br><span class="line"><span class="keyword">if</span> len(data) &gt; LIMIT:</span><br><span class="line">    <span class="keyword">raise</span> ExceededLimit(LIMIT)</span><br><span class="line"><span class="keyword">return</span> data</span><br></pre></td></tr></table></figure><p>我们现在获取前 101 行而不是 100 行，如果第 101 行数据存在，则我们知道数据总数大于 100。</p><p>LIMIT + 1 这个技巧很多时候非常使用。</p><h1 id="Select-for-update-…-of"><a href="#Select-for-update-…-of" class="headerlink" title="Select for update … of"></a>Select for update … of</h1><p>我们将会用一个 bug 来开始这一小节。这个 bug 发生在半夜，根源是数据库锁，最后造成了查询超时。</p><p>一个常用的<a href="https://medium.com/p/bullet-proofing-django-models-c080739be4e" target="_blank" rel="noopener">进行交易的模式</a> 如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.db <span class="keyword">import</span> transaction <span class="keyword">as</span> db_transaction</span><br><span class="line">...</span><br><span class="line"><span class="keyword">with</span> db_transaction.atomic():</span><br><span class="line">  transaction = (</span><br><span class="line">        Transaction.objects</span><br><span class="line">        .select_related(</span><br><span class="line">            <span class="string">'user'</span>,</span><br><span class="line">            <span class="string">'product'</span>,</span><br><span class="line">            <span class="string">'product__category'</span>,</span><br><span class="line">        )</span><br><span class="line">        .select_for_update()</span><br><span class="line">        .get(uid=uid)</span><br><span class="line">  )</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><p>涉及到交易的操作通常包含 user 和 product，所以我们通常使用 <a href="https://docs.djangoproject.com/en/2.0/ref/models/querysets/#select-related" target="_blank" rel="noopener">select_related</a> 来进行强制关联，减少查询次数。</p><p>到目前为止，问题还没有显现出来。</p><p>我们有一些 <a href="https://en.wikipedia.org/wiki/Extract,_transform,_load" target="_blank" rel="noopener">ETL</a> 程序在半夜进行，维护 user 表和 product 表。这些 ETL 程序会执行更新和插入操作，所以他们也会请求获取锁。</p><p>所以问题的根源在于：当 <a href="https://docs.djangoproject.com/en/2.0/ref/models/querysets/#select-for-update" target="_blank" rel="noopener">select_for_update</a> 和 select_related 一起使用的时候，Django 将会对本次查询涉及到对所有表加锁。</p><p>我们的程序尝试同时在 transaction, user, product 和 category 表上加锁，当 ETL 程序在半夜将后三个表加锁后，交易便失败了。</p><p>为了解决这个问题，<a href="https://docs.djangoproject.com/en/2.0/releases/2.0/#database-backend-api" target="_blank" rel="noopener">Django 2.0 中为 select_for_update 引入了一个新的参数</a>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.db <span class="keyword">import</span> transaction <span class="keyword">as</span> db_transaction</span><br><span class="line">...</span><br><span class="line"><span class="keyword">with</span> db_transaction.atomic():</span><br><span class="line">  transaction = (</span><br><span class="line">        Transaction.objects</span><br><span class="line">        .select_related(</span><br><span class="line">            <span class="string">'user'</span>,</span><br><span class="line">            <span class="string">'product'</span>,</span><br><span class="line">            <span class="string">'product__category'</span>,</span><br><span class="line">        )</span><br><span class="line">        .select_for_update(</span><br><span class="line">            of=(<span class="string">'self'</span>,)</span><br><span class="line">        )</span><br><span class="line">        .get(uid=uid)</span><br><span class="line">  )</span><br><span class="line">  ...</span><br></pre></td></tr></table></figure><p>select_for_update 现在加入了 <code>of</code> 参数，使用 <code>of</code> 可以让我们明确指定对哪个表加锁。<code>self</code> 是一个特殊的关键字，表示我们想对当前 model 对应的表加锁（在我们的例子中，是 transaction）。</p><p>到目前为止，这个功能只可用于 PostgreSQL 和 Oracle。</p><h1 id="外键索引"><a href="#外键索引" class="headerlink" title="外键索引"></a>外键索引</h1><p>当创建一个 model 时，Django 将会在外键上自动创建一个 B-Tree 索引，B-Tree 索引会增加程序的负担，而且有时候索引并不是必要的。</p><p>一个经典的例子就是下面这用来存储成员关系的关系 model:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">class Membership(Model):</span><br><span class="line">    group = ForeignKey(Group)</span><br><span class="line">    user = ForeignKey(User)</span><br></pre></td></tr></table></figure><p>Django 将会隐式地为上面这个 model 创建两个索引，一个在 group 字段上，另一个在 user 字段上。</p><p>在关系 model 中，一个常用的模式是为两个字段添加唯一性约束。在我们的例子中表现为一个用户只能在同一个组中出现一次：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class Membership(Model):</span><br><span class="line">    group = ForeignKey(Group)</span><br><span class="line">    user = ForeignKey(User)</span><br><span class="line">    class Meta:</span><br><span class="line">        unique_together = (</span><br><span class="line">           &apos;group&apos;,</span><br><span class="line">           &apos;user&apos;,</span><br><span class="line">        )</span><br></pre></td></tr></table></figure><p>unique_together 也会创建一个索引，作用于这两个字段。所以我们这个 model 最终拥有 3 个 fiele 和 2 个索引。在很多情况下（取决于业务需求），我们可以解除掉外键索引，只保留唯一性约束创建的索引：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class Membership(Model):</span><br><span class="line">    group = ForeignKey(Group)</span><br><span class="line">    user = ForeignKey(User)</span><br><span class="line">    class Meta:</span><br><span class="line">        unique_together = (</span><br><span class="line">           &apos;group&apos;,</span><br><span class="line">           &apos;user&apos;,</span><br><span class="line">        )</span><br></pre></td></tr></table></figure><p>移除多余的索引可以加快插入和更新操作的速度，同时减轻了数据库的负载。</p><h1 id="复合索引中列的顺序"><a href="#复合索引中列的顺序" class="headerlink" title="复合索引中列的顺序"></a>复合索引中列的顺序</h1><p>在多个列上构建的索引被称为<strong>复合索引</strong>。在 B-Tree 复合索引中，第一列用树结构构建索引，第二列在第一层叶子节点的基础上构建树结构，然后依此类推。</p><p><strong>所以索引中列的顺序意义重大。</strong></p><p>在这个例子中，我们首先会构建一个树存储所有的组，然后对于每一个组构建一个树，存储它的所有组员。</p><p>对于 B-Tree 树来说，我们的经验法则是让第二层索引尽可能的小。换句话来说，基数更高的列（即不同的值更多）应该被放在前面。</p><p>在这个例子中，我们可以作出一个合理的假设，即认为用户比组多。所以将用户列放在前面可以使第二级索引为组而构建，使索引更小。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class Membership(Model):</span><br><span class="line">    group = ForeignKey(Group, db_index=False)</span><br><span class="line">    user = ForeignKey(User, db_index=False)</span><br><span class="line">    class Meta:</span><br><span class="line">        unique_together = (</span><br><span class="line">            &apos;user&apos;,</span><br><span class="line">            &apos;group&apos;,</span><br><span class="line">        )</span><br></pre></td></tr></table></figure><p>这只是一个经验之谈，所以你应该对此持保留态度。最终的索引需要根据具体的使用情景来进行优化。这一小节的重点是告诉你要<strong>注意隐式索引，注意复合索引中列顺序的重大意义。</strong></p><h1 id="BRIN-索引"><a href="#BRIN-索引" class="headerlink" title="BRIN 索引"></a>BRIN 索引</h1><p>B-Tree 的结构就像一棵树一样。当随机访问数据表时，查询单个值当代价是树的高度加 1。所以对于一致性约束和（某些）范围查询来说，B-Tree 索引是比较完美的。</p><p><strong>B-Tree 的缺点在于它的大小，它有时候会变得非常大。</strong></p><p>[PostgreSQL 提供了其它多种索引，供我们用于不同的场景。][other indexes of PostgreSQL]</p><p>Django 1.11 加入了一个新的 Meta 选项来控制索引，使得我们有机会去探索其它类型的索引。</p><p>PostgreSQL 提供了一种特别使用的索引：BRIN(Block Range Index)。在某些场景下 BRIN 索引会比 B-Tree 索引更加高效。</p><p>来看一下[官方文档][BRIN] 中的说明：</p><blockquote><p>BRIN 主要针对于相对于其在表中的位置有自然关联性的列。</p></blockquote><p>接下来我们简单介绍一下 BRIN 的内部机制。BRIN 将会基于表中的相邻数据块创建一个小型索引。这个索引占用的空间很小，它只能告诉你给定值<strong>肯定不在某个区域</strong>或者<strong>可能在某个区域中</strong>（区域被索引的情况下）。</p><p>我们用一个简单的实例来演示一下 BRIN。</p><p>假设一列中有如下值：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1, 2, 3, 4, 5, 6, 7, 8, 9</span><br></pre></td></tr></table></figure><p>然后把相邻的 3 个放在一个区域内：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[1–3], [4–6], [7–9]</span><br></pre></td></tr></table></figure><p>我们利用这个索引来搜索 5:</p><ul><li><code>[1-3]</code> 肯定不在这个区域</li><li><code>[4-6]</code> 可能在这个区域</li><li><code>[7-9]</code> 肯定不在这个区域</li></ul><p>利用这个索引我们把搜索范围缩小到了区域 4-6。</p><p>我们再看一下另一个例子，在这个例子中列中的值是乱序的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[2,9,5], [1,4,7], [3,8,6]</span><br></pre></td></tr></table></figure><p>然后用每个区域中的最大值和最小值生成索引：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[2–9], [1–7], [3–8]</span><br></pre></td></tr></table></figure><p>接下来尝试去查找 5:</p><ul><li><code>[2-9]</code> 可能在这个区域中</li><li><code>[1-7]</code> 可能在这个区域中</li><li><code>[3-8]</code> 可能在这个区域中</li></ul><p>这个索引不仅没有缩小搜索的范围，同时还导致我们需要将索引和整个表的值一起读入。所以它起不到任何有效作用。</p><p>让我们再回到文档：</p><blockquote><p>… 与其在表中的物理位置有自然关联的列</p></blockquote><p>这是使用 BRIN 索引的关键。想要发挥出 BRIN 索引的作用，列中的值从整体来看应该有序或有聚集性地排列在硬盘上。</p><p>回到 Django 中，<a href="https://docs.djangoproject.com/en/2.0/ref/models/fields/#datefield" target="_blank" rel="noopener">auto_now_add</a> 列就是一个非常契合这个条件的场景，我们经常需要对 auto_now_add 列建立索引，同时它也基本上是自然有序地被存放在硬盘上。</p><p>如下面这个 model:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">class SomeModel(Model):</span><br><span class="line">    created = DatetimeField(</span><br><span class="line">        auto_now_add=True,</span><br><span class="line">    )</span><br></pre></td></tr></table></figure><p>当一行数据被创建时，Django 将会自动在 created 列插入当前时间。由于 created 列也经常被用在查询条件中，所以我们经常需要在上面建立索引：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">from django.contrib.postgres.indexes import BrinIndex</span><br><span class="line">class SomeModel(Model):</span><br><span class="line">    created = DatetimeField(</span><br><span class="line">        auto_now_add=True,</span><br><span class="line">    )</span><br><span class="line">    class Meta:</span><br><span class="line">        indexes = (</span><br><span class="line">            BrinIndex(fields=[&apos;created&apos;]),</span><br><span class="line">        )</span><br></pre></td></tr></table></figure><p>为了给大家一个直观的感受，我在表中创建列 200 万行数据，然后建立不同的索引：</p><ul><li>B-Tree 索引：37 MB</li><li>BRIN 索引：49 KB</li></ul><p>两者所占空间相差了 700 多倍。</p><p>虽然说在创建索引时，硬盘空间消耗并不是我们考虑的唯一因素。但是一般而言，我们可以在 Django 1.11 中使用新的索引支持，使查询更轻量，更快。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文翻译自 &lt;a href=&quot;https://medium.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Medium&lt;/a&gt; 上的 &lt;a href=&quot;https://medium.com/@hakibenita/9-django-tips-for-working-with-databases-beba787ed7d3&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;9 Django Tips for Working with Databases&lt;/a&gt;, 原作者 &lt;a href=&quot;https://medium.com/@hakibenita&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Haki Benita&lt;/a&gt;。&lt;/p&gt;
    
    </summary>
    
    
      <category term="python" scheme="https://cuixiaochen.com/tags/python/"/>
    
      <category term="django" scheme="https://cuixiaochen.com/tags/django/"/>
    
      <category term="orm" scheme="https://cuixiaochen.com/tags/orm/"/>
    
  </entry>
  
  <entry>
    <title>Cryptography Week 1 - Problem Set</title>
    <link href="https://cuixiaochen.com/2018/01/27/Cryptography-Week1-%E8%AF%BE%E5%90%8E%E4%B9%A0%E9%A2%98/"/>
    <id>https://cuixiaochen.com/2018/01/27/Cryptography-Week1-课后习题/</id>
    <published>2018-01-27T06:17:56.000Z</published>
    <updated>2018-05-20T13:55:30.097Z</updated>
    
    <content type="html"><![CDATA[<img src="/2018/01/27/Cryptography-Week1-课后习题/1.png" width="700"><p>先压缩再加密，效率更高。压缩的过程相当于丢掉了一部分冗余信息，使得总信息量减少，从而减少了加密的工作量。</p><a id="more"></a><img src="/2018/01/27/Cryptography-Week1-课后习题/2.png"><ul><li>选项 1 不对，因为 G’(k) 可预测 (predictable)</li><li>选项 2 正确</li><li>选项 3 正确</li><li>选项 4 正确（相当于对 G(k) 取非）</li><li>选项 5 不正确，最后一位可预测</li><li>选项 6 不正确，因为其总是生成相同的 key</li></ul><img src="/2018/01/27/Cryptography-Week1-课后习题/3.png"><p>计算过程：</p>$$\begin{align*}Adv_{PRG}(A,G) &= \left|\underset{r\leftarrow{\{0,1\}^n}}{Pr(A(r)}=1) - \underset{k\leftarrow{K}}{Pr(A(G'(k))}=1)\right|\\&= \left|\underset{r\leftarrow{\{0,1\}^n}}{Pr(LSB(r)}=1) - \underset{k\leftarrow{K}}{Pr(LSB(G(k_1)\wedge G(k_2))}=1)\right|\\&= \left|\frac{1}{2} - \frac{1}{4}\right|\\&= \frac{1}{4}\end{align*}$$<img src="/2018/01/27/Cryptography-Week1-课后习题/4.png"><img src="/2018/01/27/Cryptography-Week1-课后习题/5.png"><p>此题应该选第一个选项</p><img src="/2018/01/27/Cryptography-Week1-课后习题/6.png"><img src="/2018/01/27/Cryptography-Week1-课后习题/7.png"><img src="/2018/01/27/Cryptography-Week1-课后习题/9.png"><img src="/2018/01/27/Cryptography-Week1-课后习题/10.png">]]></content>
    
    <summary type="html">
    
      &lt;img src=&quot;/2018/01/27/Cryptography-Week1-课后习题/1.png&quot; width=&quot;700&quot;&gt;
&lt;p&gt;先压缩再加密，效率更高。压缩的过程相当于丢掉了一部分冗余信息，使得总信息量减少，从而减少了加密的工作量。&lt;/p&gt;
    
    </summary>
    
    
      <category term="cryptography" scheme="https://cuixiaochen.com/tags/cryptography/"/>
    
  </entry>
  
  <entry>
    <title>操作系统学习笔记：基本概念</title>
    <link href="https://cuixiaochen.com/2018/01/07/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/"/>
    <id>https://cuixiaochen.com/2018/01/07/操作系统学习笔记（一）：基本概念/</id>
    <published>2018-01-07T07:29:54.000Z</published>
    <updated>2018-04-30T15:42:06.869Z</updated>
    
    <content type="html"><![CDATA[<p>几个基本概念的简要介绍</p><h1 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h1><ul><li>进程 (process) 本质上是正在执行的一个程序。</li><li>与每个进程相关的是进程的地址空间 (address space), 这是从某个最小值的存储位置（通常是零）到某个最大值存储位置的列表。在这个地址空间中，进程可以进行读写。<a id="more"></a></li><li>在许多操作系统中，与一个进程有关的所有信息，除了该进程自身地址空间的内容以外，均存放在操作系统的一张表中，称为进程表 (process table)，进程表是数组（或链表）结构，当前存在的每个进程都要占用其中一项。</li><li>系统管理器授权每个进程使用一个给定的 UID 标识 (User IDentification)。每个被启动的进程都有一个启动该进程的用户 UID。子进程拥有与父进程一样的 UID。</li></ul><h1 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h1><ul><li>操作系统的一项主要功能是隐藏磁盘和其他 I/O 设备的细节特性，并提供给程序员一个良好的、清晰的独立于设备的抽象文件模型。</li><li>在读写文件之前，首先要打开文件，检查其访问权限。若权限许可，系统将返回一个小整数，称作文件描述符 (file descriptor)，供后续操作使用。若禁止访问，系统则返回一个错误码。</li><li>在 UNIX 中的另一个重要概念是安装文件系统。如下图，在 mount 调用之前，根文件系统在硬盘上，而第二个文件系统在 CD-ROM 上，它们是分离和无关的。<img src="/2018/01/07/操作系统学习笔记（一）：基本概念/mount.png"></li><li>在 UNIX 中，另一个重要的概念是特殊文件 (special file)。提供特殊文件是为了使 I/O 设备看起来像文件一般。按照惯例，特殊文件保存在 /dev 目录中。有两类特殊文件：<ul><li>块特殊文件：<br>由可随机存取的块组成的设备，如磁盘等。比如打开一个块特殊文件，然后读第 4 块，程序可以直接访问设备的第 4 块而不必考虑存放该文件的文件系统结构。</li><li>字符特殊文件：<br>打印机、调制解调器等接收或输出字符流的设备。</li></ul></li><li>管道 (pipe) 是是一种虚文件，可连接两个进程。（关于管道的详细介绍，参见我的另一篇博客：<a href="http://oldblog.cuixiaochen.com/2017/09/28/Hello-named-pipe/" target="_blank" rel="noopener">Hello, named pipe</a>）</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;几个基本概念的简要介绍&lt;/p&gt;
&lt;h1 id=&quot;进程&quot;&gt;&lt;a href=&quot;#进程&quot; class=&quot;headerlink&quot; title=&quot;进程&quot;&gt;&lt;/a&gt;进程&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;进程 (process) 本质上是正在执行的一个程序。&lt;/li&gt;
&lt;li&gt;与每个进程相关的是进程的地址空间 (address space), 这是从某个最小值的存储位置（通常是零）到某个最大值存储位置的列表。在这个地址空间中，进程可以进行读写。
    
    </summary>
    
    
      <category term="operating system" scheme="https://cuixiaochen.com/tags/operating-system/"/>
    
  </entry>
  
</feed>
