<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>XiaochenCui&#39;s Blog</title>
  
  <subtitle>相隔天堑 却不觉遥远</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://cuixiaochen.com/"/>
  <updated>2018-10-07T12:18:11.240Z</updated>
  <id>https://cuixiaochen.com/</id>
  
  <author>
    <name>Xiaochen Cui</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>一些关于 Diffie-Hellman 的 paper</title>
    <link href="https://cuixiaochen.com/2018/09/22/some-pater-about-dh/"/>
    <id>https://cuixiaochen.com/2018/09/22/some-pater-about-dh/</id>
    <published>2018-09-22T11:34:00.000Z</published>
    <updated>2018-10-07T12:18:11.240Z</updated>
    
    <content type="html"><![CDATA[<ul><li><a href="http://crypto.stanford.edu/~dabo/papers/DDH.pdf" target="_blank" rel="noopener">The Decision Diffie-Hellman problem. D. Boneh, ANTS 3, 1998</a><br>Talks about various assumptions related to Diffie Hellman.</li><li><a href="https://eprint.iacr.org/2001/085.pdf" target="_blank" rel="noopener">Universal Hash Proofs and a Paradigm for Adaptive Chosen Ciphertext Secure Public-Key Encryption. R. Cramer and V. Shoup, Eurocrypt 2002</a></li><li><a href="http://crypto.stanford.edu/~dabo/papers/ccaibejour.pdf" target="_blank" rel="noopener">Chosen-Ciphertext Security from Identity-Based Encryption. D. Boneh, R. Canetti, S. Halevi, and J. Katz, SICOMP 2007</a><br>Uses a general mechanism called Identity Based Encryption which very surprisingly it turns out to actually gives us chosen ciphertext security almost for free.</li><li><a href="https://eprint.iacr.org/2008/067.pdf" target="_blank" rel="noopener">The Twin Diffie-Hellman Problem and Applications David Cash1 Eike Kiltz2 Victor Shoup3</a></li><li><a href="https://www.iacr.org/archive/crypto2010/62230313/62230313.pdf" target="_blank" rel="noopener">Efficient Chosen-Ciphertext Security via Extractable Hash Proofs Hoeteck Wee?</a><br>Gives a very general framework for building chosen ciphertext ciphertext secure systems using extractable hash proofs.</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://crypto.stanford.edu/~dabo/papers/DDH.pdf&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;The Decision Diffie-Hellman problem. D. Bo
      
    
    </summary>
    
    
      <category term="cryptography" scheme="https://cuixiaochen.com/tags/cryptography/"/>
    
  </entry>
  
  <entry>
    <title>一些关于 RSA 的 paper</title>
    <link href="https://cuixiaochen.com/2018/09/15/some-pater-about-rsa/"/>
    <id>https://cuixiaochen.com/2018/09/15/some-pater-about-rsa/</id>
    <published>2018-09-15T09:02:29.000Z</published>
    <updated>2018-10-07T12:18:11.241Z</updated>
    
    <content type="html"><![CDATA[<ul><li><a href="https://www.shoup.net/papers/expo.pdf" target="_blank" rel="noopener">Who chosen ciphertext security matters, V.Shoup, 1998</a><br>A nice paper by Victor Shoup that talks about why chosen cipher text security is so important in the public key settings. So if the Bleichenbacher attack wasn’t convincing enough, there are many other attacks like this that are possible if you don’t use a chosen cipher-text secure system.</li><li><a href="https://crypto.stanford.edu/~dabo/papers/RSA-survey.pdf" target="_blank" rel="noopener">Twenty years of attacks on the RSA cryptosystem, D.Boneh, Notices of the AMS, 1999</a></li><li><a href="https://www.shoup.net/papers/oaep.pdf" target="_blank" rel="noopener">OAEP reconsidered, V.Shoup, Crypto 2001</a></li><li><a href="https://infoscience.epfl.ch/record/164539/files/NPDF-32.pdf" target="_blank" rel="noopener">Key length, A.Lenstra, 2004</a><br>A nice paper by Arjen Lenstra that discusses how you should choose key lengths for your public key systems, and even for your symmetric key systems.</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://www.shoup.net/papers/expo.pdf&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Who chosen ciphertext security matters, V.Shoup, 199
      
    
    </summary>
    
    
      <category term="cryptography" scheme="https://cuixiaochen.com/tags/cryptography/"/>
    
  </entry>
  
  <entry>
    <title>MIT6.824 Lab 1 - MapReduce</title>
    <link href="https://cuixiaochen.com/2018/09/10/824-lab1/"/>
    <id>https://cuixiaochen.com/2018/09/10/824-lab1/</id>
    <published>2018-09-10T13:30:17.000Z</published>
    <updated>2018-10-07T12:26:34.167Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>MIT6.824 是一门久负盛名的分布式系统课程，今天开始我将会将课程中的系统作业、学习感悟写在专栏 <a href="/categories/MIT6-824-Labs/">MIT6.824 Labs</a> 中，与大家一起学习这门非常有趣的课程<br><a id="more"></a></p><p>完整代码（含答案）见 <a href="https://github.com/XiaochenCui/mit6.824" target="_blank" rel="noopener">github</a></p><h1 id="MapReduce"><a href="#MapReduce" class="headerlink" title="MapReduce"></a>MapReduce</h1><p>MapReduce 的具体架构及思想 <a href="https://pdos.csail.mit.edu/6.824/papers/mapreduce.pdf" target="_blank" rel="noopener">paper</a> 中已经讲的很详细了，在此不再赘述，仅贴出架构图供大家复习：</p><img src="/2018/09/10/824-lab1/mr.jpg"><h1 id="习题讲解"><a href="#习题讲解" class="headerlink" title="习题讲解"></a>习题讲解</h1><h2 id="Part-I-Map-Reduce-input-and-output"><a href="#Part-I-Map-Reduce-input-and-output" class="headerlink" title="Part I: Map/Reduce input and output"></a>Part I: Map/Reduce input and output</h2><p>要求完成 doMap 和 doReduce 函数</p><h3 id="doMap"><a href="#doMap" class="headerlink" title="doMap"></a>doMap</h3><p><code>doMap</code> 函数执行一个 map 任务，它的运行流程如下：</p><ol><li>读取输入文件 (inFile)</li><li>调用用户编写的 map 函数 (mapF) 处理输入文件</li><li>然后将 map 函数的输出分片到 r 个缓存文件中（其中 r 为 reduce task 的个数）</li></ol><p>Tips：</p><ol><li>map 函数的输出为键值对列表</li><li>使用 <code>ihash</code> 确定输出文件索引值的目的是为了使输出均匀分布，且对于不同的 worker，同一个 key 会落在 reduce index 相同的输出文件</li><li>空间复杂度为 O(n)，其中 n 为 key 的个数</li><li>读取文件使用 <a href="https://golang.org/pkg/io/ioutil/#ReadFile" target="_blank" rel="noopener">ioutil#ReadFile</a></li><li>将 KeyValue 写入文件可以用 <a href="https://golang.org/pkg/encoding/json/#Encoder" target="_blank" rel="noopener">encoding/json#Encoder</a></li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">doMap</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    jobName <span class="keyword">string</span>, // the name of the MapReduce job</span></span></span><br><span class="line"><span class="function"><span class="params">    mapTask <span class="keyword">int</span>, // which <span class="keyword">map</span> task this is</span></span></span><br><span class="line"><span class="function"><span class="params">    inFile <span class="keyword">string</span>,</span></span></span><br><span class="line">    nReduce int, // the number of reduce task that will be run ("R" in the paper)</span><br><span class="line">    mapF <span class="function"><span class="keyword">func</span><span class="params">(filename <span class="keyword">string</span>, contents <span class="keyword">string</span>)</span> []<span class="title">KeyValue</span>,</span></span><br><span class="line"><span class="function">)</span> &#123;</span><br><span class="line">    <span class="comment">// Read content of inFile</span></span><br><span class="line">    data, err := ioutil.ReadFile(inFile)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Printf(<span class="string">"Error: %v"</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Execute map function</span></span><br><span class="line">    keyValuePairs := mapF(inFile, <span class="keyword">string</span>(data[:<span class="built_in">len</span>(data)]))</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Split the keyValuePairs into a multidimensional array whose size is the</span></span><br><span class="line">    <span class="comment">// number of reduce tasks</span></span><br><span class="line">    divided := <span class="built_in">make</span>([][]KeyValue, nReduce)</span><br><span class="line">    <span class="keyword">for</span> _, keyValue := <span class="keyword">range</span> keyValuePairs &#123;</span><br><span class="line">        index := ihash(keyValue.Key) % nReduce</span><br><span class="line">        divided[index] = <span class="built_in">append</span>(divided[index], keyValue)</span><br><span class="line">    &#125;</span><br><span class="line">    debug(<span class="string">"%#v"</span>, divided)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Write divided keyValuePairs to R files, where R is the number of reduce</span></span><br><span class="line">    <span class="comment">// tasks</span></span><br><span class="line">    <span class="keyword">for</span> i, subKeyValuePairs := <span class="keyword">range</span> divided &#123;</span><br><span class="line">        <span class="comment">// Get filename for output</span></span><br><span class="line">        filePath := reduceName(jobName, mapTask, i)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Create output file</span></span><br><span class="line">        f, err := os.Create(filePath)</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            log.Printf(<span class="string">"Error: %v"</span>, err)</span><br><span class="line">        &#125;</span><br><span class="line">        enc := json.NewEncoder(f)</span><br><span class="line">        <span class="keyword">for</span> _, kv := <span class="keyword">range</span> subKeyValuePairs &#123;</span><br><span class="line">            err := enc.Encode(&amp;kv)</span><br><span class="line">            <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">                log.Printf(<span class="string">"Error: %v"</span>, err)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        f.Close()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ihash</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    h := fnv.New32a()</span><br><span class="line">    h.Write([]<span class="keyword">byte</span>(s))</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">int</span>(h.Sum32() &amp; <span class="number">0x7fffffff</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="doReduce"><a href="#doReduce" class="headerlink" title="doReduce"></a>doReduce</h3><p>doReduce 函数运行一个 reduce task，它的运行流程：</p><ol><li>读取 m 个缓存文件（m 为 map task 的个数）</li><li>将相同 key 对应的 value 合并为一个列表</li><li>处理每个 key：将其对应的 value 列表传入 reduce 函数 (reduceF)，得到最终的 value</li><li>将结果写入到磁盘</li></ol><p>Tips:</p><ol><li>按行读取文件可以用 <a href="https://golang.org/pkg/bufio/#Scanner" target="_blank" rel="noopener">bufio#Scanner</a></li><li>JSON 解序列化可以用 <a href="https://golang.org/pkg/encoding/json/#Unmarshaler" target="_blank" rel="noopener">json#Unmarshaler</a></li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">doReduce</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    jobName <span class="keyword">string</span>, // the name of the whole MapReduce job</span></span></span><br><span class="line"><span class="function"><span class="params">    reduceTask <span class="keyword">int</span>, // which reduce task this is</span></span></span><br><span class="line"><span class="function"><span class="params">    outFile <span class="keyword">string</span>, // write the output here</span></span></span><br><span class="line">    nMap int, // the number of map tasks that were run ("M" in the paper)</span><br><span class="line">    reduceF <span class="function"><span class="keyword">func</span><span class="params">(key <span class="keyword">string</span>, values []<span class="keyword">string</span>)</span> <span class="title">string</span>,</span></span><br><span class="line"><span class="function">)</span> &#123;</span><br><span class="line">    keyValuesMap := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>][]<span class="keyword">string</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Read intermediate files</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; nMap; i++ &#123;</span><br><span class="line">        filename := reduceName(jobName, i, reduceTask)</span><br><span class="line">        file, err := os.Open(filename)</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            log.Printf(<span class="string">"Error: %v"</span>, err)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> tempKeyValuePairs []KeyValue</span><br><span class="line">        <span class="keyword">var</span> keyValue KeyValue</span><br><span class="line">        fileScanner := bufio.NewScanner(file)</span><br><span class="line">        <span class="keyword">for</span> fileScanner.Scan() &#123;</span><br><span class="line">            json.Unmarshal([]<span class="keyword">byte</span>(fileScanner.Text()), &amp;keyValue)</span><br><span class="line">            tempKeyValuePairs = <span class="built_in">append</span>(tempKeyValuePairs, keyValue)</span><br><span class="line">        &#125;</span><br><span class="line">        debug(<span class="string">"KeyValues: %v"</span>, tempKeyValuePairs)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> _, keyValue := <span class="keyword">range</span> tempKeyValuePairs &#123;</span><br><span class="line">            key := keyValue.Key</span><br><span class="line">            <span class="keyword">if</span> values, ok := keyValuesMap[key]; ok &#123;</span><br><span class="line">                keyValuesMap[key] = <span class="built_in">append</span>(values, keyValue.Value)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                keyValuesMap[key] = []<span class="keyword">string</span>&#123;keyValue.Value&#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    file, err := os.Create(outFile)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Printf(<span class="string">"Error: %v"</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line">    enc := json.NewEncoder(file)</span><br><span class="line">    <span class="keyword">for</span> k, v := <span class="keyword">range</span> keyValuesMap &#123;</span><br><span class="line">        enc.Encode(KeyValue&#123;k, reduceF(k, v)&#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    file.Close()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Part-II-Single-worker-word-count"><a href="#Part-II-Single-worker-word-count" class="headerlink" title="Part II: Single-worker word count"></a>Part II: Single-worker word count</h2><h3 id="mapF"><a href="#mapF" class="headerlink" title="mapF"></a>mapF</h3><p>每读入一个输入文件，map 函数就会被执行一次，第一个参数是文件名，第二个参数是文件内容。由于我们这里的目标是做 word count，所以 key 是 word，value 是 word 在该文件中出现的次数</p><p>Tips:</p><ol><li>单词分隔可以用 <a href="https://golang.org/pkg/strings/#FieldsFunc" target="_blank" rel="noopener">strings#FieldsFunc</a></li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mapF</span><span class="params">(filename <span class="keyword">string</span>, contents <span class="keyword">string</span>)</span> []<span class="title">mapreduce</span>.<span class="title">KeyValue</span></span> &#123;</span><br><span class="line">    <span class="comment">// Your code here (Part II).</span></span><br><span class="line">    notWord := <span class="function"><span class="keyword">func</span><span class="params">(c <span class="keyword">rune</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">        <span class="keyword">return</span> !unicode.IsLetter(c) &amp;&amp; !unicode.IsNumber(c)</span><br><span class="line">    &#125;</span><br><span class="line">    words := strings.FieldsFunc(contents, notWord)</span><br><span class="line">    wordCountMap := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>)</span><br><span class="line">    <span class="keyword">for</span> _, word := <span class="keyword">range</span> words &#123;</span><br><span class="line">        <span class="keyword">if</span> _, ok := wordCountMap[word]; ok &#123;</span><br><span class="line">            wordCountMap[word]++</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            wordCountMap[word] = <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> wordCount []mapreduce.KeyValue</span><br><span class="line">    <span class="keyword">for</span> k, v := <span class="keyword">range</span> wordCountMap &#123;</span><br><span class="line">        wordCount = <span class="built_in">append</span>(wordCount, mapreduce.KeyValue&#123;Key: k, Value: strconv.Itoa(v)&#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> wordCount</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="reduceF"><a href="#reduceF" class="headerlink" title="reduceF"></a>reduceF</h3><p>对于每一个 key，reduce 函数会被执行一次，第一个参数是 key，第二个参数是其对应的所有值组成的列表</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reduceF</span><span class="params">(key <span class="keyword">string</span>, values []<span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    <span class="comment">// Your code here (Part II).</span></span><br><span class="line">    sum := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> _, v := <span class="keyword">range</span> values &#123;</span><br><span class="line">        v, err := strconv.Atoi(v)</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            fmt.Print(<span class="string">"Error: %v, value: %v"</span>, err, v)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            sum += v</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> strconv.Itoa(sum)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Part-III-Distributing-MapReduce-tasks"><a href="#Part-III-Distributing-MapReduce-tasks" class="headerlink" title="Part III: Distributing MapReduce tasks"></a>Part III: Distributing MapReduce tasks</h2><p>在这里我们将会完成 schedule 函数。schedule 函数负责调度工作，它在程序的整个生命周期中会运行两次：map 阶段一次，reduce 阶段一次。</p><p>这里我们在 goroutine 中使用指针访问外部数据是非常错误的写法，一旦 doTaskArgs 的值被外部程序修改，就会导致不可预料的结果。而这里我们的程序正常运行只是由于每次循环都会重新声明 doTaskArgs。</p><p>正确的做法是将 goroutine 所需的外部变量作为参数传入 goroutine。</p><p>同时，将任务分配完毕后直接跳出分配循环的做法也是不正确的，在 Part IV 中我们将会看到更正确、更优雅的写法。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">schedule</span><span class="params">(jobName <span class="keyword">string</span>, mapFiles []<span class="keyword">string</span>, nReduce <span class="keyword">int</span>, phase jobPhase, registerChan <span class="keyword">chan</span> <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> ntasks <span class="keyword">int</span></span><br><span class="line">    <span class="keyword">var</span> n_other <span class="keyword">int</span> <span class="comment">// number of inputs (for reduce) or outputs (for map)</span></span><br><span class="line">    <span class="keyword">switch</span> phase &#123;</span><br><span class="line">    <span class="keyword">case</span> mapPhase:</span><br><span class="line">        ntasks = <span class="built_in">len</span>(mapFiles)</span><br><span class="line">        n_other = nReduce</span><br><span class="line">    <span class="keyword">case</span> reducePhase:</span><br><span class="line">        ntasks = nReduce</span><br><span class="line">        n_other = <span class="built_in">len</span>(mapFiles)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fmt.Printf(<span class="string">"Schedule: %v %v tasks (%d I/Os)\n"</span>, ntasks, phase, n_other)</span><br><span class="line"></span><br><span class="line">    finishedTasks := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; ntasks; i++ &#123;</span><br><span class="line">        workerAddress := &lt;-registerChan</span><br><span class="line">        fmt.Printf(<span class="string">"Assigning #%d task to %s\n"</span>, i, workerAddress)</span><br><span class="line">        inputFile := mapFiles[i]</span><br><span class="line">        doTaskArgs := DoTaskArgs&#123;</span><br><span class="line">            JobName:       jobName,</span><br><span class="line">            File:          inputFile,</span><br><span class="line">            Phase:         phase,</span><br><span class="line">            TaskNumber:    i,</span><br><span class="line">            NumOtherPhase: n_other,</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            success := call(workerAddress, <span class="string">"Worker.DoTask"</span>, &amp;doTaskArgs, <span class="literal">nil</span>)</span><br><span class="line">            <span class="keyword">if</span> success &#123;</span><br><span class="line">                fmt.Printf(<span class="string">"Task success\n"</span>)</span><br><span class="line">                registerChan &lt;- workerAddress</span><br><span class="line">                finishedTasks++</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                fmt.Printf(<span class="string">"Task failed\n"</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    unfinishedTasks := ntasks - finishedTasks</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; unfinishedTasks; i++ &#123;</span><br><span class="line">        &lt;-registerChan</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fmt.Printf(<span class="string">"Schedule: %v done\n"</span>, phase)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Part-IV-Handling-worker-failures"><a href="#Part-IV-Handling-worker-failures" class="headerlink" title="Part IV: Handling worker failures"></a>Part IV: Handling worker failures</h2><p>之前完成的 schedule 函数将任务分配完之后就开始等待所有任务完成，无法处理 worker failures。</p><p>在这里我们对它进行改进，主要：</p><ol><li>将 channel receive 改为 unblock</li><li>失败的 task 重新入队</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">schedule</span><span class="params">(jobName <span class="keyword">string</span>, mapFiles []<span class="keyword">string</span>, nReduce <span class="keyword">int</span>, phase jobPhase, registerChan <span class="keyword">chan</span> <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> ntasks <span class="keyword">int</span></span><br><span class="line">    <span class="keyword">var</span> n_other <span class="keyword">int</span> <span class="comment">// number of inputs (for reduce) or outputs (for map)</span></span><br><span class="line">    <span class="keyword">switch</span> phase &#123;</span><br><span class="line">    <span class="keyword">case</span> mapPhase:</span><br><span class="line">        ntasks = <span class="built_in">len</span>(mapFiles)</span><br><span class="line">        n_other = nReduce</span><br><span class="line">    <span class="keyword">case</span> reducePhase:</span><br><span class="line">        ntasks = nReduce</span><br><span class="line">        n_other = <span class="built_in">len</span>(mapFiles)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fmt.Printf(<span class="string">"Schedule: %v %v tasks (%d I/Os)\n"</span>, ntasks, phase, n_other)</span><br><span class="line"></span><br><span class="line">    finishedTasks := <span class="number">0</span></span><br><span class="line">    tasksChan := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, ntasks)</span><br><span class="line">    <span class="keyword">var</span> taskIndex <span class="keyword">int</span></span><br><span class="line">    <span class="keyword">for</span> taskIndex := <span class="number">0</span>; taskIndex &lt; ntasks; taskIndex++ &#123;</span><br><span class="line">        tasksChan &lt;- taskIndex</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> inputFile <span class="keyword">string</span></span><br><span class="line">    <span class="keyword">for</span> finishedTasks &lt; ntasks &#123;</span><br><span class="line">        <span class="keyword">select</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> taskIndex = &lt;-tasksChan:</span><br><span class="line">            workerAddress := &lt;-registerChan</span><br><span class="line">            fmt.Printf(<span class="string">"Assigning #%d task to %s\n"</span>, taskIndex, workerAddress)</span><br><span class="line">            inputFile = mapFiles[taskIndex]</span><br><span class="line">            doTaskArgs := DoTaskArgs&#123;</span><br><span class="line">                JobName:       jobName,</span><br><span class="line">                File:          inputFile,</span><br><span class="line">                Phase:         phase,</span><br><span class="line">                TaskNumber:    taskIndex,</span><br><span class="line">                NumOtherPhase: n_other,</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">                success := call(workerAddress, <span class="string">"Worker.DoTask"</span>, &amp;doTaskArgs, <span class="literal">nil</span>)</span><br><span class="line">                <span class="keyword">if</span> success &#123;</span><br><span class="line">                    fmt.Printf(<span class="string">"Task #%d success\n"</span>, doTaskArgs.TaskNumber)</span><br><span class="line">                    finishedTasks++</span><br><span class="line">                    registerChan &lt;- workerAddress</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    fmt.Printf(<span class="string">"Task #%d failed\n"</span>, doTaskArgs.TaskNumber)</span><br><span class="line">                    tasksChan &lt;- doTaskArgs.TaskNumber</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;()</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fmt.Printf(<span class="string">"Schedule: %v done\n"</span>, phase)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Part-V-Inverted-index-generation"><a href="#Part-V-Inverted-index-generation" class="headerlink" title="Part V: Inverted index generation"></a>Part V: Inverted index generation</h2><p>在这里我们将会实现 inverted index, 与之前的 word count 正好相反，现在 word 作为 key，而 document 作为 value</p><h3 id="doMap-1"><a href="#doMap-1" class="headerlink" title="doMap"></a>doMap</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mapF</span><span class="params">(document <span class="keyword">string</span>, value <span class="keyword">string</span>)</span> <span class="params">(res []mapreduce.KeyValue)</span></span> &#123;</span><br><span class="line">    <span class="comment">// Your code here (Part V).</span></span><br><span class="line">    notWord := <span class="function"><span class="keyword">func</span><span class="params">(c <span class="keyword">rune</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">        <span class="keyword">return</span> !unicode.IsLetter(c) &amp;&amp; !unicode.IsNumber(c)</span><br><span class="line">    &#125;</span><br><span class="line">    words := strings.FieldsFunc(value, notWord)</span><br><span class="line">    wordDoc := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>)</span><br><span class="line">    <span class="keyword">for</span> _, word := <span class="keyword">range</span> words &#123;</span><br><span class="line">        <span class="keyword">if</span> _, ok := wordDoc[word]; !ok &#123;</span><br><span class="line">            wordDoc[word] = document</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> k, v := <span class="keyword">range</span> wordDoc &#123;</span><br><span class="line">        res = <span class="built_in">append</span>(res, mapreduce.KeyValue&#123;Key: k, Value: v&#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="doReduce-1"><a href="#doReduce-1" class="headerlink" title="doReduce"></a>doReduce</h3><p>由于 values 不存在冲突的情况，所以直接 join 起来就可以了。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reduceF</span><span class="params">(key <span class="keyword">string</span>, values []<span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    <span class="comment">// Your code here (Part V).</span></span><br><span class="line">    <span class="keyword">var</span> documents []<span class="keyword">string</span></span><br><span class="line">    <span class="keyword">for</span> _, v := <span class="keyword">range</span> values &#123;</span><br><span class="line">        documents = <span class="built_in">append</span>(documents, v)</span><br><span class="line">    &#125;</span><br><span class="line">    res := strings.Join(documents, <span class="string">","</span>)</span><br><span class="line">    res = strconv.Itoa(<span class="built_in">len</span>(documents)) + <span class="string">" "</span> + res</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;MIT6.824 是一门久负盛名的分布式系统课程，今天开始我将会将课程中的系统作业、学习感悟写在专栏 &lt;a href=&quot;/categories/MIT6-824-Labs/&quot;&gt;MIT6.824 Labs&lt;/a&gt; 中，与大家一起学习这门非常有趣的课程&lt;br&gt;
    
    </summary>
    
      <category term="MIT6.824 Labs" scheme="https://cuixiaochen.com/categories/MIT6-824-Labs/"/>
    
    
      <category term="distributed systems" scheme="https://cuixiaochen.com/tags/distributed-systems/"/>
    
  </entry>
  
  <entry>
    <title>Cryptography Week 5 - Programming Assignment</title>
    <link href="https://cuixiaochen.com/2018/08/12/cryptography-week-5-program-assigment/"/>
    <id>https://cuixiaochen.com/2018/08/12/cryptography-week-5-program-assigment/</id>
    <published>2018-08-12T09:44:51.000Z</published>
    <updated>2018-08-12T10:05:46.146Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>这次我们的任务是求离散对数 (discrete log)，采用的方法是 meet in the middle</p><p>Meet in the middle 最令我们印象深刻的就是其在破解 3DES 时的表现，将暴力破解的时间复杂度减少到了 $2 ^ {56}$<br><a id="more"></a></p><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><img src="/2018/08/12/cryptography-week-5-program-assigment/pa.png"><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>需要注意的是，modular division 和一般除法不同，需要先求 modular inversion，然后再做 modular multiplication 得到 division</p><p>以下是代码题解：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> gmpy2</span><br><span class="line"><span class="keyword">from</span> gmpy2 <span class="keyword">import</span> (</span><br><span class="line">    mpz,</span><br><span class="line">    powmod,</span><br><span class="line">    mul,</span><br><span class="line">    invert,</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">B = <span class="number">2</span> ** <span class="number">20</span></span><br><span class="line">p = mpz(<span class="string">'13407807929942597099574024998205846127479365820592393377723561443721764030073546976801874298166903427690031858186486050853753882811946569946433649006084171'</span>)</span><br><span class="line">g = mpz(<span class="string">'11717829880366207009516117596335367088558084999998952205599979459063929499736583746670572176471460312928594829675428279466566527115212748467589894601965568'</span>)</span><br><span class="line">h = mpz(<span class="string">'3239475104050450443565264378728065788649097520952449527834792452971981976143292558073856937958553180532878928001494706097394108577585732452307673444020333'</span>)</span><br><span class="line"></span><br><span class="line">hash_table = dict()</span><br><span class="line"><span class="keyword">for</span> x_1 <span class="keyword">in</span> range(B + <span class="number">1</span>):</span><br><span class="line">    key = mul(h, invert(powmod(g, x_1, p), p)) % p</span><br><span class="line">    value = x_1</span><br><span class="line">    hash_table[key] = value</span><br><span class="line"></span><br><span class="line">base = powmod(g, B, p)</span><br><span class="line"><span class="keyword">for</span> x_0 <span class="keyword">in</span> range(B + <span class="number">1</span>):</span><br><span class="line">    target = powmod(base, x_0, p)</span><br><span class="line">    <span class="keyword">if</span> target <span class="keyword">in</span> hash_table:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">x = x_0 * B + hash_table[target]</span><br><span class="line">print(<span class="string">'x: &#123;&#125;'</span>.format(x))</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;这次我们的任务是求离散对数 (discrete log)，采用的方法是 meet in the middle&lt;/p&gt;
&lt;p&gt;Meet in the middle 最令我们印象深刻的就是其在破解 3DES 时的表现，将暴力破解的时间复杂度减少到了 $2 ^ {56}$&lt;br&gt;
    
    </summary>
    
      <category term="Exercises of Cryptography" scheme="https://cuixiaochen.com/categories/Exercises-of-Cryptography/"/>
    
    
      <category term="cryptography" scheme="https://cuixiaochen.com/tags/cryptography/"/>
    
  </entry>
  
  <entry>
    <title>Cryptography Week 5 - Problem Set</title>
    <link href="https://cuixiaochen.com/2018/08/12/cryptography-week-5-problem-set/"/>
    <id>https://cuixiaochen.com/2018/08/12/cryptography-week-5-problem-set/</id>
    <published>2018-08-12T05:42:10.000Z</published>
    <updated>2018-08-12T06:49:52.356Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h1><p>本章的主要内容是密钥交换 (key exchange) 和数论 (number theory)</p><p>密钥交换部分先后讲了 TTP (Trusted third parties), Merkle Puzzle 和 Diffie-Hellman protocol</p><p>数论部分的核心概念是 Modular arithmetic，并由此展开 Fermat’s theorem, Euler’s theorem 等定理，同时辅以 order, generator 等概念来做 Modular arithmetic<br><a id="more"></a></p><h1 id="Exercise-explanation"><a href="#Exercise-explanation" class="headerlink" title="Exercise explanation"></a>Exercise explanation</h1><img src="/2018/08/12/cryptography-week-5-problem-set/1.png" width="700"><p>此题比较简单，要注意两点：</p><ol><li>密钥不能以明文形式发送，所以发送的应该是 ticket 而不是 key</li><li>三者所持有的密钥应该相同</li></ol><img src="/2018/08/12/cryptography-week-5-problem-set/2.png" width="700"><p>1 和 4 两个选项需要求解离散对数，是正确选项</p><img src="/2018/08/12/cryptography-week-5-problem-set/3.png" width="700"><img src="/2018/08/12/cryptography-week-5-problem-set/4.png" width="700"><p>由于 pk 是公开的，所以对 ciphertext 加 MAC 不能防止 MIMA</p><img src="/2018/08/12/cryptography-week-5-problem-set/5.png" width="700"><p>本题应使用 Extended Euclidean Algorithm</p><img src="/2018/08/12/cryptography-week-5-problem-set/6.png" width="700"><p>求解 Modular inversion 同样可以用 Extended Euclidean Algorithm</p><img src="/2018/08/12/cryptography-week-5-problem-set/7.png" width="700"><p>使用 Euler’s theorem</p><img src="/2018/08/12/cryptography-week-5-problem-set/8.png" width="700"><p>使用 Fermat’s theorem</p><img src="/2018/08/12/cryptography-week-5-problem-set/9.png" width="700"><p>使用 Fermat’s theorem</p><img src="/2018/08/12/cryptography-week-5-problem-set/10.png" width="700"><img src="/2018/08/12/cryptography-week-5-problem-set/11.png" width="700"><img src="/2018/08/12/cryptography-week-5-problem-set/12.png" width="700"><img src="/2018/08/12/cryptography-week-5-problem-set/13.png" width="700"><img src="/2018/08/12/cryptography-week-5-problem-set/14.png" width="700"><img src="/2018/08/12/cryptography-week-5-problem-set/15.png" width="700">]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Overview&quot;&gt;&lt;a href=&quot;#Overview&quot; class=&quot;headerlink&quot; title=&quot;Overview&quot;&gt;&lt;/a&gt;Overview&lt;/h1&gt;&lt;p&gt;本章的主要内容是密钥交换 (key exchange) 和数论 (number theory)&lt;/p&gt;
&lt;p&gt;密钥交换部分先后讲了 TTP (Trusted third parties), Merkle Puzzle 和 Diffie-Hellman protocol&lt;/p&gt;
&lt;p&gt;数论部分的核心概念是 Modular arithmetic，并由此展开 Fermat’s theorem, Euler’s theorem 等定理，同时辅以 order, generator 等概念来做 Modular arithmetic&lt;br&gt;
    
    </summary>
    
      <category term="Exercises of Cryptography" scheme="https://cuixiaochen.com/categories/Exercises-of-Cryptography/"/>
    
    
      <category term="cryptography" scheme="https://cuixiaochen.com/tags/cryptography/"/>
    
  </entry>
  
  <entry>
    <title>Proof of Fermat&#39;s Little Theorem</title>
    <link href="https://cuixiaochen.com/2018/07/22/fermat-little-theorem/"/>
    <id>https://cuixiaochen.com/2018/07/22/fermat-little-theorem/</id>
    <published>2018-07-22T14:20:44.000Z</published>
    <updated>2018-08-12T06:49:01.611Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h1><p>Fermat’s little theorem states that if $p$ is a prime number, then for any integer $a$, the number $a^p - a$ is an integer multiple of $p$. In the notation of modular arithmetic, this is expressed as</p>$$    \begin{align*}        a^p \equiv a\: (mod p)    \end{align*}$$<p>To be continued</p><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ul><li><a href="https://en.wikipedia.org/wiki/Fermat%27s_little_theorem" target="_blank" rel="noopener">Fermat’s little theorem</a></li><li><a href="https://primes.utm.edu/notes/proofs/FermatsLittleTheorem.html" target="_blank" rel="noopener">Proof of Fermat’s Little Theorem</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Overview&quot;&gt;&lt;a href=&quot;#Overview&quot; class=&quot;headerlink&quot; title=&quot;Overview&quot;&gt;&lt;/a&gt;Overview&lt;/h1&gt;&lt;p&gt;Fermat’s little theorem states that if $p$ is 
      
    
    </summary>
    
      <category term="Fun with number theory" scheme="https://cuixiaochen.com/categories/Fun-with-number-theory/"/>
    
    
      <category term="number theory" scheme="https://cuixiaochen.com/tags/number-theory/"/>
    
  </entry>
  
  <entry>
    <title>新专栏：数论</title>
    <link href="https://cuixiaochen.com/2018/07/22/number-theorem/"/>
    <id>https://cuixiaochen.com/2018/07/22/number-theorem/</id>
    <published>2018-07-22T13:36:00.000Z</published>
    <updated>2018-08-12T06:49:13.807Z</updated>
    
    <content type="html"><![CDATA[<p>一个新的专栏： <a href="categories/Fun-with-number-theory/">Fun with number theory</a>。这个专栏将从费马小定律开始，讲一些简单的数论知识，并介绍这些数论知识在公钥密码学、素数检查、复数计算等方面的应用</p><p>由于本人也是初学者，错误及遗漏之处还请大家多多指正</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;一个新的专栏： &lt;a href=&quot;categories/Fun-with-number-theory/&quot;&gt;Fun with number theory&lt;/a&gt;。这个专栏将从费马小定律开始，讲一些简单的数论知识，并介绍这些数论知识在公钥密码学、素数检查、复数计算等方面的应用&lt;
      
    
    </summary>
    
      <category term="Fun with number theory" scheme="https://cuixiaochen.com/categories/Fun-with-number-theory/"/>
    
    
      <category term="number theory" scheme="https://cuixiaochen.com/tags/number-theory/"/>
    
  </entry>
  
  <entry>
    <title>Vim Lisp Plugin 推荐</title>
    <link href="https://cuixiaochen.com/2018/07/19/lisp-vim/"/>
    <id>https://cuixiaochen.com/2018/07/19/lisp-vim/</id>
    <published>2018-07-19T13:57:14.000Z</published>
    <updated>2018-07-20T11:34:41.030Z</updated>
    
    <content type="html"><![CDATA[<p>使用 lisp 编程的时候括号是一个很让人头疼的问题，vim 自带的 <a href="https://github.com/vim/vim/blob/master/runtime/plugin/matchparen.vim" target="_blank" rel="noopener">matchparen</a> 可以起到一定的帮助，但是还是有两个小问题：</p><ul><li>需要将光标移到括号上才能知道它对应的是哪个括号</li><li>频繁报错，很影响编码效率</li></ul><p>在这里向大家推荐两个插件帮大家更舒服地编写 lisp<br><a id="more"></a></p><h1 id="auto-pairs"><a href="#auto-pairs" class="headerlink" title="auto-pairs"></a>auto-pairs</h1><p><a href="https://github.com/jiangmiao/auto-pairs" target="_blank" rel="noopener">auto-pairs</a> 是一款非常实用的括号自动补全插件</p><h1 id="rainbow"><a href="#rainbow" class="headerlink" title="rainbow"></a>rainbow</h1><p><a href="https://github.com/luochen1990/rainbow" target="_blank" rel="noopener">rainbow</a> 可以给我们的括号着色，既美观又实用，可谓 lisp 神器</p><h2 id="效果图："><a href="#效果图：" class="headerlink" title="效果图："></a>效果图：</h2><img src="/2018/07/19/lisp-vim/rainbow.png"><h2 id="rainbow-的配置"><a href="#rainbow-的配置" class="headerlink" title="rainbow 的配置"></a>rainbow 的配置</h2><h3 id="使-rainbow-默认开启"><a href="#使-rainbow-默认开启" class="headerlink" title="使 rainbow 默认开启"></a>使 rainbow 默认开启</h3><p>与其他常用的 plugin 不同，rainbow 默认是关闭的，我们可以通过配置使其自动开启：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let g:rainbow_active = 1</span><br></pre></td></tr></table></figure><h3 id="颜色"><a href="#颜色" class="headerlink" title="颜色"></a>颜色</h3><p>rainbow 默认配置的颜色辨识度不高，我为其配置了更有辨识度的配色方案：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let g:rainbow_conf = &#123;</span><br><span class="line">\    &apos;guifgs&apos;: [&apos;royalblue3&apos;, &apos;darkorange3&apos;, &apos;seagreen3&apos;, &apos;firebrick&apos;],</span><br><span class="line">\    &apos;ctermfgs&apos;: [&apos;darkred&apos;, &apos;blue&apos;, &apos;yellow&apos;, &apos;cyan&apos;, &apos;magenta&apos;, &apos;brown&apos;],</span><br><span class="line">\&#125;</span><br></pre></td></tr></table></figure><h3 id="只为特定类型的文件启用"><a href="#只为特定类型的文件启用" class="headerlink" title="只为特定类型的文件启用"></a>只为特定类型的文件启用</h3><p>由于 rainbow 会破坏 markdown 等文件编辑界面，在这里我们通过配置使其只为特定文件开启：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Plug &apos;luochen1990/rainbow&apos;, &#123; &apos;for&apos;: &apos;scheme&apos;  &#125;</span><br></pre></td></tr></table></figure><p>我使用的插件管理器是 <a href="https://github.com/junegunn/vim-plug" target="_blank" rel="noopener">plug</a>，由于目前只在编写 scheme 的需要写比较多的括号，所以只为 scheme 源代码文件开启彩虹配色</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;使用 lisp 编程的时候括号是一个很让人头疼的问题，vim 自带的 &lt;a href=&quot;https://github.com/vim/vim/blob/master/runtime/plugin/matchparen.vim&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;matchparen&lt;/a&gt; 可以起到一定的帮助，但是还是有两个小问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;需要将光标移到括号上才能知道它对应的是哪个括号&lt;/li&gt;
&lt;li&gt;频繁报错，很影响编码效率&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在这里向大家推荐两个插件帮大家更舒服地编写 lisp&lt;br&gt;
    
    </summary>
    
    
      <category term="vim" scheme="https://cuixiaochen.com/tags/vim/"/>
    
      <category term="lisp" scheme="https://cuixiaochen.com/tags/lisp/"/>
    
  </entry>
  
  <entry>
    <title>一些关于 Key Exchange Protocol 的 paper</title>
    <link href="https://cuixiaochen.com/2018/07/15/key-exchange-paper/"/>
    <id>https://cuixiaochen.com/2018/07/15/key-exchange-paper/</id>
    <published>2018-07-15T13:48:13.000Z</published>
    <updated>2018-07-15T13:56:10.703Z</updated>
    
    <content type="html"><![CDATA[<ul><li><a href="https://www.boazbarak.org/Papers/merkle.pdf" target="_blank" rel="noopener">Mer Puzzles are Optimal, B.Barak, M.Mahmoody-Ghidary, Crypto ‘09</a><br>当我们只使用 symmetric ciphers 和 hash functions 的时候，Merkle Puzzles 是 key exchange 的最优选择。即我们无法在这样的限制下超越 quadratic gap</li><li><a href="http://www.shoup.net/papers/skey.pdf" target="_blank" rel="noopener">On Formal models of key exchange (sections 7-9) V.Shoup, 1999</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://www.boazbarak.org/Papers/merkle.pdf&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Mer Puzzles are Optimal, B.Barak, M.Mahmoody-G
      
    
    </summary>
    
    
      <category term="cryptography" scheme="https://cuixiaochen.com/tags/cryptography/"/>
    
  </entry>
  
  <entry>
    <title>Closed Form Expression For Fibonacci Numbers 的证明</title>
    <link href="https://cuixiaochen.com/2018/07/11/fib/"/>
    <id>https://cuixiaochen.com/2018/07/11/fib/</id>
    <published>2018-07-10T23:11:39.000Z</published>
    <updated>2018-07-22T13:23:00.797Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h1><p>此题出自 SICP 第一章练习题 1.13</p><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>Prove that $Fib(n)$ is the closest integer to $\phi^n/\sqrt5$, where $\phi=(1+\sqrt5)/2$. Hint: Let $\psi=(1-\sqrt5)/2$. Use induction and definition of the Fibonacci numbers (see section 1.2.2) to prove that $Fib(n)=(\phi^n-\psi^n)/\sqrt5$.<br><a id="more"></a></p><h1 id="证明"><a href="#证明" class="headerlink" title="证明"></a>证明</h1><h2 id="phi-和-psi-的性质"><a href="#phi-和-psi-的性质" class="headerlink" title="$\phi$ 和 $\psi$ 的性质"></a>$\phi$ 和 $\psi$ 的性质</h2><p>由题目所设 $\phi=(1+\sqrt5)/2$ 易得：</p>$$    \begin{align*}        \phi^2 = \phi+1 \\        1/\phi + 1 = \phi \\    \end{align*}$$<p>由 $\psi=(1-\sqrt5)/2$ 易得：</p>$$    \begin{align*}        \psi^2 = \psi + 1 \\        1/\psi + 1 = \psi\\    \end{align*}$$<h2 id="归纳证明法证明-Fib-n-phi-n-psi-n-sqrt5"><a href="#归纳证明法证明-Fib-n-phi-n-psi-n-sqrt5" class="headerlink" title="归纳证明法证明 $Fib(n)=(\phi^n-\psi^n)/\sqrt5$"></a>归纳证明法证明 $Fib(n)=(\phi^n-\psi^n)/\sqrt5$</h2><p>$\text{for } n=0:$<br>$$    \begin{align*}        (\phi^n-\psi^n)/\sqrt5 =& (\phi^0-\psi^0)/\sqrt5 \\                               =& 0 \\    \end{align*}$$</p><p>$\text{for } n=1:$<br>$$    \begin{align*}        (\phi^n-\psi^n)/\sqrt5 =& (\phi^1-\psi^1)/\sqrt5 \\                               =& 1 \\    \end{align*}$$</p><p>$\text{for } n=2:$<br>$$    \begin{align*}        (\phi^n-\psi^n)/\sqrt5 =& (\phi^2-\psi^2)/\sqrt5 \\                               =& 1 \\    \end{align*}$$</p><p>现在开始采用归纳证明法</p><p>假设下列两个等式成立：</p>$$    \begin{align*}        Fib(n)   =& (\phi^n-\psi^n)/\sqrt5 \\        Fib(n-1) =& (\phi^{n-1}-\psi^{n-1})/\sqrt5 \\    \end{align*}$$<p>我们现在需要证明以下等式成立：</p>$$    \begin{align*}        Fib(n+1) =& (\phi^{n+1}-\psi^{n+1})/\sqrt5 \\    \end{align*}$$<p>通过 Fibonacci 序列的性质与之前提到的 $\phi$ 和 $\psi$ 的性质，可给出如下的证明过程：</p>$$    \begin{align*}        Fib(n+1) =& Fib(n) + Fib(n-1) \\                 =& (\phi^n-\psi^n)/\sqrt5 + (\phi^{n-1}-\psi^{n-1})/\sqrt5 \\                 =& ((\phi^n-\psi^n) + (\phi^{n-1}-\psi^{n-1}))/\sqrt5 \\                 =& ((\phi^n+\phi^{n-1}) - (\psi^n+\psi^{n-1}))/\sqrt5 \\                 =& (\phi^{n+1} * (\phi^{-1}+\phi^{-2}) - \psi^{n+1} * (\psi^{-1}+\psi^{-2})) / \sqrt5 \\                 =& (\phi^{n+1} * \phi^{-1} * (1+\phi^{-1}) - \psi^{n+1} * \psi^{-1} * (1+\psi^{-1})) / \sqrt5 \\                 =& (\phi^{n+1} * 1/\phi * (1+1/\phi) - \psi^{n+1} * 1/\psi * (1+1/\psi)) / \sqrt5 \\                 =& (\phi^{n+1} * 1/\phi * \phi - \psi^{n+1} * 1/\psi * \psi) / \sqrt5 \\                 =& (\phi^{n+1} - \psi^{n+1}) / \sqrt5 \\    \end{align*}$$<h2 id="最后一步"><a href="#最后一步" class="headerlink" title="最后一步"></a>最后一步</h2><p>我们首先简单转化一下之前证明过的等式：</p>$$    \begin{align*}        Fib(n) =& (\phi^n-\psi^n)/\sqrt5 \\        Fib(n) =& \phi^n/\sqrt5 - \psi^n/\sqrt5 \\        \phi^n/\sqrt5 - Fib(n) =& \psi^n/\sqrt5 \\    \end{align*}$$<p>做以上变换是因为我们的目的是证明 $Fib(n)$ 和 $\phi^n/\sqrt5$ 之间的关系。现在我们需要做的就是证明这两者的差总是小于 $1/2$。即证明：</p>$$    \begin{align*}        \psi^n/\sqrt5 \leq 1/2    \end{align*}$$<p>即证明：</p>$$    \begin{align*}        \psi^n \leq \sqrt5/2    \end{align*}$$<p>由于 $\psi=(1-\sqrt5)/2$，我们可以计算求得：</p>$$    \begin{align*}        \psi \approx -0.618304    \end{align*}$$<p>由于 $Fib(n)$ 总是整数且 $n \geq 0$，$|\psi| &lt; 1$，可以得出：</p>$$    \begin{align*}        \psi^n \leq 1    \end{align*}$$<p>同时：</p>$$    \begin{align*}        \sqrt5/2 \approx 1.118    \end{align*}$$<p>因为 $\psi^n \leq 1$，且 $\sqrt5/2 &gt; 1$，所以：</p>$$    \begin{align*}        \psi^n < \sqrt5/2    \end{align*}$$<p>因此，$Fib(n)$ 是最接近 $\psi^n/\sqrt5$ 的整数。</p><p>完。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="http://www.billthelizard.com/2009/12/sicp-exercise-113-fibonacci-and-golden.html" target="_blank" rel="noopener">Bill the Lizard</a></li><li><a href="https://en.wikipedia.org/wiki/Fibonacci_number#Closed-form_expression" target="_blank" rel="noopener">Fibonacci number</a></li><li><a href="https://artofproblemsolving.com/wiki/index.php?title=Binet%27s_Formula" target="_blank" rel="noopener">Binet’s Formula - Art of Problem Solving</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;概览&quot;&gt;&lt;a href=&quot;#概览&quot; class=&quot;headerlink&quot; title=&quot;概览&quot;&gt;&lt;/a&gt;概览&lt;/h1&gt;&lt;p&gt;此题出自 SICP 第一章练习题 1.13&lt;/p&gt;
&lt;h1 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h1&gt;&lt;p&gt;Prove that $Fib(n)$ is the closest integer to $\phi^n/\sqrt5$, where $\phi=(1+\sqrt5)/2$. Hint: Let $\psi=(1-\sqrt5)/2$. Use induction and definition of the Fibonacci numbers (see section 1.2.2) to prove that $Fib(n)=(\phi^n-\psi^n)/\sqrt5$.&lt;br&gt;
    
    </summary>
    
      <category term="Fun with number theory" scheme="https://cuixiaochen.com/categories/Fun-with-number-theory/"/>
    
    
      <category term="sicp" scheme="https://cuixiaochen.com/tags/sicp/"/>
    
      <category term="number theory" scheme="https://cuixiaochen.com/tags/number-theory/"/>
    
  </entry>
  
  <entry>
    <title>Counting Change 问题的详细分析及解答</title>
    <link href="https://cuixiaochen.com/2018/07/08/count-change/"/>
    <id>https://cuixiaochen.com/2018/07/08/count-change/</id>
    <published>2018-07-08T06:26:39.000Z</published>
    <updated>2018-07-10T14:43:00.423Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>Counting change 问题来源于 SICP 第一章 1.2 节，书中给出了树形递归解法，并将迭代解法作为了课后练习。本文将会详细解答此题的迭代解法并给出运行时间的对比。<br><a id="more"></a></p><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>给了半美元、四分之一美元、10 美分、5 美分和 1 美分的硬币，将 1 美元换成零钱，一共有多少种不同方式？</p><h1 id="消除递归"><a href="#消除递归" class="headerlink" title="消除递归"></a>消除递归</h1><p>消除递归最通用的方法是使用辅助栈 (auxiliary stack)。简单来说就是将参数推入栈中，然后开始迭代，直到得到我们想要的结果。</p><p>具体到本题，我们将使用自底向上的动态规划 (dynamic programming) 来解决问题，同时因为我们身（天）经（天）百（刷）战（题），很容易在给出一般性的动态规划解法之后进行优化，将所需的栈空间压缩到 O(1)。</p><h1 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h1><p>设 $f(x, n)$ 为使用最小面值的 n 种硬币换 x 美分的方法总数。</p><p>我们从 $f(x, 1)$ 开始分析。此时 $n=1$，表示只使用 1 美分硬币换 x 美分。显然得出，$f(0, 1)=1$。同时（a 为最小面值硬币的面值）：</p>$$    \begin{align*}        \underset{x>0}{f(x, 1)}=\left\{                                    \begin{array}{ll}                                        1, & \text{for } x \bmod a \equiv 0\\                                        0, & \text{for } x \bmod a \neq 0\\                                    \end{array}                                \right.    \end{align*}$$<p>因为此题中最小面值的硬币面值为 1 美分，所以 $\underset{x&gt;0}{f(x, 1)}=1$</p><p>接下来，我们开始推导到 n=2 时到情况，即使用面值最小的 2 种硬币换 x 美分。设 a 为面值第二小的硬币的面值（在此题中为 5）。则有：</p>$$    \begin{align*}        f(x, 2)=\left\{                    \begin{array}{ll}                        f(x, 1)+f(x-a, 2), & \text{for } x > 0\\                        1, & \text{for } x \equiv 0\\                        0, & \text{for } x < 0\\                    \end{array}                \right.    \end{align*}$$<p>同理可给出一般性的方程：$f(x, n)=f(x, n-1)+f(x-a, n)$（其中 a 为 n 种硬币中最大面值硬币的面值）。</p><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>在这里我们给出 scheme 的实现，空间占用为 $O(n^2)$，时间复杂度为 $O(n^2)$</p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">count-change</span> amount)</span><br><span class="line">  (<span class="name">cc</span> amount <span class="number">5</span>))</span><br><span class="line"></span><br><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">cc</span> amount n)</span><br><span class="line">  (<span class="name"><span class="builtin-name">cond</span></span> ((<span class="name"><span class="builtin-name">&lt;</span></span> amount <span class="number">0</span>) <span class="number">0</span>)</span><br><span class="line">        ((<span class="name"><span class="builtin-name">=</span></span> n <span class="number">1</span>) <span class="number">1</span>)</span><br><span class="line">        (<span class="name"><span class="builtin-name">else</span></span> (<span class="name"><span class="builtin-name">+</span></span> (<span class="name">cc</span> amount</span><br><span class="line">                     (<span class="name"><span class="builtin-name">-</span></span> n <span class="number">1</span>))</span><br><span class="line">                 (<span class="name">cc</span> (<span class="name"><span class="builtin-name">-</span></span> amount (<span class="name">get-value</span> n))</span><br><span class="line">                     n)))))</span><br><span class="line"></span><br><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">get-value</span> n)</span><br><span class="line">  (<span class="name"><span class="builtin-name">cond</span></span> ((<span class="name"><span class="builtin-name">=</span></span> n <span class="number">1</span>) <span class="number">1</span>)</span><br><span class="line">        ((<span class="name"><span class="builtin-name">=</span></span> n <span class="number">2</span>) <span class="number">5</span>)</span><br><span class="line">        ((<span class="name"><span class="builtin-name">=</span></span> n <span class="number">3</span>) <span class="number">10</span>)</span><br><span class="line">        ((<span class="name"><span class="builtin-name">=</span></span> n <span class="number">4</span>) <span class="number">25</span>)</span><br><span class="line">        ((<span class="name"><span class="builtin-name">=</span></span> n <span class="number">5</span>) <span class="number">50</span>)))</span><br></pre></td></tr></table></figure><h2 id="改进"><a href="#改进" class="headerlink" title="改进"></a>改进</h2><p>简单改进一下，即可将空间占用降低至 $O(1)$，同时时间复杂度不变</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">待填坑</span><br></pre></td></tr></table></figure><h1 id="与原有树形递归解法的比较"><a href="#与原有树形递归解法的比较" class="headerlink" title="与原有树形递归解法的比较"></a>与原有树形递归解法的比较</h1><h2 id="运行时间"><a href="#运行时间" class="headerlink" title="运行时间"></a>运行时间</h2><p>我们在硬件相同、运行环境相同的情况下分别用这两种解法计算 (count-change 2000)</p><p>树形递归解法：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ time racket -t chapter-1/count-change-tree-recusive.scm</span><br><span class="line">11712101</span><br><span class="line">racket -t chapter-1/count-change-tree-recusive.scm  74.17s user 0.25s system 99% cpu 1:14.45 total</span><br></pre></td></tr></table></figure><p>迭代解法 (DP)：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ time racket -t chapter-1/count-change-iteration.scm</span><br><span class="line">11712101</span><br><span class="line">racket -t chapter-1/count-change-iteration.scm  0.40s user 0.08s system 95% cpu 0.501 total</span><br></pre></td></tr></table></figure><p>可以看到，在 x 为 2000 时，树形递归解法消耗的时间是迭代解法的 148 倍。且由于前者的时间复杂度为指数级别，随着 x 的增加，其消耗时间的增长速度会越来越快。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://stackoverflow.com/questions/1485022/sicp-making-change" target="_blank" rel="noopener">SICP making change</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;p&gt;Counting change 问题来源于 SICP 第一章 1.2 节，书中给出了树形递归解法，并将迭代解法作为了课后练习。本文将会详细解答此题的迭代解法并给出运行时间的对比。&lt;br&gt;
    
    </summary>
    
    
      <category term="sicp" scheme="https://cuixiaochen.com/tags/sicp/"/>
    
      <category term="algorithm" scheme="https://cuixiaochen.com/tags/algorithm/"/>
    
      <category term="dynamic programming" scheme="https://cuixiaochen.com/tags/dynamic-programming/"/>
    
  </entry>
  
  <entry>
    <title>SICP 学习环境的搭建</title>
    <link href="https://cuixiaochen.com/2018/07/07/sicp-env/"/>
    <id>https://cuixiaochen.com/2018/07/07/sicp-env/</id>
    <published>2018-07-07T11:11:23.000Z</published>
    <updated>2018-07-07T12:06:10.936Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>If art interprets our dream, the computer executes them in the guise of programs!<br>– Alan J. Perlis</p></blockquote><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>SICP 从 lisp 语法开始，为我们构成了一个包含计算机理论学科的闭环系统。今天开始我们要借助这本书更深入地理解程序的本质，<br><a id="more"></a></p><p>在运行环境方面，有两种选择：<a href="https://www.gnu.org/software/mit-scheme/" target="_blank" rel="noopener">mit-scheme</a>, <a href="https://racket-lang.org/" target="_blank" rel="noopener">racket</a>。其中 racket 提供图形化界面的 DrRacket 以及命令行界面 racket。笔者倾向于使用命令行界面的 racket 作为运行环境，并使用 vim 作为代码编辑器。接下来我将简单介绍一下这两种运行环境的安装及基本使用，并列出一些讲解进阶使用的文章供大家更舒服地编写 scheme。</p><h1 id="mit-scheme"><a href="#mit-scheme" class="headerlink" title="mit-scheme"></a>mit-scheme</h1><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p><code>brew install mit-scheme</code></p><h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><p>相比于 racket 的 REPL，mit-scheme 缺少了诸如自动补全、快速跳转之类的功能</p><h1 id="racket"><a href="#racket" class="headerlink" title="racket"></a>racket</h1><h2 id="安装-1"><a href="#安装-1" class="headerlink" title="安装"></a>安装</h2><p>可以从 <a href="https://racket-lang.org/" target="_blank" rel="noopener">racket</a> 下载安装包进行安装，也可以直接通过命令行 <code>brew cask install racket</code> 安装完整的 racket 客户端。如果通过 <code>brew install racket</code> 安装，则仅会安装一个最精简的、不包括 DrRacket 的 racket 客户端。</p><h2 id="加载-scheme-源文件"><a href="#加载-scheme-源文件" class="headerlink" title="加载 scheme 源文件"></a>加载 scheme 源文件</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">racket -f &lt;file&gt;  # 详见 racket -h</span><br></pre></td></tr></table></figure><p>或在 REPL 中执行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; (load &quot;example.scm&quot;)</span><br></pre></td></tr></table></figure><h1 id="拓展阅读"><a href="#拓展阅读" class="headerlink" title="拓展阅读"></a>拓展阅读</h1><p>由于笔者还未做深入研究，在这里先列出一些链接。</p><ul><li><a href="https://racket-zh.org/faq" target="_blank" rel="noopener">Racket 常见问题</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;If art interprets our dream, the computer executes them in the guise of programs!&lt;br&gt;– Alan J. Perlis&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;SICP 从 lisp 语法开始，为我们构成了一个包含计算机理论学科的闭环系统。今天开始我们要借助这本书更深入地理解程序的本质，&lt;br&gt;
    
    </summary>
    
    
      <category term="sicp" scheme="https://cuixiaochen.com/tags/sicp/"/>
    
      <category term="scheme" scheme="https://cuixiaochen.com/tags/scheme/"/>
    
      <category term="functional programming" scheme="https://cuixiaochen.com/tags/functional-programming/"/>
    
  </entry>
  
  <entry>
    <title>Cryptography Week 4 - Programming Assignment</title>
    <link href="https://cuixiaochen.com/2018/06/28/cryptography-week-4-program-assigment/"/>
    <id>https://cuixiaochen.com/2018/06/28/cryptography-week-4-program-assigment/</id>
    <published>2018-06-28T12:54:02.000Z</published>
    <updated>2018-08-12T09:52:33.741Z</updated>
    
    <content type="html"><![CDATA[<p>这次我们的目标是利用 <a href="https://en.wikipedia.org/wiki/Padding_oracle_attack" target="_blank" rel="noopener">Padding oracle attack</a> 破解加密过的消息，padding oracle attack 的原理相对来讲比较简单，但是在具体的编程破解过程中需要注意几个问题：</p><ul><li>发送 chosen ciphertext 的间隔时间不能太短，不然会收到 500 响应</li><li>在第一个字节被成功 decrypt 之后，可根据 padding 格式跳过一些字节，节省一些时间<a id="more"></a></li><li>当一个 block 被完全 decrypt 之后，需要将 ciphertext 的最后一个 block 丢弃，使当前 decrypt 的 message block 被服务器认为是最后一个 message block，这样才能利用 padding oracle</li><li>除以上几点外还有一些 trival 的小坑需要留心，在此不做赘述</li></ul><img src="/2018/06/28/cryptography-week-4-program-assigment/pp.png"><p>最终代码：<a href="https://github.com/XiaochenCui/cryptography-homework/blob/master/week_4/padding_oracle.py" target="_blank" rel="noopener">github</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这次我们的目标是利用 &lt;a href=&quot;https://en.wikipedia.org/wiki/Padding_oracle_attack&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Padding oracle attack&lt;/a&gt; 破解加密过的消息，padding oracle attack 的原理相对来讲比较简单，但是在具体的编程破解过程中需要注意几个问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;发送 chosen ciphertext 的间隔时间不能太短，不然会收到 500 响应&lt;/li&gt;
&lt;li&gt;在第一个字节被成功 decrypt 之后，可根据 padding 格式跳过一些字节，节省一些时间
    
    </summary>
    
      <category term="Exercises of Cryptography" scheme="https://cuixiaochen.com/categories/Exercises-of-Cryptography/"/>
    
    
      <category term="cryptography" scheme="https://cuixiaochen.com/tags/cryptography/"/>
    
  </entry>
  
  <entry>
    <title>Cryptography Week 4 - Problem Set</title>
    <link href="https://cuixiaochen.com/2018/06/28/cryptography-week-4-problem-set/"/>
    <id>https://cuixiaochen.com/2018/06/28/cryptography-week-4-problem-set/</id>
    <published>2018-06-28T12:23:36.000Z</published>
    <updated>2018-08-12T06:50:31.612Z</updated>
    
    <content type="html"><![CDATA[<img src="/2018/06/28/cryptography-week-4-problem-set/1.png" width="700"><p>我们可以从 <a href="https://en.wikipedia.org/wiki/Padding_oracle_attack" target="_blank" rel="noopener">Padding oracle attack</a> 中找到伪造密文的思路：<br>设：$1 \oplus x = 5$, IV 中的对应字节为 $y$<br>则：当 $y’ = y \oplus x$ 时，$y \oplus 1 \equiv y’ \oplus 5$<br>所以：将 $y$ 更改为 $y’$ 可使 message 中的相应字节变更为 5<br><a id="more"></a></p><img src="/2018/06/28/cryptography-week-4-problem-set/2.png" width="700"><p>第二个选项中提供的加密系统由于不会输出 bottom，所以一定不提供 authenticated encryption<br>第三个选项中的加密系统只需保持 $c_1 \equiv c_2$，即可成功进行 chosen ciphertext attack</p><img src="/2018/06/28/cryptography-week-4-problem-set/3.png" width="700"><p>Dan Boneh 教授已经强调过无数次：”Never implements encrypt method by yourself”</p><p>4 ~ 10 题都比较简单，在此不做讲解<br><img src="/2018/06/28/cryptography-week-4-problem-set/4.png" width="700"></p><img src="/2018/06/28/cryptography-week-4-problem-set/5.png" width="700"><img src="/2018/06/28/cryptography-week-4-problem-set/6.png" width="700"><img src="/2018/06/28/cryptography-week-4-problem-set/7.png" width="700"><img src="/2018/06/28/cryptography-week-4-problem-set/8.png" width="700"><img src="/2018/06/28/cryptography-week-4-problem-set/9.png" width="700"><img src="/2018/06/28/cryptography-week-4-problem-set/10.png" width="700">]]></content>
    
    <summary type="html">
    
      &lt;img src=&quot;/2018/06/28/cryptography-week-4-problem-set/1.png&quot; width=&quot;700&quot;&gt;
&lt;p&gt;我们可以从 &lt;a href=&quot;https://en.wikipedia.org/wiki/Padding_oracle_attack&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Padding oracle attack&lt;/a&gt; 中找到伪造密文的思路：&lt;br&gt;设：$1 \oplus x = 5$, IV 中的对应字节为 $y$&lt;br&gt;则：当 $y’ = y \oplus x$ 时，$y \oplus 1 \equiv y’ \oplus 5$&lt;br&gt;所以：将 $y$ 更改为 $y’$ 可使 message 中的相应字节变更为 5&lt;br&gt;
    
    </summary>
    
      <category term="Exercises of Cryptography" scheme="https://cuixiaochen.com/categories/Exercises-of-Cryptography/"/>
    
    
      <category term="cryptography" scheme="https://cuixiaochen.com/tags/cryptography/"/>
    
  </entry>
  
  <entry>
    <title>一些关于 Authenticated Encryption 的 paper（二）</title>
    <link href="https://cuixiaochen.com/2018/06/25/some-pater-about-auth-enc-2/"/>
    <id>https://cuixiaochen.com/2018/06/25/some-pater-about-auth-enc-2/</id>
    <published>2018-06-25T14:17:46.000Z</published>
    <updated>2018-06-25T14:27:48.369Z</updated>
    
    <content type="html"><![CDATA[<ul><li><a href="https://eprint.iacr.org/2010/264.pdf" target="_blank" rel="noopener">Cryptographic Extraction and Key Derivation: The HKDF Scheme. H.Krawczyk, Crypto 2010</a></li><li><a href="http://web.cs.ucdavis.edu/~rogaway/papers/keywrap.pdf" target="_blank" rel="noopener">Deterministic Authenticated-Encryption: A Provable-Security Treatment of the Keywrap Problem. P.Rogaway, T.Shrimption, Enrocrypt 2006</a><a id="more"></a></li><li><a href="https://eprint.iacr.org/2003/147.pdf" target="_blank" rel="noopener">A Parallelizable Enciphering Mode. S.Halevi, P.Rogaway, CT-RSA 2004</a></li><li><a href="http://web.cs.ucdavis.edu/~rogaway/papers/offsets.pdf" target="_blank" rel="noopener">Efficient Instantiations of Tweakable Blockciphers and Refinements to Modes OCB and PMAC. P.Rogaway, Asiacrypt 2004</a></li><li><a href="http://web.cs.ucdavis.edu/~rogaway/papers/thorp.pdf" target="_blank" rel="noopener">How to Encipher Messages on a Small Domain: Deterministic Encryption and the Thorp Shuffle. B.Morris, P.Rogaway, T.Stegers, Crypto 2009</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://eprint.iacr.org/2010/264.pdf&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Cryptographic Extraction and Key Derivation: The HKDF Scheme. H.Krawczyk, Crypto 2010&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://web.cs.ucdavis.edu/~rogaway/papers/keywrap.pdf&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Deterministic Authenticated-Encryption: A Provable-Security Treatment of the Keywrap Problem. P.Rogaway, T.Shrimption, Enrocrypt 2006&lt;/a&gt;
    
    </summary>
    
    
      <category term="cryptography" scheme="https://cuixiaochen.com/tags/cryptography/"/>
    
  </entry>
  
  <entry>
    <title>一些关于 Authenticated Encryption 的 paper</title>
    <link href="https://cuixiaochen.com/2018/06/18/some-paper-about-auth-enc/"/>
    <id>https://cuixiaochen.com/2018/06/18/some-paper-about-auth-enc/</id>
    <published>2018-06-18T13:12:28.000Z</published>
    <updated>2018-06-18T13:34:21.507Z</updated>
    
    <content type="html"><![CDATA[<ul><li><a href="https://iacr.org/archive/crypto2001/21390309.pdf" target="_blank" rel="noopener">The Order of Encryption and Authentication for Protecting Communications, H.Krawczyk, Crypto 2001.</a><br>比较了 encrypt-then-MAC 和 MAC-then-encrypt</li><li><a href="http://web.cs.ucdavis.edu/~rogaway/papers/ad.pdf" target="_blank" rel="noopener">Authenticated-Encryption with Associated-Data, P.Rogaway, Proc. of CCS 2002.</a><br>讨论了 OCB<a id="more"></a></li><li><a href="https://www.iacr.org/cryptodb/archive/2003/CRYPTO/1069/1069.pdf" target="_blank" rel="noopener">Password Interception in a SSL/TLS Channel, B.Canvel, A.Hiltgen, S.Vaudenay, M.Vuagnoux, Crypto 2003.</a><br>介绍了 padding oracle attack</li><li><a href="http://www.isg.rhul.ac.uk/~kp/SandPfinal.pdf" target="_blank" rel="noopener">Plaintext Recovery Attacks Against SSH, M.Albrecht, K.Paterson and G.Watson, IEEE S&amp;P 2009.</a><br>介绍了 length attack</li><li><a href="https://www.cs.columbia.edu/~smb/papers/badesp.pdf" target="_blank" rel="noopener">Problem areas for the IP security protocols, S.Bellovin, Usenix Security 1996.</a><br>介绍了一些对于没有提供 integrity 而只是提供 CPA security 的协议的攻击方法，并借此告诉我们在加密中只提供 CPA security 是不安全的</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://iacr.org/archive/crypto2001/21390309.pdf&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;The Order of Encryption and Authentication for Protecting Communications, H.Krawczyk, Crypto 2001.&lt;/a&gt;&lt;br&gt;比较了 encrypt-then-MAC 和 MAC-then-encrypt&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://web.cs.ucdavis.edu/~rogaway/papers/ad.pdf&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Authenticated-Encryption with Associated-Data, P.Rogaway, Proc. of CCS 2002.&lt;/a&gt;&lt;br&gt;讨论了 OCB
    
    </summary>
    
    
      <category term="cryptography" scheme="https://cuixiaochen.com/tags/cryptography/"/>
    
  </entry>
  
  <entry>
    <title>Cryptography Week 3 - Programming Assignment</title>
    <link href="https://cuixiaochen.com/2018/06/12/cryptography-week-3-program-assignment/"/>
    <id>https://cuixiaochen.com/2018/06/12/cryptography-week-3-program-assignment/</id>
    <published>2018-06-11T23:44:36.000Z</published>
    <updated>2018-08-12T06:50:27.562Z</updated>
    
    <content type="html"><![CDATA[<p>本周的任务是实现对大文件的分块哈希，使得浏览器可以在仅收到一部分文件的时候进行 MAC 校验（假设初始 MAC 已通过可信赖的途径分发给浏览器）<br><a id="more"></a></p><img src="/2018/06/12/cryptography-week-3-program-assignment/pa.png"><p>代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> binascii</span><br><span class="line"><span class="keyword">from</span> Crypto.Hash <span class="keyword">import</span> SHA256</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">file_block_generator</span><span class="params">(content)</span>:</span></span><br><span class="line">    block_count, reminder = divmod(len(content), <span class="number">1024</span>)</span><br><span class="line">    <span class="keyword">for</span> block_index <span class="keyword">in</span> range(block_count + <span class="number">1</span>)[::<span class="number">-1</span>]:</span><br><span class="line">        start = block_index * <span class="number">1024</span></span><br><span class="line">        end = <span class="number">1024</span> * (block_index + <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">if</span> end &gt; len(content):</span><br><span class="line">            end = len(content)</span><br><span class="line">        block = content[start:end]</span><br><span class="line">        <span class="keyword">yield</span> block</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">blocked_hash</span><span class="params">(content)</span>:</span></span><br><span class="line">    h = <span class="keyword">None</span></span><br><span class="line">    <span class="keyword">for</span> block <span class="keyword">in</span> file_block_generator(content):</span><br><span class="line">        <span class="keyword">if</span> h:</span><br><span class="line">            block = block + h</span><br><span class="line">        h = SHA256.new()</span><br><span class="line">        h.update(block)</span><br><span class="line">        h = h.digest()</span><br><span class="line">    <span class="keyword">return</span> h</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="keyword">import</span> sys</span><br><span class="line">    f = open(sys.argv[<span class="number">1</span>], <span class="string">'rb'</span>)</span><br><span class="line">    h = blocked_hash(f.read())</span><br><span class="line">    print(binascii.hexlify(h))</span><br></pre></td></tr></table></figure><p>由于本题比较简单，在此不做过多讲解</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本周的任务是实现对大文件的分块哈希，使得浏览器可以在仅收到一部分文件的时候进行 MAC 校验（假设初始 MAC 已通过可信赖的途径分发给浏览器）&lt;br&gt;
    
    </summary>
    
      <category term="Exercises of Cryptography" scheme="https://cuixiaochen.com/categories/Exercises-of-Cryptography/"/>
    
    
      <category term="cryptography" scheme="https://cuixiaochen.com/tags/cryptography/"/>
    
  </entry>
  
  <entry>
    <title>Cryptography Week 3 - Problem Set</title>
    <link href="https://cuixiaochen.com/2018/06/11/cryptography-week-3-problem-set/"/>
    <id>https://cuixiaochen.com/2018/06/11/cryptography-week-3-problem-set/</id>
    <published>2018-06-11T12:55:20.000Z</published>
    <updated>2018-08-12T06:50:23.621Z</updated>
    
    <content type="html"><![CDATA[<p>这周的习题比较简单，不需要过多讲解</p><img src="/2018/06/11/cryptography-week-3-problem-set/1.png" width="700"><a id="more"></a><img src="/2018/06/11/cryptography-week-3-problem-set/2.png" width="700"><img src="/2018/06/11/cryptography-week-3-problem-set/3.png" width="700"><img src="/2018/06/11/cryptography-week-3-problem-set/4.png" width="700"><img src="/2018/06/11/cryptography-week-3-problem-set/5.png" width="700"><img src="/2018/06/11/cryptography-week-3-problem-set/6.png" width="700"><img src="/2018/06/11/cryptography-week-3-problem-set/7.png" width="700"><img src="/2018/06/11/cryptography-week-3-problem-set/8.png" width="700"><img src="/2018/06/11/cryptography-week-3-problem-set/9.png" width="700"><img src="/2018/06/11/cryptography-week-3-problem-set/10.png" width="700">]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这周的习题比较简单，不需要过多讲解&lt;/p&gt;
&lt;img src=&quot;/2018/06/11/cryptography-week-3-problem-set/1.png&quot; width=&quot;700&quot;&gt;
    
    </summary>
    
      <category term="Exercises of Cryptography" scheme="https://cuixiaochen.com/categories/Exercises-of-Cryptography/"/>
    
    
      <category term="cryptography" scheme="https://cuixiaochen.com/tags/cryptography/"/>
    
  </entry>
  
  <entry>
    <title>一些关于 MAC 的 paper</title>
    <link href="https://cuixiaochen.com/2018/06/09/some-paper-about-mac/"/>
    <id>https://cuixiaochen.com/2018/06/09/some-paper-about-mac/</id>
    <published>2018-06-09T06:41:14.000Z</published>
    <updated>2018-06-11T13:27:39.307Z</updated>
    
    <content type="html"><![CDATA[<ul><li><a href="http://web.cs.ucdavis.edu/~rogaway/papers/3k.pdf" target="_blank" rel="noopener">J.Bloack, P.Rogaway: CBC MACs for Arbitray-Length Messages: The Three-Key Constructions. J.Cryptology 18(2):111-131 (2005)</a><br>讲了 CMAC 的基础构型：three key construction</li><li><a href="https://pdfs.semanticscholar.org/0f8a/9d5bf4ef5a3863470f3faf38da2672f0fca1.pdf" target="_blank" rel="noopener">K.Pietrzak: A Tight Bound for EMAC. ICALP (2) 2006: 168-179</a><br>证明了 CBC-MAC 的超集是 PRF<a id="more"></a></li><li><a href="https://iacr.org/archive/eurocrypt2002/23320380/pmac.ps" target="_blank" rel="noopener">J.Block, P.Rogaway: A Block-Cipher Mode of Operation for Parallelizable Message Authentication. EUROCRYPT 2002: 384-397</a><br>讲了 PMAC 的构造</li><li><a href="https://eprint.iacr.org/2006/043.pdf" target="_blank" rel="noopener">M.Bellare: New Proofs for NMAC and HMAC:Security Without Collision-Resistance. CRYPTO 2006:602-619</a><br>谈论了 NMAC 和 HMAC 的安全性</li><li><a href="https://www.iacr.org/archive/eurocrypt2008/49650197/49650197.pdf" target="_blank" rel="noopener">Y.Dodis, K.Pietrazk, P.Puniya: A New Mode of Operation for Block Ciphers and Length-Preserving MACs. EUROCRYPT 2008: 198-219</a><br>这篇论文角度比较新奇，先假设 AES 并不是 PRG，而只是一个 regular unpredictable function，然后在这样的前提下成功地构建出了可用于 long message 的 MAC</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://web.cs.ucdavis.edu/~rogaway/papers/3k.pdf&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;J.Bloack, P.Rogaway: CBC MACs for Arbitray-Length Messages: The Three-Key Constructions. J.Cryptology 18(2):111-131 (2005)&lt;/a&gt;&lt;br&gt;讲了 CMAC 的基础构型：three key construction&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://pdfs.semanticscholar.org/0f8a/9d5bf4ef5a3863470f3faf38da2672f0fca1.pdf&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;K.Pietrzak: A Tight Bound for EMAC. ICALP (2) 2006: 168-179&lt;/a&gt;&lt;br&gt;证明了 CBC-MAC 的超集是 PRF
    
    </summary>
    
    
      <category term="cryptography" scheme="https://cuixiaochen.com/tags/cryptography/"/>
    
  </entry>
  
  <entry>
    <title>Cryptography Week 2 - Programming Assignment</title>
    <link href="https://cuixiaochen.com/2018/06/05/cryptography-week-2-programming-assignment/"/>
    <id>https://cuixiaochen.com/2018/06/05/cryptography-week-2-programming-assignment/</id>
    <published>2018-06-05T01:33:29.000Z</published>
    <updated>2018-08-12T06:50:19.060Z</updated>
    
    <content type="html"><![CDATA[<p>这次我们的任务是实现 CBC 和 CTR，要求用 AES 做为 PRF，所以我们只需要使用 AES 的加密算法。<br><a id="more"></a></p><img src="/2018/06/05/cryptography-week-2-programming-assignment/pa.png"><p>在这里我们仅贴出核心代码，完整代码在：<a href="https://github.com/XiaochenCui/cryptography-homework" target="_blank" rel="noopener">https://github.com/XiaochenCui/cryptography-homework</a></p><h1 id="CBC-Cipher-Block-Chaining"><a href="#CBC-Cipher-Block-Chaining" class="headerlink" title="CBC (Cipher Block Chaining)"></a>CBC (Cipher Block Chaining)</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">encrypt</span><span class="params">(msg, key, iv)</span>:</span></span><br><span class="line">    cipher = AES.new(key, AES.MODE_ECB)</span><br><span class="line">    cipher_block = iv</span><br><span class="line">    ciphertext = iv</span><br><span class="line">    <span class="keyword">for</span> msg_block <span class="keyword">in</span> msg_block_generator(msg, padding=<span class="keyword">True</span>):</span><br><span class="line">        cipher_block = cipher.encrypt(xor(cipher_block, msg_block))</span><br><span class="line">        ciphertext += cipher_block</span><br><span class="line">    <span class="keyword">return</span> ciphertext</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">decrypt</span><span class="params">(cipher_text, key)</span>:</span></span><br><span class="line">    cipher = AES.new(key, AES.MODE_ECB)</span><br><span class="line">    iv, cipher_text = cipher_text[:<span class="number">16</span>], cipher_text[<span class="number">16</span>:]</span><br><span class="line">    msg = <span class="string">b''</span></span><br><span class="line">    <span class="keyword">for</span> cipher_block <span class="keyword">in</span> cipher_block_generator(cipher_text):</span><br><span class="line">        msg_block = xor(cipher.decrypt(cipher_block), iv)</span><br><span class="line">        iv = cipher_block</span><br><span class="line">        msg += msg_block</span><br><span class="line">    <span class="keyword">if</span> msg[<span class="number">-16</span>:] == <span class="string">b'\x16'</span> * <span class="number">16</span>:</span><br><span class="line">        <span class="keyword">return</span> msg[:<span class="number">-16</span>]</span><br><span class="line">    pad_bytes = msg[<span class="number">-1</span>]</span><br><span class="line">    reminder = len(msg) - pad_bytes</span><br><span class="line">    <span class="keyword">if</span> msg[reminder:] == bytes([pad_bytes]) * pad_bytes:</span><br><span class="line">        <span class="keyword">return</span> msg[:reminder]</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        print(<span class="string">'Cipher_text is invalid'</span>)</span><br></pre></td></tr></table></figure><h1 id="CTR-Counter-mode"><a href="#CTR-Counter-mode" class="headerlink" title="CTR (Counter mode)"></a>CTR (Counter mode)</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">encrypt</span><span class="params">(msg, key, iv)</span>:</span></span><br><span class="line">    cipher = AES.new(key, AES.MODE_ECB)</span><br><span class="line">    ciphertext = <span class="string">b''</span></span><br><span class="line">    <span class="keyword">for</span> i, msg_block <span class="keyword">in</span> enumerate(msg_block_generator(msg, padding=<span class="keyword">False</span>)):</span><br><span class="line">        cipher_block = cipher.encrypt(byte.add(iv, i))</span><br><span class="line">        cipher_block = byte.xor(msg_block, cipher_block)</span><br><span class="line">        ciphertext += cipher_block</span><br><span class="line">    <span class="keyword">return</span> ciphertext</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">decrypt</span><span class="params">(cipher_text, key)</span>:</span></span><br><span class="line">    iv, cipher_text = cipher_text[:<span class="number">16</span>], cipher_text[<span class="number">16</span>:]</span><br><span class="line">    cipher = AES.new(key, AES.MODE_ECB)</span><br><span class="line">    msg = <span class="string">b''</span></span><br><span class="line">    <span class="keyword">for</span> i, cipher_block <span class="keyword">in</span> enumerate(cipher_block_generator(cipher_text)):</span><br><span class="line">        iv_encrypted = cipher.encrypt(byte.add(iv, i))</span><br><span class="line">        msg_block = byte.xor(cipher_block, iv_encrypted)</span><br><span class="line">        msg += msg_block</span><br><span class="line">    <span class="keyword">return</span> msg</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这次我们的任务是实现 CBC 和 CTR，要求用 AES 做为 PRF，所以我们只需要使用 AES 的加密算法。&lt;br&gt;
    
    </summary>
    
      <category term="Exercises of Cryptography" scheme="https://cuixiaochen.com/categories/Exercises-of-Cryptography/"/>
    
    
      <category term="cryptography" scheme="https://cuixiaochen.com/tags/cryptography/"/>
    
  </entry>
  
</feed>
