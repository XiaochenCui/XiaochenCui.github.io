<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>XiaochenCui&#39;s Blog</title>
  
  <subtitle>相隔天堑 却不觉遥远</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://cuixiaochen.com/"/>
  <updated>2018-08-12T06:49:52.356Z</updated>
  <id>https://cuixiaochen.com/</id>
  
  <author>
    <name>Xiaochen Cui</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Cryptography Week 5 - Problem Set</title>
    <link href="https://cuixiaochen.com/2018/08/12/cryptography-week-5-problem-set/"/>
    <id>https://cuixiaochen.com/2018/08/12/cryptography-week-5-problem-set/</id>
    <published>2018-08-12T05:42:10.000Z</published>
    <updated>2018-08-12T06:49:52.356Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h1><p>本章的主要内容是密钥交换 (key exchange) 和数论 (number theory)</p><p>密钥交换部分先后讲了 TTP (Trusted third parties), Merkle Puzzle 和 Diffie-Hellman protocol</p><p>数论部分的核心概念是 Modular arithmetic，并由此展开 Fermat’s theorem, Euler’s theorem 等定理，同时辅以 order, generator 等概念来做 Modular arithmetic<br><a id="more"></a></p><h1 id="Exercise-explanation"><a href="#Exercise-explanation" class="headerlink" title="Exercise explanation"></a>Exercise explanation</h1><img src="/2018/08/12/cryptography-week-5-problem-set/1.png" width="700"><p>此题比较简单，要注意两点：</p><ol><li>密钥不能以明文形式发送，所以发送的应该是 ticket 而不是 key</li><li>三者所持有的密钥应该相同</li></ol><img src="/2018/08/12/cryptography-week-5-problem-set/2.png" width="700"><p>1 和 4 两个选项需要求解离散对数，是正确选项</p><img src="/2018/08/12/cryptography-week-5-problem-set/3.png" width="700"><img src="/2018/08/12/cryptography-week-5-problem-set/4.png" width="700"><p>由于 pk 是公开的，所以对 ciphertext 加 MAC 不能防止 MIMA</p><img src="/2018/08/12/cryptography-week-5-problem-set/5.png" width="700"><p>本题应使用 Extended Euclidean Algorithm</p><img src="/2018/08/12/cryptography-week-5-problem-set/6.png" width="700"><p>求解 Modular inversion 同样可以用 Extended Euclidean Algorithm</p><img src="/2018/08/12/cryptography-week-5-problem-set/7.png" width="700"><p>使用 Euler’s theorem</p><img src="/2018/08/12/cryptography-week-5-problem-set/8.png" width="700"><p>使用 Fermat’s theorem</p><img src="/2018/08/12/cryptography-week-5-problem-set/9.png" width="700"><p>使用 Fermat’s theorem</p><img src="/2018/08/12/cryptography-week-5-problem-set/10.png" width="700"><img src="/2018/08/12/cryptography-week-5-problem-set/11.png" width="700"><img src="/2018/08/12/cryptography-week-5-problem-set/12.png" width="700"><img src="/2018/08/12/cryptography-week-5-problem-set/13.png" width="700"><img src="/2018/08/12/cryptography-week-5-problem-set/14.png" width="700"><img src="/2018/08/12/cryptography-week-5-problem-set/15.png" width="700">]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Overview&quot;&gt;&lt;a href=&quot;#Overview&quot; class=&quot;headerlink&quot; title=&quot;Overview&quot;&gt;&lt;/a&gt;Overview&lt;/h1&gt;&lt;p&gt;本章的主要内容是密钥交换 (key exchange) 和数论 (number theory)&lt;/p&gt;
&lt;p&gt;密钥交换部分先后讲了 TTP (Trusted third parties), Merkle Puzzle 和 Diffie-Hellman protocol&lt;/p&gt;
&lt;p&gt;数论部分的核心概念是 Modular arithmetic，并由此展开 Fermat’s theorem, Euler’s theorem 等定理，同时辅以 order, generator 等概念来做 Modular arithmetic&lt;br&gt;
    
    </summary>
    
      <category term="Exercises of Cryptography" scheme="https://cuixiaochen.com/categories/Exercises-of-Cryptography/"/>
    
    
      <category term="cryptography" scheme="https://cuixiaochen.com/tags/cryptography/"/>
    
  </entry>
  
  <entry>
    <title>Proof of Fermat&#39;s Little Theorem</title>
    <link href="https://cuixiaochen.com/2018/07/22/fermat-little-theorem/"/>
    <id>https://cuixiaochen.com/2018/07/22/fermat-little-theorem/</id>
    <published>2018-07-22T14:20:44.000Z</published>
    <updated>2018-08-12T06:49:01.611Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h1><p>Fermat’s little theorem states that if $p$ is a prime number, then for any integer $a$, the number $a^p - a$ is an integer multiple of $p$. In the notation of modular arithmetic, this is expressed as</p>$$    \begin{align*}        a^p \equiv a\: (mod p)    \end{align*}$$<p>To be continued</p><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ul><li><a href="https://en.wikipedia.org/wiki/Fermat%27s_little_theorem" target="_blank" rel="noopener">Fermat’s little theorem</a></li><li><a href="https://primes.utm.edu/notes/proofs/FermatsLittleTheorem.html" target="_blank" rel="noopener">Proof of Fermat’s Little Theorem</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Overview&quot;&gt;&lt;a href=&quot;#Overview&quot; class=&quot;headerlink&quot; title=&quot;Overview&quot;&gt;&lt;/a&gt;Overview&lt;/h1&gt;&lt;p&gt;Fermat’s little theorem states that if $p$ is 
      
    
    </summary>
    
      <category term="Fun with number theory" scheme="https://cuixiaochen.com/categories/Fun-with-number-theory/"/>
    
    
      <category term="number theory" scheme="https://cuixiaochen.com/tags/number-theory/"/>
    
  </entry>
  
  <entry>
    <title>新专栏：数论</title>
    <link href="https://cuixiaochen.com/2018/07/22/number-theorem/"/>
    <id>https://cuixiaochen.com/2018/07/22/number-theorem/</id>
    <published>2018-07-22T13:36:00.000Z</published>
    <updated>2018-08-12T06:49:13.807Z</updated>
    
    <content type="html"><![CDATA[<p>一个新的专栏： <a href="categories/Fun-with-number-theory/">Fun with number theory</a>。这个专栏将从费马小定律开始，讲一些简单的数论知识，并介绍这些数论知识在公钥密码学、素数检查、复数计算等方面的应用</p><p>由于本人也是初学者，错误及遗漏之处还请大家多多指正</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;一个新的专栏： &lt;a href=&quot;categories/Fun-with-number-theory/&quot;&gt;Fun with number theory&lt;/a&gt;。这个专栏将从费马小定律开始，讲一些简单的数论知识，并介绍这些数论知识在公钥密码学、素数检查、复数计算等方面的应用&lt;
      
    
    </summary>
    
      <category term="Fun with number theory" scheme="https://cuixiaochen.com/categories/Fun-with-number-theory/"/>
    
    
      <category term="number theory" scheme="https://cuixiaochen.com/tags/number-theory/"/>
    
  </entry>
  
  <entry>
    <title>Vim Lisp Plugin 推荐</title>
    <link href="https://cuixiaochen.com/2018/07/19/lisp-vim/"/>
    <id>https://cuixiaochen.com/2018/07/19/lisp-vim/</id>
    <published>2018-07-19T13:57:14.000Z</published>
    <updated>2018-07-20T11:34:41.030Z</updated>
    
    <content type="html"><![CDATA[<p>使用 lisp 编程的时候括号是一个很让人头疼的问题，vim 自带的 <a href="https://github.com/vim/vim/blob/master/runtime/plugin/matchparen.vim" target="_blank" rel="noopener">matchparen</a> 可以起到一定的帮助，但是还是有两个小问题：</p><ul><li>需要将光标移到括号上才能知道它对应的是哪个括号</li><li>频繁报错，很影响编码效率</li></ul><p>在这里向大家推荐两个插件帮大家更舒服地编写 lisp<br><a id="more"></a></p><h1 id="auto-pairs"><a href="#auto-pairs" class="headerlink" title="auto-pairs"></a>auto-pairs</h1><p><a href="https://github.com/jiangmiao/auto-pairs" target="_blank" rel="noopener">auto-pairs</a> 是一款非常实用的括号自动补全插件</p><h1 id="rainbow"><a href="#rainbow" class="headerlink" title="rainbow"></a>rainbow</h1><p><a href="https://github.com/luochen1990/rainbow" target="_blank" rel="noopener">rainbow</a> 可以给我们的括号着色，既美观又实用，可谓 lisp 神器</p><h2 id="效果图："><a href="#效果图：" class="headerlink" title="效果图："></a>效果图：</h2><img src="/2018/07/19/lisp-vim/rainbow.png"><h2 id="rainbow-的配置"><a href="#rainbow-的配置" class="headerlink" title="rainbow 的配置"></a>rainbow 的配置</h2><h3 id="使-rainbow-默认开启"><a href="#使-rainbow-默认开启" class="headerlink" title="使 rainbow 默认开启"></a>使 rainbow 默认开启</h3><p>与其他常用的 plugin 不同，rainbow 默认是关闭的，我们可以通过配置使其自动开启：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let g:rainbow_active = 1</span><br></pre></td></tr></table></figure><h3 id="颜色"><a href="#颜色" class="headerlink" title="颜色"></a>颜色</h3><p>rainbow 默认配置的颜色辨识度不高，我为其配置了更有辨识度的配色方案：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let g:rainbow_conf = &#123;</span><br><span class="line">\    &apos;guifgs&apos;: [&apos;royalblue3&apos;, &apos;darkorange3&apos;, &apos;seagreen3&apos;, &apos;firebrick&apos;],</span><br><span class="line">\    &apos;ctermfgs&apos;: [&apos;darkred&apos;, &apos;blue&apos;, &apos;yellow&apos;, &apos;cyan&apos;, &apos;magenta&apos;, &apos;brown&apos;],</span><br><span class="line">\&#125;</span><br></pre></td></tr></table></figure><h3 id="只为特定类型的文件启用"><a href="#只为特定类型的文件启用" class="headerlink" title="只为特定类型的文件启用"></a>只为特定类型的文件启用</h3><p>由于 rainbow 会破坏 markdown 等文件编辑界面，在这里我们通过配置使其只为特定文件开启：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Plug &apos;luochen1990/rainbow&apos;, &#123; &apos;for&apos;: &apos;scheme&apos;  &#125;</span><br></pre></td></tr></table></figure><p>我使用的插件管理器是 <a href="https://github.com/junegunn/vim-plug" target="_blank" rel="noopener">plug</a>，由于目前只在编写 scheme 的需要写比较多的括号，所以只为 scheme 源代码文件开启彩虹配色</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;使用 lisp 编程的时候括号是一个很让人头疼的问题，vim 自带的 &lt;a href=&quot;https://github.com/vim/vim/blob/master/runtime/plugin/matchparen.vim&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;matchparen&lt;/a&gt; 可以起到一定的帮助，但是还是有两个小问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;需要将光标移到括号上才能知道它对应的是哪个括号&lt;/li&gt;
&lt;li&gt;频繁报错，很影响编码效率&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在这里向大家推荐两个插件帮大家更舒服地编写 lisp&lt;br&gt;
    
    </summary>
    
    
      <category term="vim" scheme="https://cuixiaochen.com/tags/vim/"/>
    
      <category term="lisp" scheme="https://cuixiaochen.com/tags/lisp/"/>
    
  </entry>
  
  <entry>
    <title>一些关于 Key Exchange Protocol 的 paper</title>
    <link href="https://cuixiaochen.com/2018/07/15/key-exchange-paper/"/>
    <id>https://cuixiaochen.com/2018/07/15/key-exchange-paper/</id>
    <published>2018-07-15T13:48:13.000Z</published>
    <updated>2018-07-15T13:56:10.703Z</updated>
    
    <content type="html"><![CDATA[<ul><li><a href="https://www.boazbarak.org/Papers/merkle.pdf" target="_blank" rel="noopener">Mer Puzzles are Optimal, B.Barak, M.Mahmoody-Ghidary, Crypto ‘09</a><br>当我们只使用 symmetric ciphers 和 hash functions 的时候，Merkle Puzzles 是 key exchange 的最优选择。即我们无法在这样的限制下超越 quadratic gap</li><li><a href="http://www.shoup.net/papers/skey.pdf" target="_blank" rel="noopener">On Formal models of key exchange (sections 7-9) V.Shoup, 1999</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://www.boazbarak.org/Papers/merkle.pdf&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Mer Puzzles are Optimal, B.Barak, M.Mahmoody-G
      
    
    </summary>
    
    
      <category term="cryptography" scheme="https://cuixiaochen.com/tags/cryptography/"/>
    
  </entry>
  
  <entry>
    <title>Closed Form Expression For Fibonacci Numbers 的证明</title>
    <link href="https://cuixiaochen.com/2018/07/11/fib/"/>
    <id>https://cuixiaochen.com/2018/07/11/fib/</id>
    <published>2018-07-10T23:11:39.000Z</published>
    <updated>2018-07-22T13:23:00.797Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h1><p>此题出自 SICP 第一章练习题 1.13</p><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>Prove that $Fib(n)$ is the closest integer to $\phi^n/\sqrt5$, where $\phi=(1+\sqrt5)/2$. Hint: Let $\psi=(1-\sqrt5)/2$. Use induction and definition of the Fibonacci numbers (see section 1.2.2) to prove that $Fib(n)=(\phi^n-\psi^n)/\sqrt5$.<br><a id="more"></a></p><h1 id="证明"><a href="#证明" class="headerlink" title="证明"></a>证明</h1><h2 id="phi-和-psi-的性质"><a href="#phi-和-psi-的性质" class="headerlink" title="$\phi$ 和 $\psi$ 的性质"></a>$\phi$ 和 $\psi$ 的性质</h2><p>由题目所设 $\phi=(1+\sqrt5)/2$ 易得：</p>$$    \begin{align*}        \phi^2 = \phi+1 \\        1/\phi + 1 = \phi \\    \end{align*}$$<p>由 $\psi=(1-\sqrt5)/2$ 易得：</p>$$    \begin{align*}        \psi^2 = \psi + 1 \\        1/\psi + 1 = \psi\\    \end{align*}$$<h2 id="归纳证明法证明-Fib-n-phi-n-psi-n-sqrt5"><a href="#归纳证明法证明-Fib-n-phi-n-psi-n-sqrt5" class="headerlink" title="归纳证明法证明 $Fib(n)=(\phi^n-\psi^n)/\sqrt5$"></a>归纳证明法证明 $Fib(n)=(\phi^n-\psi^n)/\sqrt5$</h2><p>$\text{for } n=0:$<br>$$    \begin{align*}        (\phi^n-\psi^n)/\sqrt5 =& (\phi^0-\psi^0)/\sqrt5 \\                               =& 0 \\    \end{align*}$$</p><p>$\text{for } n=1:$<br>$$    \begin{align*}        (\phi^n-\psi^n)/\sqrt5 =& (\phi^1-\psi^1)/\sqrt5 \\                               =& 1 \\    \end{align*}$$</p><p>$\text{for } n=2:$<br>$$    \begin{align*}        (\phi^n-\psi^n)/\sqrt5 =& (\phi^2-\psi^2)/\sqrt5 \\                               =& 1 \\    \end{align*}$$</p><p>现在开始采用归纳证明法</p><p>假设下列两个等式成立：</p>$$    \begin{align*}        Fib(n)   =& (\phi^n-\psi^n)/\sqrt5 \\        Fib(n-1) =& (\phi^{n-1}-\psi^{n-1})/\sqrt5 \\    \end{align*}$$<p>我们现在需要证明以下等式成立：</p>$$    \begin{align*}        Fib(n+1) =& (\phi^{n+1}-\psi^{n+1})/\sqrt5 \\    \end{align*}$$<p>通过 Fibonacci 序列的性质与之前提到的 $\phi$ 和 $\psi$ 的性质，可给出如下的证明过程：</p>$$    \begin{align*}        Fib(n+1) =& Fib(n) + Fib(n-1) \\                 =& (\phi^n-\psi^n)/\sqrt5 + (\phi^{n-1}-\psi^{n-1})/\sqrt5 \\                 =& ((\phi^n-\psi^n) + (\phi^{n-1}-\psi^{n-1}))/\sqrt5 \\                 =& ((\phi^n+\phi^{n-1}) - (\psi^n+\psi^{n-1}))/\sqrt5 \\                 =& (\phi^{n+1} * (\phi^{-1}+\phi^{-2}) - \psi^{n+1} * (\psi^{-1}+\psi^{-2})) / \sqrt5 \\                 =& (\phi^{n+1} * \phi^{-1} * (1+\phi^{-1}) - \psi^{n+1} * \psi^{-1} * (1+\psi^{-1})) / \sqrt5 \\                 =& (\phi^{n+1} * 1/\phi * (1+1/\phi) - \psi^{n+1} * 1/\psi * (1+1/\psi)) / \sqrt5 \\                 =& (\phi^{n+1} * 1/\phi * \phi - \psi^{n+1} * 1/\psi * \psi) / \sqrt5 \\                 =& (\phi^{n+1} - \psi^{n+1}) / \sqrt5 \\    \end{align*}$$<h2 id="最后一步"><a href="#最后一步" class="headerlink" title="最后一步"></a>最后一步</h2><p>我们首先简单转化一下之前证明过的等式：</p>$$    \begin{align*}        Fib(n) =& (\phi^n-\psi^n)/\sqrt5 \\        Fib(n) =& \phi^n/\sqrt5 - \psi^n/\sqrt5 \\        \phi^n/\sqrt5 - Fib(n) =& \psi^n/\sqrt5 \\    \end{align*}$$<p>做以上变换是因为我们的目的是证明 $Fib(n)$ 和 $\phi^n/\sqrt5$ 之间的关系。现在我们需要做的就是证明这两者的差总是小于 $1/2$。即证明：</p>$$    \begin{align*}        \psi^n/\sqrt5 \leq 1/2    \end{align*}$$<p>即证明：</p>$$    \begin{align*}        \psi^n \leq \sqrt5/2    \end{align*}$$<p>由于 $\psi=(1-\sqrt5)/2$，我们可以计算求得：</p>$$    \begin{align*}        \psi \approx -0.618304    \end{align*}$$<p>由于 $Fib(n)$ 总是整数且 $n \geq 0$，$|\psi| &lt; 1$，可以得出：</p>$$    \begin{align*}        \psi^n \leq 1    \end{align*}$$<p>同时：</p>$$    \begin{align*}        \sqrt5/2 \approx 1.118    \end{align*}$$<p>因为 $\psi^n \leq 1$，且 $\sqrt5/2 &gt; 1$，所以：</p>$$    \begin{align*}        \psi^n < \sqrt5/2    \end{align*}$$<p>因此，$Fib(n)$ 是最接近 $\psi^n/\sqrt5$ 的整数。</p><p>完。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="http://www.billthelizard.com/2009/12/sicp-exercise-113-fibonacci-and-golden.html" target="_blank" rel="noopener">Bill the Lizard</a></li><li><a href="https://en.wikipedia.org/wiki/Fibonacci_number#Closed-form_expression" target="_blank" rel="noopener">Fibonacci number</a></li><li><a href="https://artofproblemsolving.com/wiki/index.php?title=Binet%27s_Formula" target="_blank" rel="noopener">Binet’s Formula - Art of Problem Solving</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;概览&quot;&gt;&lt;a href=&quot;#概览&quot; class=&quot;headerlink&quot; title=&quot;概览&quot;&gt;&lt;/a&gt;概览&lt;/h1&gt;&lt;p&gt;此题出自 SICP 第一章练习题 1.13&lt;/p&gt;
&lt;h1 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h1&gt;&lt;p&gt;Prove that $Fib(n)$ is the closest integer to $\phi^n/\sqrt5$, where $\phi=(1+\sqrt5)/2$. Hint: Let $\psi=(1-\sqrt5)/2$. Use induction and definition of the Fibonacci numbers (see section 1.2.2) to prove that $Fib(n)=(\phi^n-\psi^n)/\sqrt5$.&lt;br&gt;
    
    </summary>
    
      <category term="Fun with number theory" scheme="https://cuixiaochen.com/categories/Fun-with-number-theory/"/>
    
    
      <category term="sicp" scheme="https://cuixiaochen.com/tags/sicp/"/>
    
      <category term="number theory" scheme="https://cuixiaochen.com/tags/number-theory/"/>
    
  </entry>
  
  <entry>
    <title>Counting Change 问题的详细分析及解答</title>
    <link href="https://cuixiaochen.com/2018/07/08/count-change/"/>
    <id>https://cuixiaochen.com/2018/07/08/count-change/</id>
    <published>2018-07-08T06:26:39.000Z</published>
    <updated>2018-07-10T14:43:00.423Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>Counting change 问题来源于 SICP 第一章 1.2 节，书中给出了树形递归解法，并将迭代解法作为了课后练习。本文将会详细解答此题的迭代解法并给出运行时间的对比。<br><a id="more"></a></p><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>给了半美元、四分之一美元、10 美分、5 美分和 1 美分的硬币，将 1 美元换成零钱，一共有多少种不同方式？</p><h1 id="消除递归"><a href="#消除递归" class="headerlink" title="消除递归"></a>消除递归</h1><p>消除递归最通用的方法是使用辅助栈 (auxiliary stack)。简单来说就是将参数推入栈中，然后开始迭代，直到得到我们想要的结果。</p><p>具体到本题，我们将使用自底向上的动态规划 (dynamic programming) 来解决问题，同时因为我们身（天）经（天）百（刷）战（题），很容易在给出一般性的动态规划解法之后进行优化，将所需的栈空间压缩到 O(1)。</p><h1 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h1><p>设 $f(x, n)$ 为使用最小面值的 n 种硬币换 x 美分的方法总数。</p><p>我们从 $f(x, 1)$ 开始分析。此时 $n=1$，表示只使用 1 美分硬币换 x 美分。显然得出，$f(0, 1)=1$。同时（a 为最小面值硬币的面值）：</p>$$    \begin{align*}        \underset{x>0}{f(x, 1)}=\left\{                                    \begin{array}{ll}                                        1, & \text{for } x \bmod a \equiv 0\\                                        0, & \text{for } x \bmod a \neq 0\\                                    \end{array}                                \right.    \end{align*}$$<p>因为此题中最小面值的硬币面值为 1 美分，所以 $\underset{x&gt;0}{f(x, 1)}=1$</p><p>接下来，我们开始推导到 n=2 时到情况，即使用面值最小的 2 种硬币换 x 美分。设 a 为面值第二小的硬币的面值（在此题中为 5）。则有：</p>$$    \begin{align*}        f(x, 2)=\left\{                    \begin{array}{ll}                        f(x, 1)+f(x-a, 2), & \text{for } x > 0\\                        1, & \text{for } x \equiv 0\\                        0, & \text{for } x < 0\\                    \end{array}                \right.    \end{align*}$$<p>同理可给出一般性的方程：$f(x, n)=f(x, n-1)+f(x-a, n)$（其中 a 为 n 种硬币中最大面值硬币的面值）。</p><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>在这里我们给出 scheme 的实现，空间占用为 $O(n^2)$，时间复杂度为 $O(n^2)$</p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">count-change</span> amount)</span><br><span class="line">  (<span class="name">cc</span> amount <span class="number">5</span>))</span><br><span class="line"></span><br><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">cc</span> amount n)</span><br><span class="line">  (<span class="name"><span class="builtin-name">cond</span></span> ((<span class="name"><span class="builtin-name">&lt;</span></span> amount <span class="number">0</span>) <span class="number">0</span>)</span><br><span class="line">        ((<span class="name"><span class="builtin-name">=</span></span> n <span class="number">1</span>) <span class="number">1</span>)</span><br><span class="line">        (<span class="name"><span class="builtin-name">else</span></span> (<span class="name"><span class="builtin-name">+</span></span> (<span class="name">cc</span> amount</span><br><span class="line">                     (<span class="name"><span class="builtin-name">-</span></span> n <span class="number">1</span>))</span><br><span class="line">                 (<span class="name">cc</span> (<span class="name"><span class="builtin-name">-</span></span> amount (<span class="name">get-value</span> n))</span><br><span class="line">                     n)))))</span><br><span class="line"></span><br><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">get-value</span> n)</span><br><span class="line">  (<span class="name"><span class="builtin-name">cond</span></span> ((<span class="name"><span class="builtin-name">=</span></span> n <span class="number">1</span>) <span class="number">1</span>)</span><br><span class="line">        ((<span class="name"><span class="builtin-name">=</span></span> n <span class="number">2</span>) <span class="number">5</span>)</span><br><span class="line">        ((<span class="name"><span class="builtin-name">=</span></span> n <span class="number">3</span>) <span class="number">10</span>)</span><br><span class="line">        ((<span class="name"><span class="builtin-name">=</span></span> n <span class="number">4</span>) <span class="number">25</span>)</span><br><span class="line">        ((<span class="name"><span class="builtin-name">=</span></span> n <span class="number">5</span>) <span class="number">50</span>)))</span><br></pre></td></tr></table></figure><h2 id="改进"><a href="#改进" class="headerlink" title="改进"></a>改进</h2><p>简单改进一下，即可将空间占用降低至 $O(1)$，同时时间复杂度不变</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">待填坑</span><br></pre></td></tr></table></figure><h1 id="与原有树形递归解法的比较"><a href="#与原有树形递归解法的比较" class="headerlink" title="与原有树形递归解法的比较"></a>与原有树形递归解法的比较</h1><h2 id="运行时间"><a href="#运行时间" class="headerlink" title="运行时间"></a>运行时间</h2><p>我们在硬件相同、运行环境相同的情况下分别用这两种解法计算 (count-change 2000)</p><p>树形递归解法：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ time racket -t chapter-1/count-change-tree-recusive.scm</span><br><span class="line">11712101</span><br><span class="line">racket -t chapter-1/count-change-tree-recusive.scm  74.17s user 0.25s system 99% cpu 1:14.45 total</span><br></pre></td></tr></table></figure><p>迭代解法 (DP)：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ time racket -t chapter-1/count-change-iteration.scm</span><br><span class="line">11712101</span><br><span class="line">racket -t chapter-1/count-change-iteration.scm  0.40s user 0.08s system 95% cpu 0.501 total</span><br></pre></td></tr></table></figure><p>可以看到，在 x 为 2000 时，树形递归解法消耗的时间是迭代解法的 148 倍。且由于前者的时间复杂度为指数级别，随着 x 的增加，其消耗时间的增长速度会越来越快。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://stackoverflow.com/questions/1485022/sicp-making-change" target="_blank" rel="noopener">SICP making change</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;p&gt;Counting change 问题来源于 SICP 第一章 1.2 节，书中给出了树形递归解法，并将迭代解法作为了课后练习。本文将会详细解答此题的迭代解法并给出运行时间的对比。&lt;br&gt;
    
    </summary>
    
    
      <category term="sicp" scheme="https://cuixiaochen.com/tags/sicp/"/>
    
      <category term="algorithm" scheme="https://cuixiaochen.com/tags/algorithm/"/>
    
      <category term="dynamic programming" scheme="https://cuixiaochen.com/tags/dynamic-programming/"/>
    
  </entry>
  
  <entry>
    <title>SICP 学习环境的搭建</title>
    <link href="https://cuixiaochen.com/2018/07/07/sicp-env/"/>
    <id>https://cuixiaochen.com/2018/07/07/sicp-env/</id>
    <published>2018-07-07T11:11:23.000Z</published>
    <updated>2018-07-07T12:06:10.936Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>If art interprets our dream, the computer executes them in the guise of programs!<br>– Alan J. Perlis</p></blockquote><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>SICP 从 lisp 语法开始，为我们构成了一个包含计算机理论学科的闭环系统。今天开始我们要借助这本书更深入地理解程序的本质，<br><a id="more"></a></p><p>在运行环境方面，有两种选择：<a href="https://www.gnu.org/software/mit-scheme/" target="_blank" rel="noopener">mit-scheme</a>, <a href="https://racket-lang.org/" target="_blank" rel="noopener">racket</a>。其中 racket 提供图形化界面的 DrRacket 以及命令行界面 racket。笔者倾向于使用命令行界面的 racket 作为运行环境，并使用 vim 作为代码编辑器。接下来我将简单介绍一下这两种运行环境的安装及基本使用，并列出一些讲解进阶使用的文章供大家更舒服地编写 scheme。</p><h1 id="mit-scheme"><a href="#mit-scheme" class="headerlink" title="mit-scheme"></a>mit-scheme</h1><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p><code>brew install mit-scheme</code></p><h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><p>相比于 racket 的 REPL，mit-scheme 缺少了诸如自动补全、快速跳转之类的功能</p><h1 id="racket"><a href="#racket" class="headerlink" title="racket"></a>racket</h1><h2 id="安装-1"><a href="#安装-1" class="headerlink" title="安装"></a>安装</h2><p>可以从 <a href="https://racket-lang.org/" target="_blank" rel="noopener">racket</a> 下载安装包进行安装，也可以直接通过命令行 <code>brew cask install racket</code> 安装完整的 racket 客户端。如果通过 <code>brew install racket</code> 安装，则仅会安装一个最精简的、不包括 DrRacket 的 racket 客户端。</p><h2 id="加载-scheme-源文件"><a href="#加载-scheme-源文件" class="headerlink" title="加载 scheme 源文件"></a>加载 scheme 源文件</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">racket -f &lt;file&gt;  # 详见 racket -h</span><br></pre></td></tr></table></figure><p>或在 REPL 中执行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; (load &quot;example.scm&quot;)</span><br></pre></td></tr></table></figure><h1 id="拓展阅读"><a href="#拓展阅读" class="headerlink" title="拓展阅读"></a>拓展阅读</h1><p>由于笔者还未做深入研究，在这里先列出一些链接。</p><ul><li><a href="https://racket-zh.org/faq" target="_blank" rel="noopener">Racket 常见问题</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;If art interprets our dream, the computer executes them in the guise of programs!&lt;br&gt;– Alan J. Perlis&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;SICP 从 lisp 语法开始，为我们构成了一个包含计算机理论学科的闭环系统。今天开始我们要借助这本书更深入地理解程序的本质，&lt;br&gt;
    
    </summary>
    
    
      <category term="sicp" scheme="https://cuixiaochen.com/tags/sicp/"/>
    
      <category term="scheme" scheme="https://cuixiaochen.com/tags/scheme/"/>
    
      <category term="functional programming" scheme="https://cuixiaochen.com/tags/functional-programming/"/>
    
  </entry>
  
  <entry>
    <title>Cryptography Week 4 - Programming Project</title>
    <link href="https://cuixiaochen.com/2018/06/28/cryptography-week-4-program-assigment/"/>
    <id>https://cuixiaochen.com/2018/06/28/cryptography-week-4-program-assigment/</id>
    <published>2018-06-28T12:54:02.000Z</published>
    <updated>2018-08-12T06:50:35.592Z</updated>
    
    <content type="html"><![CDATA[<p>这次我们的目标是利用 <a href="https://en.wikipedia.org/wiki/Padding_oracle_attack" target="_blank" rel="noopener">Padding oracle attack</a> 破解加密过的消息，padding oracle attack 的原理相对来讲比较简单，但是在具体的编程破解过程中需要注意几个问题：</p><ul><li>发送 chosen ciphertext 的间隔时间不能太短，不然会收到 500 响应</li><li>在第一个字节被成功 decrypt 之后，可根据 padding 格式跳过一些字节，节省一些时间<a id="more"></a></li><li>当一个 block 被完全 decrypt 之后，需要将 ciphertext 的最后一个 block 丢弃，使当前 decrypt 的 message block 被服务器认为是最后一个 message block，这样才能利用 padding oracle</li><li>除以上几点外还有一些 trival 的小坑需要留心，在此不做赘述</li></ul><img src="/2018/06/28/cryptography-week-4-program-assigment/pp.png"><p>最终代码：<a href="https://github.com/XiaochenCui/cryptography-homework/blob/master/week_4/padding_oracle.py" target="_blank" rel="noopener">github</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这次我们的目标是利用 &lt;a href=&quot;https://en.wikipedia.org/wiki/Padding_oracle_attack&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Padding oracle attack&lt;/a&gt; 破解加密过的消息，padding oracle attack 的原理相对来讲比较简单，但是在具体的编程破解过程中需要注意几个问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;发送 chosen ciphertext 的间隔时间不能太短，不然会收到 500 响应&lt;/li&gt;
&lt;li&gt;在第一个字节被成功 decrypt 之后，可根据 padding 格式跳过一些字节，节省一些时间
    
    </summary>
    
      <category term="Exercises of Cryptography" scheme="https://cuixiaochen.com/categories/Exercises-of-Cryptography/"/>
    
    
      <category term="cryptography" scheme="https://cuixiaochen.com/tags/cryptography/"/>
    
  </entry>
  
  <entry>
    <title>Cryptography Week 4 - Problem Set</title>
    <link href="https://cuixiaochen.com/2018/06/28/cryptography-week-4-problem-set/"/>
    <id>https://cuixiaochen.com/2018/06/28/cryptography-week-4-problem-set/</id>
    <published>2018-06-28T12:23:36.000Z</published>
    <updated>2018-08-12T06:50:31.612Z</updated>
    
    <content type="html"><![CDATA[<img src="/2018/06/28/cryptography-week-4-problem-set/1.png" width="700"><p>我们可以从 <a href="https://en.wikipedia.org/wiki/Padding_oracle_attack" target="_blank" rel="noopener">Padding oracle attack</a> 中找到伪造密文的思路：<br>设：$1 \oplus x = 5$, IV 中的对应字节为 $y$<br>则：当 $y’ = y \oplus x$ 时，$y \oplus 1 \equiv y’ \oplus 5$<br>所以：将 $y$ 更改为 $y’$ 可使 message 中的相应字节变更为 5<br><a id="more"></a></p><img src="/2018/06/28/cryptography-week-4-problem-set/2.png" width="700"><p>第二个选项中提供的加密系统由于不会输出 bottom，所以一定不提供 authenticated encryption<br>第三个选项中的加密系统只需保持 $c_1 \equiv c_2$，即可成功进行 chosen ciphertext attack</p><img src="/2018/06/28/cryptography-week-4-problem-set/3.png" width="700"><p>Dan Boneh 教授已经强调过无数次：”Never implements encrypt method by yourself”</p><p>4 ~ 10 题都比较简单，在此不做讲解<br><img src="/2018/06/28/cryptography-week-4-problem-set/4.png" width="700"></p><img src="/2018/06/28/cryptography-week-4-problem-set/5.png" width="700"><img src="/2018/06/28/cryptography-week-4-problem-set/6.png" width="700"><img src="/2018/06/28/cryptography-week-4-problem-set/7.png" width="700"><img src="/2018/06/28/cryptography-week-4-problem-set/8.png" width="700"><img src="/2018/06/28/cryptography-week-4-problem-set/9.png" width="700"><img src="/2018/06/28/cryptography-week-4-problem-set/10.png" width="700">]]></content>
    
    <summary type="html">
    
      &lt;img src=&quot;/2018/06/28/cryptography-week-4-problem-set/1.png&quot; width=&quot;700&quot;&gt;
&lt;p&gt;我们可以从 &lt;a href=&quot;https://en.wikipedia.org/wiki/Padding_oracle_attack&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Padding oracle attack&lt;/a&gt; 中找到伪造密文的思路：&lt;br&gt;设：$1 \oplus x = 5$, IV 中的对应字节为 $y$&lt;br&gt;则：当 $y’ = y \oplus x$ 时，$y \oplus 1 \equiv y’ \oplus 5$&lt;br&gt;所以：将 $y$ 更改为 $y’$ 可使 message 中的相应字节变更为 5&lt;br&gt;
    
    </summary>
    
      <category term="Exercises of Cryptography" scheme="https://cuixiaochen.com/categories/Exercises-of-Cryptography/"/>
    
    
      <category term="cryptography" scheme="https://cuixiaochen.com/tags/cryptography/"/>
    
  </entry>
  
  <entry>
    <title>一些关于 Authenticated Encryption 的 paper（二）</title>
    <link href="https://cuixiaochen.com/2018/06/25/some-pater-about-auth-enc-2/"/>
    <id>https://cuixiaochen.com/2018/06/25/some-pater-about-auth-enc-2/</id>
    <published>2018-06-25T14:17:46.000Z</published>
    <updated>2018-06-25T14:27:48.369Z</updated>
    
    <content type="html"><![CDATA[<ul><li><a href="https://eprint.iacr.org/2010/264.pdf" target="_blank" rel="noopener">Cryptographic Extraction and Key Derivation: The HKDF Scheme. H.Krawczyk, Crypto 2010</a></li><li><a href="http://web.cs.ucdavis.edu/~rogaway/papers/keywrap.pdf" target="_blank" rel="noopener">Deterministic Authenticated-Encryption: A Provable-Security Treatment of the Keywrap Problem. P.Rogaway, T.Shrimption, Enrocrypt 2006</a><a id="more"></a></li><li><a href="https://eprint.iacr.org/2003/147.pdf" target="_blank" rel="noopener">A Parallelizable Enciphering Mode. S.Halevi, P.Rogaway, CT-RSA 2004</a></li><li><a href="http://web.cs.ucdavis.edu/~rogaway/papers/offsets.pdf" target="_blank" rel="noopener">Efficient Instantiations of Tweakable Blockciphers and Refinements to Modes OCB and PMAC. P.Rogaway, Asiacrypt 2004</a></li><li><a href="http://web.cs.ucdavis.edu/~rogaway/papers/thorp.pdf" target="_blank" rel="noopener">How to Encipher Messages on a Small Domain: Deterministic Encryption and the Thorp Shuffle. B.Morris, P.Rogaway, T.Stegers, Crypto 2009</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://eprint.iacr.org/2010/264.pdf&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Cryptographic Extraction and Key Derivation: The HKDF Scheme. H.Krawczyk, Crypto 2010&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://web.cs.ucdavis.edu/~rogaway/papers/keywrap.pdf&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Deterministic Authenticated-Encryption: A Provable-Security Treatment of the Keywrap Problem. P.Rogaway, T.Shrimption, Enrocrypt 2006&lt;/a&gt;
    
    </summary>
    
    
      <category term="cryptography" scheme="https://cuixiaochen.com/tags/cryptography/"/>
    
  </entry>
  
  <entry>
    <title>Architecture - 东风集团传统能源车平台</title>
    <link href="https://cuixiaochen.com/2018/06/21/architect-fuel/"/>
    <id>https://cuixiaochen.com/2018/06/21/architect-fuel/</id>
    <published>2018-06-21T15:03:16.000Z</published>
    <updated>2018-06-25T14:30:28.355Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h1><p>本文将主要从消息总线、存储方案、查询方案以及指令下发等方面介绍东风传统能源车平台的技术架构。<br><a id="more"></a><br>此平台主要提供对车辆的监控及控制。</p><h2 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h2><p>通信协议基于 TCP 并兼容 GB32960。</p><p>注 1：由于硬件限制，我们并未使用 mqtt。</p><p>注 2：由于保密级别的限制，在此不对协议做过多介绍</p><h2 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h2><p>现有平台的容量预计为 10 万台车。车载终端在正常行驶情况下每 30 秒向平台发送一次数据包，数据包中包含车辆的实时信息，数据包大小按 1KB 记。当车辆出现异常时，车载终端以每秒一次的频率向平台发送报警数据包。</p><p>由此可粗略估算得出：QPS 大概为 5000，每天新增数据包总量大约为 500G。</p><h1 id="基础设施选择"><a href="#基础设施选择" class="headerlink" title="基础设施选择"></a>基础设施选择</h1><h2 id="存储"><a href="#存储" class="headerlink" title="存储"></a>存储</h2><p>由于所有数据包都需要存储以在日后做车况分析、数据统计以及故障排查，所以我们只能选择列式存储，具体的方案是使用 HBASE。业务逻辑相关的数据使用 MySQL/PostgreSQL 进行存储。</p><h2 id="消息总线"><a href="#消息总线" class="headerlink" title="消息总线"></a>消息总线</h2><p>由于该平台对 availability 和 durability 的要求极高，所以必须要有一个稳健的消息总线，数据包在到达系统的第一时间进入消息总线，以保证系统的 reliability 以及 fault tolerance。</p><p>消息总线的选择主要有 <a href="https://kafka.apache.org/documentation/#introduction" target="_blank" rel="noopener">Kafka</a>, <a href="https://redis.io/topics/streams-intro" target="_blank" rel="noopener">Redis Streams</a> 以及 <a href="https://www.rabbitmq.com/" target="_blank" rel="noopener">Rabbitmq</a>。</p><p>Kafka 的主要优势在于数据可靠性以及较高的性能。</p><p>Redis Streams 的主要优势在于其性能最高，而且由于我们的系统本来也需要 Redis 的支持，选择 Redis Streams 可以利用已有的 infrastructure。但由于 Redis 在接受到数据后先将其贮存到内存，随后再通过持久化的方式写入磁盘，可靠性不如 Kafka。</p><p>Rabbitmq 的主要优势在于其完整支持 <a href="https://www.amqp.org/" target="_blank" rel="noopener">AMQP</a> 协议，但其开启持久化后性能不足。</p><p>综上，我们选择 Apache Kafka 作为系统的消息总线。</p><h2 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h2><p>使用 Redis</p><h1 id="系统架构"><a href="#系统架构" class="headerlink" title="系统架构"></a>系统架构</h1><h2 id="架构简图"><a href="#架构简图" class="headerlink" title="架构简图"></a>架构简图</h2><p>系统架构简图如下，有部分省略</p><img src="/2018/06/21/architect-fuel/fuel.png"><p>未完待续</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;概览&quot;&gt;&lt;a href=&quot;#概览&quot; class=&quot;headerlink&quot; title=&quot;概览&quot;&gt;&lt;/a&gt;概览&lt;/h1&gt;&lt;p&gt;本文将主要从消息总线、存储方案、查询方案以及指令下发等方面介绍东风传统能源车平台的技术架构。&lt;br&gt;
    
    </summary>
    
    
      <category term="architecture" scheme="https://cuixiaochen.com/tags/architecture/"/>
    
  </entry>
  
  <entry>
    <title>一些关于 Authenticated Encryption 的 paper</title>
    <link href="https://cuixiaochen.com/2018/06/18/some-paper-about-auth-enc/"/>
    <id>https://cuixiaochen.com/2018/06/18/some-paper-about-auth-enc/</id>
    <published>2018-06-18T13:12:28.000Z</published>
    <updated>2018-06-18T13:34:21.507Z</updated>
    
    <content type="html"><![CDATA[<ul><li><a href="https://iacr.org/archive/crypto2001/21390309.pdf" target="_blank" rel="noopener">The Order of Encryption and Authentication for Protecting Communications, H.Krawczyk, Crypto 2001.</a><br>比较了 encrypt-then-MAC 和 MAC-then-encrypt</li><li><a href="http://web.cs.ucdavis.edu/~rogaway/papers/ad.pdf" target="_blank" rel="noopener">Authenticated-Encryption with Associated-Data, P.Rogaway, Proc. of CCS 2002.</a><br>讨论了 OCB<a id="more"></a></li><li><a href="https://www.iacr.org/cryptodb/archive/2003/CRYPTO/1069/1069.pdf" target="_blank" rel="noopener">Password Interception in a SSL/TLS Channel, B.Canvel, A.Hiltgen, S.Vaudenay, M.Vuagnoux, Crypto 2003.</a><br>介绍了 padding oracle attack</li><li><a href="http://www.isg.rhul.ac.uk/~kp/SandPfinal.pdf" target="_blank" rel="noopener">Plaintext Recovery Attacks Against SSH, M.Albrecht, K.Paterson and G.Watson, IEEE S&amp;P 2009.</a><br>介绍了 length attack</li><li><a href="https://www.cs.columbia.edu/~smb/papers/badesp.pdf" target="_blank" rel="noopener">Problem areas for the IP security protocols, S.Bellovin, Usenix Security 1996.</a><br>介绍了一些对于没有提供 integrity 而只是提供 CPA security 的协议的攻击方法，并借此告诉我们在加密中只提供 CPA security 是不安全的</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://iacr.org/archive/crypto2001/21390309.pdf&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;The Order of Encryption and Authentication for Protecting Communications, H.Krawczyk, Crypto 2001.&lt;/a&gt;&lt;br&gt;比较了 encrypt-then-MAC 和 MAC-then-encrypt&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://web.cs.ucdavis.edu/~rogaway/papers/ad.pdf&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Authenticated-Encryption with Associated-Data, P.Rogaway, Proc. of CCS 2002.&lt;/a&gt;&lt;br&gt;讨论了 OCB
    
    </summary>
    
    
      <category term="cryptography" scheme="https://cuixiaochen.com/tags/cryptography/"/>
    
  </entry>
  
  <entry>
    <title>Cryptography Week 3 - Programming Assignment</title>
    <link href="https://cuixiaochen.com/2018/06/12/cryptography-week-3-program-assignment/"/>
    <id>https://cuixiaochen.com/2018/06/12/cryptography-week-3-program-assignment/</id>
    <published>2018-06-11T23:44:36.000Z</published>
    <updated>2018-08-12T06:50:27.562Z</updated>
    
    <content type="html"><![CDATA[<p>本周的任务是实现对大文件的分块哈希，使得浏览器可以在仅收到一部分文件的时候进行 MAC 校验（假设初始 MAC 已通过可信赖的途径分发给浏览器）<br><a id="more"></a></p><img src="/2018/06/12/cryptography-week-3-program-assignment/pa.png"><p>代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> binascii</span><br><span class="line"><span class="keyword">from</span> Crypto.Hash <span class="keyword">import</span> SHA256</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">file_block_generator</span><span class="params">(content)</span>:</span></span><br><span class="line">    block_count, reminder = divmod(len(content), <span class="number">1024</span>)</span><br><span class="line">    <span class="keyword">for</span> block_index <span class="keyword">in</span> range(block_count + <span class="number">1</span>)[::<span class="number">-1</span>]:</span><br><span class="line">        start = block_index * <span class="number">1024</span></span><br><span class="line">        end = <span class="number">1024</span> * (block_index + <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">if</span> end &gt; len(content):</span><br><span class="line">            end = len(content)</span><br><span class="line">        block = content[start:end]</span><br><span class="line">        <span class="keyword">yield</span> block</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">blocked_hash</span><span class="params">(content)</span>:</span></span><br><span class="line">    h = <span class="keyword">None</span></span><br><span class="line">    <span class="keyword">for</span> block <span class="keyword">in</span> file_block_generator(content):</span><br><span class="line">        <span class="keyword">if</span> h:</span><br><span class="line">            block = block + h</span><br><span class="line">        h = SHA256.new()</span><br><span class="line">        h.update(block)</span><br><span class="line">        h = h.digest()</span><br><span class="line">    <span class="keyword">return</span> h</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="keyword">import</span> sys</span><br><span class="line">    f = open(sys.argv[<span class="number">1</span>], <span class="string">'rb'</span>)</span><br><span class="line">    h = blocked_hash(f.read())</span><br><span class="line">    print(binascii.hexlify(h))</span><br></pre></td></tr></table></figure><p>由于本题比较简单，在此不做过多讲解</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本周的任务是实现对大文件的分块哈希，使得浏览器可以在仅收到一部分文件的时候进行 MAC 校验（假设初始 MAC 已通过可信赖的途径分发给浏览器）&lt;br&gt;
    
    </summary>
    
      <category term="Exercises of Cryptography" scheme="https://cuixiaochen.com/categories/Exercises-of-Cryptography/"/>
    
    
      <category term="cryptography" scheme="https://cuixiaochen.com/tags/cryptography/"/>
    
  </entry>
  
  <entry>
    <title>Cryptography Week 3 - Problem Set</title>
    <link href="https://cuixiaochen.com/2018/06/11/cryptography-week-3-problem-set/"/>
    <id>https://cuixiaochen.com/2018/06/11/cryptography-week-3-problem-set/</id>
    <published>2018-06-11T12:55:20.000Z</published>
    <updated>2018-08-12T06:50:23.621Z</updated>
    
    <content type="html"><![CDATA[<p>这周的习题比较简单，不需要过多讲解</p><img src="/2018/06/11/cryptography-week-3-problem-set/1.png" width="700"><a id="more"></a><img src="/2018/06/11/cryptography-week-3-problem-set/2.png" width="700"><img src="/2018/06/11/cryptography-week-3-problem-set/3.png" width="700"><img src="/2018/06/11/cryptography-week-3-problem-set/4.png" width="700"><img src="/2018/06/11/cryptography-week-3-problem-set/5.png" width="700"><img src="/2018/06/11/cryptography-week-3-problem-set/6.png" width="700"><img src="/2018/06/11/cryptography-week-3-problem-set/7.png" width="700"><img src="/2018/06/11/cryptography-week-3-problem-set/8.png" width="700"><img src="/2018/06/11/cryptography-week-3-problem-set/9.png" width="700"><img src="/2018/06/11/cryptography-week-3-problem-set/10.png" width="700">]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这周的习题比较简单，不需要过多讲解&lt;/p&gt;
&lt;img src=&quot;/2018/06/11/cryptography-week-3-problem-set/1.png&quot; width=&quot;700&quot;&gt;
    
    </summary>
    
      <category term="Exercises of Cryptography" scheme="https://cuixiaochen.com/categories/Exercises-of-Cryptography/"/>
    
    
      <category term="cryptography" scheme="https://cuixiaochen.com/tags/cryptography/"/>
    
  </entry>
  
  <entry>
    <title>一些关于 MAC 的 paper</title>
    <link href="https://cuixiaochen.com/2018/06/09/some-paper-about-mac/"/>
    <id>https://cuixiaochen.com/2018/06/09/some-paper-about-mac/</id>
    <published>2018-06-09T06:41:14.000Z</published>
    <updated>2018-06-11T13:27:39.307Z</updated>
    
    <content type="html"><![CDATA[<ul><li><a href="http://web.cs.ucdavis.edu/~rogaway/papers/3k.pdf" target="_blank" rel="noopener">J.Bloack, P.Rogaway: CBC MACs for Arbitray-Length Messages: The Three-Key Constructions. J.Cryptology 18(2):111-131 (2005)</a><br>讲了 CMAC 的基础构型：three key construction</li><li><a href="https://pdfs.semanticscholar.org/0f8a/9d5bf4ef5a3863470f3faf38da2672f0fca1.pdf" target="_blank" rel="noopener">K.Pietrzak: A Tight Bound for EMAC. ICALP (2) 2006: 168-179</a><br>证明了 CBC-MAC 的超集是 PRF<a id="more"></a></li><li><a href="https://iacr.org/archive/eurocrypt2002/23320380/pmac.ps" target="_blank" rel="noopener">J.Block, P.Rogaway: A Block-Cipher Mode of Operation for Parallelizable Message Authentication. EUROCRYPT 2002: 384-397</a><br>讲了 PMAC 的构造</li><li><a href="https://eprint.iacr.org/2006/043.pdf" target="_blank" rel="noopener">M.Bellare: New Proofs for NMAC and HMAC:Security Without Collision-Resistance. CRYPTO 2006:602-619</a><br>谈论了 NMAC 和 HMAC 的安全性</li><li><a href="https://www.iacr.org/archive/eurocrypt2008/49650197/49650197.pdf" target="_blank" rel="noopener">Y.Dodis, K.Pietrazk, P.Puniya: A New Mode of Operation for Block Ciphers and Length-Preserving MACs. EUROCRYPT 2008: 198-219</a><br>这篇论文角度比较新奇，先假设 AES 并不是 PRG，而只是一个 regular unpredictable function，然后在这样的前提下成功地构建出了可用于 long message 的 MAC</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://web.cs.ucdavis.edu/~rogaway/papers/3k.pdf&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;J.Bloack, P.Rogaway: CBC MACs for Arbitray-Length Messages: The Three-Key Constructions. J.Cryptology 18(2):111-131 (2005)&lt;/a&gt;&lt;br&gt;讲了 CMAC 的基础构型：three key construction&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://pdfs.semanticscholar.org/0f8a/9d5bf4ef5a3863470f3faf38da2672f0fca1.pdf&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;K.Pietrzak: A Tight Bound for EMAC. ICALP (2) 2006: 168-179&lt;/a&gt;&lt;br&gt;证明了 CBC-MAC 的超集是 PRF
    
    </summary>
    
    
      <category term="cryptography" scheme="https://cuixiaochen.com/tags/cryptography/"/>
    
  </entry>
  
  <entry>
    <title>Cryptography Week 2 - Programming Assignment</title>
    <link href="https://cuixiaochen.com/2018/06/05/cryptography-week-2-programming-assignment/"/>
    <id>https://cuixiaochen.com/2018/06/05/cryptography-week-2-programming-assignment/</id>
    <published>2018-06-05T01:33:29.000Z</published>
    <updated>2018-08-12T06:50:19.060Z</updated>
    
    <content type="html"><![CDATA[<p>这次我们的任务是实现 CBC 和 CTR，要求用 AES 做为 PRF，所以我们只需要使用 AES 的加密算法。<br><a id="more"></a></p><img src="/2018/06/05/cryptography-week-2-programming-assignment/pa.png"><p>在这里我们仅贴出核心代码，完整代码在：<a href="https://github.com/XiaochenCui/cryptography-homework" target="_blank" rel="noopener">https://github.com/XiaochenCui/cryptography-homework</a></p><h1 id="CBC-Cipher-Block-Chaining"><a href="#CBC-Cipher-Block-Chaining" class="headerlink" title="CBC (Cipher Block Chaining)"></a>CBC (Cipher Block Chaining)</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">encrypt</span><span class="params">(msg, key, iv)</span>:</span></span><br><span class="line">    cipher = AES.new(key, AES.MODE_ECB)</span><br><span class="line">    cipher_block = iv</span><br><span class="line">    ciphertext = iv</span><br><span class="line">    <span class="keyword">for</span> msg_block <span class="keyword">in</span> msg_block_generator(msg, padding=<span class="keyword">True</span>):</span><br><span class="line">        cipher_block = cipher.encrypt(xor(cipher_block, msg_block))</span><br><span class="line">        ciphertext += cipher_block</span><br><span class="line">    <span class="keyword">return</span> ciphertext</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">decrypt</span><span class="params">(cipher_text, key)</span>:</span></span><br><span class="line">    cipher = AES.new(key, AES.MODE_ECB)</span><br><span class="line">    iv, cipher_text = cipher_text[:<span class="number">16</span>], cipher_text[<span class="number">16</span>:]</span><br><span class="line">    msg = <span class="string">b''</span></span><br><span class="line">    <span class="keyword">for</span> cipher_block <span class="keyword">in</span> cipher_block_generator(cipher_text):</span><br><span class="line">        msg_block = xor(cipher.decrypt(cipher_block), iv)</span><br><span class="line">        iv = cipher_block</span><br><span class="line">        msg += msg_block</span><br><span class="line">    <span class="keyword">if</span> msg[<span class="number">-16</span>:] == <span class="string">b'\x16'</span> * <span class="number">16</span>:</span><br><span class="line">        <span class="keyword">return</span> msg[:<span class="number">-16</span>]</span><br><span class="line">    pad_bytes = msg[<span class="number">-1</span>]</span><br><span class="line">    reminder = len(msg) - pad_bytes</span><br><span class="line">    <span class="keyword">if</span> msg[reminder:] == bytes([pad_bytes]) * pad_bytes:</span><br><span class="line">        <span class="keyword">return</span> msg[:reminder]</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        print(<span class="string">'Cipher_text is invalid'</span>)</span><br></pre></td></tr></table></figure><h1 id="CTR-Counter-mode"><a href="#CTR-Counter-mode" class="headerlink" title="CTR (Counter mode)"></a>CTR (Counter mode)</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">encrypt</span><span class="params">(msg, key, iv)</span>:</span></span><br><span class="line">    cipher = AES.new(key, AES.MODE_ECB)</span><br><span class="line">    ciphertext = <span class="string">b''</span></span><br><span class="line">    <span class="keyword">for</span> i, msg_block <span class="keyword">in</span> enumerate(msg_block_generator(msg, padding=<span class="keyword">False</span>)):</span><br><span class="line">        cipher_block = cipher.encrypt(byte.add(iv, i))</span><br><span class="line">        cipher_block = byte.xor(msg_block, cipher_block)</span><br><span class="line">        ciphertext += cipher_block</span><br><span class="line">    <span class="keyword">return</span> ciphertext</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">decrypt</span><span class="params">(cipher_text, key)</span>:</span></span><br><span class="line">    iv, cipher_text = cipher_text[:<span class="number">16</span>], cipher_text[<span class="number">16</span>:]</span><br><span class="line">    cipher = AES.new(key, AES.MODE_ECB)</span><br><span class="line">    msg = <span class="string">b''</span></span><br><span class="line">    <span class="keyword">for</span> i, cipher_block <span class="keyword">in</span> enumerate(cipher_block_generator(cipher_text)):</span><br><span class="line">        iv_encrypted = cipher.encrypt(byte.add(iv, i))</span><br><span class="line">        msg_block = byte.xor(cipher_block, iv_encrypted)</span><br><span class="line">        msg += msg_block</span><br><span class="line">    <span class="keyword">return</span> msg</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这次我们的任务是实现 CBC 和 CTR，要求用 AES 做为 PRF，所以我们只需要使用 AES 的加密算法。&lt;br&gt;
    
    </summary>
    
      <category term="Exercises of Cryptography" scheme="https://cuixiaochen.com/categories/Exercises-of-Cryptography/"/>
    
    
      <category term="cryptography" scheme="https://cuixiaochen.com/tags/cryptography/"/>
    
  </entry>
  
  <entry>
    <title>Cryptography Week 2 - Problem Set</title>
    <link href="https://cuixiaochen.com/2018/05/20/Cryptography-Week-2-Problem-Set/"/>
    <id>https://cuixiaochen.com/2018/05/20/Cryptography-Week-2-Problem-Set/</id>
    <published>2018-05-20T13:44:00.000Z</published>
    <updated>2018-08-12T06:50:09.815Z</updated>
    
    <content type="html"><![CDATA[<img src="/2018/05/20/Cryptography-Week-2-Problem-Set/1.png" width="700"><a id="more"></a>$2^{128}\approx3.4e+38$<img src="/2018/05/20/Cryptography-Week-2-Problem-Set/2.png" width="700"><img src="/2018/05/20/Cryptography-Week-2-Problem-Set/3.png" width="700"><img src="/2018/05/20/Cryptography-Week-2-Problem-Set/4.png" width="700">$$\begin{align*}        m = 0^{64}:& \\        &L_1 = 0^{32} R_1 \\        &R_1 = 0^{32} \oplus F(k_1, 0^{32}) \\        &L_2 = 0^{32} \oplus F(k_1, 0^{32}) \\        &R_2 = 0^{32} \oplus F(k_2, 0^{32}\oplus F(k_1,0^{32})) \\        m = 1^{32}0^{32}:& \\        &L_1 = 0^{32} R_1 \\        &R_1 = 1^{32} \oplus F(k_1, 0^{32}) \\        &L_2 = 1^{32} \oplus F(k_1, 0^{32}) \\        &R_2 = 0^{32} \oplus F(k_2, 1^{32}\oplus F(k_1,0^{32})) \\\end{align*}$$<p>Therefore:<br>$$    \underset{m = 0^{64}}{L_2} \oplus \underset{m = 1^{32}0^{32}}{L_2} \equiv 1^{32}$$</p><img src="/2018/05/20/Cryptography-Week-2-Problem-Set/5.png" width="700">$$\begin{align*}        c' &= F(k, IV \oplus m_1) \\        &= F(k, F(k, c_0) \oplus c_0 \oplus c_0) \\        &= F(k, F(k, c_0) \oplus c_0 \oplus F(k, c_0)) \\        &= F(k, c_0)\end{align*}$$<p>Therefore:<br>$$    c_1 = c'_0$$</p><img src="/2018/05/20/Cryptography-Week-2-Problem-Set/6.png" width="700"><img src="/2018/05/20/Cryptography-Week-2-Problem-Set/7.png" width="700"><img src="/2018/05/20/Cryptography-Week-2-Problem-Set/8.png" width="700"><img src="/2018/05/20/Cryptography-Week-2-Problem-Set/9.png" width="700">]]></content>
    
    <summary type="html">
    
      &lt;img src=&quot;/2018/05/20/Cryptography-Week-2-Problem-Set/1.png&quot; width=&quot;700&quot;&gt;
    
    </summary>
    
      <category term="Exercises of Cryptography" scheme="https://cuixiaochen.com/categories/Exercises-of-Cryptography/"/>
    
    
      <category term="cryptography" scheme="https://cuixiaochen.com/tags/cryptography/"/>
    
  </entry>
  
  <entry>
    <title>Redis 学习资料</title>
    <link href="https://cuixiaochen.com/2018/04/30/redis-study-references/"/>
    <id>https://cuixiaochen.com/2018/04/30/redis-study-references/</id>
    <published>2018-04-30T15:11:04.000Z</published>
    <updated>2018-07-15T15:01:27.028Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Source-Code"><a href="#Source-Code" class="headerlink" title="Source Code"></a>Source Code</h1><ul><li><a href="https://github.com/antirez/redis" target="_blank" rel="noopener">redis</a></li><li><a href="https://github.com/huangz1990/redis-3.0-annotated" target="_blank" rel="noopener">redis-3.0-annotated</a><br>带有详细注释的 Redis 3.0 代码<a id="more"></a></li></ul><h1 id="Books"><a href="#Books" class="headerlink" title="Books"></a>Books</h1><ul><li><a href="https://book.douban.com/subject/25900156/" target="_blank" rel="noopener">Redis 设计与实现</a><br>通俗易懂，深入浅出</li><li><a href="https://book.douban.com/subject/26612779/" target="_blank" rel="noopener">Redis 实战</a><br>入门书籍，价值不大</li></ul><h1 id="Archives"><a href="#Archives" class="headerlink" title="Archives"></a>Archives</h1><h2 id="Redlock"><a href="#Redlock" class="headerlink" title="Redlock"></a>Redlock</h2><ul><li><a href="https://redis.io/topics/distlock" target="_blank" rel="noopener">Distributed locks with Redis</a></li><li><a href="https://martin.kleppmann.com/2016/02/08/how-to-do-distributed-locking.html" target="_blank" rel="noopener">How to do distributed locking - Martin Kleppmann</a></li><li><a href="http://antirez.com/news/101" target="_blank" rel="noopener">Is Redlock safe? - antirez</a></li><li><a href="http://zhangtielei.com/posts/blog-redlock-reasoning.html" target="_blank" rel="noopener">基于 Redis 的分布式锁到底安全吗（上）？</a></li><li><a href="http://zhangtielei.com/posts/blog-redlock-reasoning-part2.html" target="_blank" rel="noopener">基于 Redis 的分布式锁到底安全吗（下）？</a></li></ul><h2 id="RESP-REdis-Serialization-Protocol"><a href="#RESP-REdis-Serialization-Protocol" class="headerlink" title="RESP(REdis Serialization Protocol)"></a>RESP(REdis Serialization Protocol)</h2><ul><li><a href="https://redis.io/topics/protocol" target="_blank" rel="noopener">Redis Protocol specification</a></li><li><a href="https://www.compose.com/articles/how-to-talk-raw-redis/" target="_blank" rel="noopener">How to talk raw Redis</a></li></ul><h2 id="Persistence"><a href="#Persistence" class="headerlink" title="Persistence"></a>Persistence</h2><ul><li><a href="http://oldblog.antirez.com/post/redis-persistence-demystified.html" target="_blank" rel="noopener">Redis persistence demystified</a></li></ul><h2 id="RDB"><a href="#RDB" class="headerlink" title="RDB"></a>RDB</h2><ul><li><a href="https://github.com/sripathikrishnan/redis-rdb-tools/wiki/Redis-RDB-Dump-File-Format" target="_blank" rel="noopener">Redis RDB Dump File Format</a></li><li><a href="https://github.com/sripathikrishnan/redis-rdb-tools/blob/master/docs/RDB_Version_History.textile" target="_blank" rel="noopener">Redis RDB Version History</a></li></ul><h1 id="Maillists"><a href="#Maillists" class="headerlink" title="Maillists"></a>Maillists</h1><ul><li><a href="https://groups.google.com/forum/#!forum/redis-db" target="_blank" rel="noopener">Redis DB</a></li><li><a href="https://groups.google.com/forum/#!forum/redis-dev" target="_blank" rel="noopener">redis-dev</a></li></ul><h1 id="Twitter"><a href="#Twitter" class="headerlink" title="Twitter"></a>Twitter</h1><ul><li><a href="https://twitter.com/redisfeed" target="_blank" rel="noopener">@redisfeed</a></li><li><a href="https://twitter.com/antirez" target="_blank" rel="noopener">@antirez</a></li></ul><p>待补充</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Source-Code&quot;&gt;&lt;a href=&quot;#Source-Code&quot; class=&quot;headerlink&quot; title=&quot;Source Code&quot;&gt;&lt;/a&gt;Source Code&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/antirez/redis&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;redis&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/huangz1990/redis-3.0-annotated&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;redis-3.0-annotated&lt;/a&gt;&lt;br&gt;带有详细注释的 Redis 3.0 代码
    
    </summary>
    
    
      <category term="redis" scheme="https://cuixiaochen.com/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>操作系统学习笔记：第一章习题及解答</title>
    <link href="https://cuixiaochen.com/2018/04/17/operation-system-study-notes-2/"/>
    <id>https://cuixiaochen.com/2018/04/17/operation-system-study-notes-2/</id>
    <published>2018-04-17T14:00:19.000Z</published>
    <updated>2018-04-30T15:42:06.866Z</updated>
    
    <content type="html"><![CDATA[<h1 id="习题"><a href="#习题" class="headerlink" title="习题"></a>习题</h1><ol><li><p>什么是 multiprogramming？</p><p>在第二代操作系统（如 7094 机）上，若当前作业因等待磁带或其他 I/O 操作而暂停时，CPU 就只能简单地原地踏步直至该 I/O 完成。在很多情况下，I/O 操作等待的时间通常占到 80% ~ 90%, 所以要通过 multiprogramming 的方式来减少 CPU 资源的浪费。</p><p>具体方案就是将内存分成多个部分，每个部分存放不同的作业（如下图所示），当一个作业等待 I/O 操作完成时，另一个作业可以使用 CPU。如果内存中可以同时存放足够多的作业，则 CPU 利用率可以接近 100%。（注意：在内存中同时驻留多个作业需要特殊的硬件来对其进行保护，以避免作业对信息被窃取或受到攻击。）</p><img src="/2018/04/17/operation-system-study-notes-2/multi-programmed-system.jpg"><a id="more"></a></li><li><p>什么是 SPOOLing ？你是否认为将来的个人计算机会把 SPOOLing 作为标准功能？</p><p>SPOOLing(Simultaneous Peripheral operation on line), 指任何时刻当一个作业运行结束时，操作系统就能将一个新作业从磁盘读出，装进空出来的内存区域运行。（该技术同时也用于输出）</p><p>具体答案还有待后续章节的学习，但我认为 SPOOLing 不会在将来被当作个人计算机的标准功能。因为其需要等一个作业运行结束，意味着用户在操作计算机时会经常遇到计算机卡住的情况，从而带给用户不好的体验（相比于后来出现的分时系统）。</p></li><li><p>在早期计算机中，每个字节的读写直接由 CPU 处理（即没有 <a href="https://www.techopedia.com/definition/2767/direct-memory-access-dma" target="_blank" rel="noopener">DMA</a> ）。对于多道程序而言这种组织方式有什么含义？</p><p>使用多道程序的主要目的是使计算机在等待 I/O 操作时可以完成别的工作。如果没有 DMA ，I/O 操作将会完全占用 CPU 。因此，这种方式不利于对于 CPU 的充分利用。</p></li><li><p>系列计算机的思想在 20 世纪 60 年代由 IBM 引入进 System/360 大型机。现在这种思想已经消亡了还是继续活跃着？</p><p>依然存在。例如 Intel 生产的 Pentium I，II，III 和 4 仅仅在价格、速度等属性上有所不同，但它们的体系结构都是兼容的。</p></li><li><p>缓慢采用 GUI 的一个原因是支持它的硬件的成本（高昂）。为了支持 25 行 80 列字符的单色文本屏幕应该需要多少视颊 RAM? 对于 1024x768 像素 24 位色彩位图需要多少视频 RAM? 在 1980 年 ($5/KB) 这些 RAM 的成本是多少？现在它的成本是多少？</p><p>25*80=2000bytes≈2kb, 1024*768*3=2359296bytes≈2359kb。在 1980 年，它们将会分布耗费 $10 和 $11520。现在的 RAM 的成本小于 $1/MB。</p></li><li><p>在建立一个操作系统时有几个设计目的，例如资源利用、及时性、健壮性等。请列举两个可能互相矛盾的设计目的。</p><p>资源利用与缓存。资源利用要求尽量满足当前所运行程序的资源要求，而缓存则要求缓存频繁访问的数据。所以当前进程可能会占用过多的资源导致缓存空间不足。</p></li><li><p>下面的哪一条指令只能在内核态中使用？<br>a) 禁止所有的中断。<br>b) 读日期 - 时间时钟。<br>c) 设置日期 - 时间时钟。<br>d) 改变存储器映像。</p><p>a,c,d</p></li><li><p>考虑一个有两个 CPU 的系统，并且每一个 CPU 有两个线程（超线程）。假设有三个程序 P0，P1，P2，分別以运行时间 5ms，10ms，20ms 开始。运行这些程序需要多少时间？假设这三个程序都是 100% 限于 CPU，在运行时无阻塞，并且一旦设定就不改变 CPU。</p><p>运行这些程序所需的时间取决于这些程序以怎样的组合被分配到 CPU 上，一共有以下 4 种情况：</p><ol><li>(P0,P1) and P2 =&gt; (5ms + 10ms) and 20ms =&gt; 20ms</li><li>(P0,P2) and P1 =&gt; (5ms + 20ms) and 10ms =&gt; 25ms</li><li>(P1,P2) and P0 =&gt; (10ms + 20ms) and 50ms =&gt; 30ms</li><li>(P0,P1,P2) =&gt; (5ms + 10ms + 20ms) =&gt; 35m</li></ol></li><li><p>一台计算机有一个四级流水线，每一级都花费相同的时间执行其工作，即 1ns。这台机器每秒可执行多少条指令？</p><p>1s / (1ns/ 条） = $10 ^ 9$ 条</p></li><li><p>假设一个计算机系统有高速缓存、内存 (RAM) 以及磁盘，操作系统用虚拟内存。读取缓存中的一个词需要 2ns，RAM 需要 10ns，磁盘需要 10ms。如果缓存的命中率是 95%，内存的是（缓存失效时）99%，读取一个词的平均时间是多少？</p><p>$2ns\times95\%+10ns\times(1-95\%)\times99\%+10ms\times(1-95\%)(1-99\%) = 5002.395ns$</p></li><li><p>一位校对人员注意到在一部将要出版的操作系统教科书手稿中有一个多次出现的拼写错误。这本书大致有 700 页。每页 50 行，一行 80 个字符。若把文稿用电子扫描，那么，主副本进入图 1-9 中的每个存储系统的层次要花费多少时间？对于内存储方式，考虑所给定的存取时间是每次一个字符，对于磁盘设备，假定存取时间是每次一个 1024 字符的盘块，而对于磁带，假设给定开始时间后的存取时间和磁盘存取时间相同。</p><img src="/2018/04/17/operation-system-study-notes-2/caching-stuff.jpg"><p>答：原稿包含 80*50*700 = 2800000 字符。如果这些字符放在寄存器中，cpu 访问它们需要 2.8ms（在这里我们假设这些字符可以一次性放入寄存器），在 Cache 中需要 5.6ms，在内存中需要 28ms。整本书大约有 2700 个 1024 字节的数据块，因此从磁盘读取它们大约需要 27 秒，从磁带读取大约需要 2 分钟 7 秒。（根据书中的数据计算）</p></li><li><p>在用户程序进行一个系统调用，以读写磁盘文件时，该程序提供指示说明了所需要的文件，一个指向数据缓冲区的指针以及计数。然后，控制权转给操作系统，它调用相关的驱动程序。假设驱动程序启动磁盘并且直到中断发生才终止。在从磁盘读的情况下，很明显，调用者会被阻塞（因为文件中没有数据）。在向磁盘写时会发生什么情况？需要把调用者阻塞一直等到磁盘传送完成为止吗？</p><p>这道题暂时无法解答</p></li><li><p>什么是陷阱指令？在操作系统中解释它的用途。</p><p>TRAP 指令将处理器的执行模式从用户态切换到内核态，它使用户可以调用操作系统内核中的函数。</p></li><li><p>陷阱和中断的主要差别是什么？</p><p>陷阱是由程序造成的，而且与程序同步；中断由外部事件和时钟造成。</p></li><li><p>在分时系统中为什么需要进程表？在只有一个进程存在的个人计算机系统中，该进程控制整个机器直到进程结束，这种机器也需要进程表吗？</p><p>进程表的作用是在进程暂时被挂起时保存进程打开的所有文件的当前读取位置。单进程操作系统中不需要进程表，因为进程不会被挂起。</p></li><li><p>说明有没有理由要在一个非空的目录中安装一个文件系统？如果要这样做，如何做？</p><p>这道题暂时无法解答</p></li><li><p>在一个操作系统中系统调用的目的是什么？</p><p>进入内核，调用操作系统服务</p></li><li><p>对于下列系统调用 ，给出引起失败的条件：fork、exec 以及 unlink。</p><p>fork: fork 失败的主要原因有两个：(a) 系统中已经有了太多的进程（进程表中没有空闲的槽）；(b) 该实际用户 ID 的进程总数超过了系统限制（在 POSIX.1 中，CHILD_MAX 代表了每个实际用户 ID 的最大进程数，可在运行时通过调用 <code>long sysconf(int _SC_CHLID_MAX)</code> 取得）<br>exec: 给定的 pathname/filename 不合法，这里的不合法有两种情况：(a) 不存在，(b) 存在但不是一个可用的 shell 脚本<br>unlink: 待我详细阅读相关资料后再给出解答</p></li><li><p>在 <code>count = write(fd, buffer, nbytes);</code> 调用中，能在 count 中而不是 nbytes 中返回值吗？如果能，为什么？</p><p>能，因为当 write 调用失败时返回 -1，否则返回实际写入当字节数</p></li><li><p>有一个文件，其文件描述符是 fd，内含下列字节序列：3，1，4，1，5，9，2，6，5，3，5。<br>有如下系统调用：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">lseek(fd, <span class="number">3</span>, SEEK_SET);</span><br><span class="line">read(fd, &amp;buffer, <span class="number">4</span>);</span><br></pre></td></tr></table></figure><p>其中 lseek 调用寻找文件中的第 3 个字节。在读操作完成之后，buffer 中的内容是什么？</p><p>1, 5, 9, 2</p></li><li><p>假设一个 10MB 的文件在磁盘连续扇区的同一个轨道上（轨道号：50）。磁盘的磁头臂此时位于第 100 号轨道。要想从磁盘上找回这个文件，需要多长时间？ 假设磁头臂从一个柱面移动到下一个柱面需要 1ms，当文件的开始部分存储在的扇区旋转到磁头下需要 5ms，并且读的速率是 100MB/s。</p><p>155ms（在 SSD 普及的今天，这道题基本没有意义）</p></li><li><p>块特殊文件和字符特殊文件的基本差别是什么？</p><p>块特殊文件 (block special file) 提供对设备带缓冲的访问<br>字符特殊文件 (character special file) 提供对设备不带缓冲的访问</p></li><li><p>如下图所示，库调用被称为 read，而系统调用自身也被称为 read，这两者都有相问的名字是正常的吗？ 如果不是，哪一个更重要？</p><p>是正常的，因为系统调用实际上并没有名称。当库函数 read 陷入内核时，它将系统调用的编号放在操作系统所期望的地方（寄存器或堆栈）中，然后由内核根据编号执行相应的系统调用，整个过程中不会用到任何名称。而对于库调用来说名称是很重要的，因为我们写的程序中需要使用这个名称。</p><img src="/2018/04/17/operation-system-study-notes-2/system.jpg.png"></li><li><p>在分布式系统中，C-S 模式很普遍。这种模式能用在单个计算机的系统中吗？</p><p>可以</p><p>未完待续</p></li></ol><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://www.techopedia.com/definition/2767/direct-memory-access-dma" target="_blank" rel="noopener">What is Direct Memory Access (DMA)? - Definition from Techopedia</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;习题&quot;&gt;&lt;a href=&quot;#习题&quot; class=&quot;headerlink&quot; title=&quot;习题&quot;&gt;&lt;/a&gt;习题&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;什么是 multiprogramming？&lt;/p&gt;
&lt;p&gt;在第二代操作系统（如 7094 机）上，若当前作业因等待磁带或其他 I/O 操作而暂停时，CPU 就只能简单地原地踏步直至该 I/O 完成。在很多情况下，I/O 操作等待的时间通常占到 80% ~ 90%, 所以要通过 multiprogramming 的方式来减少 CPU 资源的浪费。&lt;/p&gt;
&lt;p&gt;具体方案就是将内存分成多个部分，每个部分存放不同的作业（如下图所示），当一个作业等待 I/O 操作完成时，另一个作业可以使用 CPU。如果内存中可以同时存放足够多的作业，则 CPU 利用率可以接近 100%。（注意：在内存中同时驻留多个作业需要特殊的硬件来对其进行保护，以避免作业对信息被窃取或受到攻击。）&lt;/p&gt;
&lt;img src=&quot;/2018/04/17/operation-system-study-notes-2/multi-programmed-system.jpg&quot;&gt;
    
    </summary>
    
    
      <category term="operating system" scheme="https://cuixiaochen.com/tags/operating-system/"/>
    
  </entry>
  
</feed>
